{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/custom-coder.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Base class for custom video decoders. To add your own custom video decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using `registerDecoder`.\n * @public\n */\nexport class CustomVideoDecoder {\n    /** Returns true iff the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio decoders. To add your own custom audio decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using `registerDecoder`.\n * @public\n */\nexport class CustomAudioDecoder {\n    /** Returns true iff the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom video encoders. To add your own custom video encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using `registerEncoder`.\n * @public\n */\nexport class CustomVideoEncoder {\n    /** Returns true iff the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio encoders. To add your own custom audio encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using `registerEncoder`.\n * @public\n */\nexport class CustomAudioEncoder {\n    /** Returns true iff the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\nexport const customVideoDecoders = [];\nexport const customAudioDecoders = [];\nexport const customVideoEncoders = [];\nexport const customAudioEncoders = [];\n/**\n * Registers a custom video or audio decoder. Registered decoders will automatically be used for decoding whenever\n * possible.\n * @public\n */\nexport const registerDecoder = (decoder) => {\n    if (decoder.prototype instanceof CustomVideoDecoder) {\n        const casted = decoder;\n        if (customVideoDecoders.includes(casted)) {\n            console.warn('Video decoder already registered.');\n            return;\n        }\n        customVideoDecoders.push(casted);\n    }\n    else if (decoder.prototype instanceof CustomAudioDecoder) {\n        const casted = decoder;\n        if (customAudioDecoders.includes(casted)) {\n            console.warn('Audio decoder already registered.');\n            return;\n        }\n        customAudioDecoders.push(casted);\n    }\n    else {\n        throw new TypeError('Decoder must be a CustomVideoDecoder or CustomAudioDecoder.');\n    }\n};\n/**\n * Registers a custom video or audio encoder. Registered encoders will automatically be used for encoding whenever\n * possible.\n * @public\n */\nexport const registerEncoder = (encoder) => {\n    if (encoder.prototype instanceof CustomVideoEncoder) {\n        const casted = encoder;\n        if (customVideoEncoders.includes(casted)) {\n            console.warn('Video encoder already registered.');\n            return;\n        }\n        customVideoEncoders.push(casted);\n    }\n    else if (encoder.prototype instanceof CustomAudioEncoder) {\n        const casted = encoder;\n        if (customAudioEncoders.includes(casted)) {\n            console.warn('Audio encoder already registered.');\n            return;\n        }\n        customAudioEncoders.push(casted);\n    }\n    else {\n        throw new TypeError('Encoder must be a CustomVideoEncoder or CustomAudioEncoder.');\n    }\n};\n"],"names":[],"mappings":"AAAA;;;;;;CAMC,GACD;;;;CAIC;;;;;;;;;;;;AACM,MAAM;IACT,2EAA2E,GAC3E,6DAA6D;IAC7D,OAAO,SAAS,KAAK,EAAE,MAAM,EAAE;QAC3B,OAAO;IACX;AACJ;AAMO,MAAM;IACT,2EAA2E,GAC3E,6DAA6D;IAC7D,OAAO,SAAS,KAAK,EAAE,MAAM,EAAE;QAC3B,OAAO;IACX;AACJ;AAMO,MAAM;IACT,2EAA2E,GAC3E,6DAA6D;IAC7D,OAAO,SAAS,KAAK,EAAE,MAAM,EAAE;QAC3B,OAAO;IACX;AACJ;AAMO,MAAM;IACT,2EAA2E,GAC3E,6DAA6D;IAC7D,OAAO,SAAS,KAAK,EAAE,MAAM,EAAE;QAC3B,OAAO;IACX;AACJ;AACO,MAAM,sBAAsB,EAAE;AAC9B,MAAM,sBAAsB,EAAE;AAC9B,MAAM,sBAAsB,EAAE;AAC9B,MAAM,sBAAsB,EAAE;AAM9B,MAAM,kBAAkB,CAAC;IAC5B,IAAI,QAAQ,SAAS,YAAY,oBAAoB;QACjD,MAAM,SAAS;QACf,IAAI,oBAAoB,QAAQ,CAAC,SAAS;YACtC,QAAQ,IAAI,CAAC;YACb;QACJ;QACA,oBAAoB,IAAI,CAAC;IAC7B,OACK,IAAI,QAAQ,SAAS,YAAY,oBAAoB;QACtD,MAAM,SAAS;QACf,IAAI,oBAAoB,QAAQ,CAAC,SAAS;YACtC,QAAQ,IAAI,CAAC;YACb;QACJ;QACA,oBAAoB,IAAI,CAAC;IAC7B,OACK;QACD,MAAM,IAAI,UAAU;IACxB;AACJ;AAMO,MAAM,kBAAkB,CAAC;IAC5B,IAAI,QAAQ,SAAS,YAAY,oBAAoB;QACjD,MAAM,SAAS;QACf,IAAI,oBAAoB,QAAQ,CAAC,SAAS;YACtC,QAAQ,IAAI,CAAC;YACb;QACJ;QACA,oBAAoB,IAAI,CAAC;IAC7B,OACK,IAAI,QAAQ,SAAS,YAAY,oBAAoB;QACtD,MAAM,SAAS;QACf,IAAI,oBAAoB,QAAQ,CAAC,SAAS;YACtC,QAAQ,IAAI,CAAC;YACb;QACJ;QACA,oBAAoB,IAAI,CAAC;IAC7B,OACK;QACD,MAAM,IAAI,UAAU;IACxB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 97, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/misc.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport function assert(x) {\n    if (!x) {\n        throw new Error('Assertion failed.');\n    }\n}\nexport const normalizeRotation = (rotation) => {\n    const mappedRotation = (rotation % 360 + 360) % 360;\n    if (mappedRotation === 0 || mappedRotation === 90 || mappedRotation === 180 || mappedRotation === 270) {\n        return mappedRotation;\n    }\n    else {\n        throw new Error(`Invalid rotation ${rotation}.`);\n    }\n};\nexport const last = (arr) => {\n    return arr && arr[arr.length - 1];\n};\nexport const isU32 = (value) => {\n    return value >= 0 && value < 2 ** 32;\n};\nexport class Bitstream {\n    constructor(bytes) {\n        this.bytes = bytes;\n        /** Current offset in bits. */\n        this.pos = 0;\n    }\n    seekToByte(byteOffset) {\n        this.pos = 8 * byteOffset;\n    }\n    readBit() {\n        const byteIndex = Math.floor(this.pos / 8);\n        const byte = this.bytes[byteIndex] ?? 0;\n        const bitIndex = 0b111 - (this.pos & 0b111);\n        const bit = (byte & (1 << bitIndex)) >> bitIndex;\n        this.pos++;\n        return bit;\n    }\n    readBits(n) {\n        if (n === 1) {\n            return this.readBit();\n        }\n        let result = 0;\n        for (let i = 0; i < n; i++) {\n            result <<= 1;\n            result |= this.readBit();\n        }\n        return result;\n    }\n    writeBits(n, value) {\n        const end = this.pos + n;\n        for (let i = this.pos; i < end; i++) {\n            const byteIndex = Math.floor(i / 8);\n            let byte = this.bytes[byteIndex];\n            const bitIndex = 0b111 - (i & 0b111);\n            byte &= ~(1 << bitIndex);\n            byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n            this.bytes[byteIndex] = byte;\n        }\n        this.pos = end;\n    }\n    ;\n    readAlignedByte() {\n        // Ensure we're byte-aligned\n        if (this.pos % 8 !== 0) {\n            throw new Error('Bitstream is not byte-aligned.');\n        }\n        const byteIndex = this.pos / 8;\n        const byte = this.bytes[byteIndex] ?? 0;\n        this.pos += 8;\n        return byte;\n    }\n    skipBits(n) {\n        this.pos += n;\n    }\n    getBitsLeft() {\n        return this.bytes.length * 8 - this.pos;\n    }\n    clone() {\n        const clone = new Bitstream(this.bytes);\n        clone.pos = this.pos;\n        return clone;\n    }\n}\n/** Reads an exponential-Golomb universal code from a Bitstream.  */\nexport const readExpGolomb = (bitstream) => {\n    let leadingZeroBits = 0;\n    while (bitstream.readBits(1) === 0 && leadingZeroBits < 32) {\n        leadingZeroBits++;\n    }\n    if (leadingZeroBits >= 32) {\n        throw new Error('Invalid exponential-Golomb code.');\n    }\n    const result = (1 << leadingZeroBits) - 1 + bitstream.readBits(leadingZeroBits);\n    return result;\n};\n/** Reads a signed exponential-Golomb universal code from a Bitstream. */\nexport const readSignedExpGolomb = (bitstream) => {\n    const codeNum = readExpGolomb(bitstream);\n    return ((codeNum & 1) === 0)\n        ? -(codeNum >> 1)\n        : ((codeNum + 1) >> 1);\n};\nexport const writeBits = (bytes, start, end, value) => {\n    for (let i = start; i < end; i++) {\n        const byteIndex = Math.floor(i / 8);\n        let byte = bytes[byteIndex];\n        const bitIndex = 0b111 - (i & 0b111);\n        byte &= ~(1 << bitIndex);\n        byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n        bytes[byteIndex] = byte;\n    }\n};\nexport const toUint8Array = (source) => {\n    if (source instanceof Uint8Array) {\n        return source;\n    }\n    else if (source instanceof ArrayBuffer) {\n        return new Uint8Array(source);\n    }\n    else {\n        return new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    }\n};\nexport const toDataView = (source) => {\n    if (source instanceof DataView) {\n        return source;\n    }\n    else if (source instanceof ArrayBuffer) {\n        return new DataView(source);\n    }\n    else {\n        return new DataView(source.buffer, source.byteOffset, source.byteLength);\n    }\n};\nexport const textEncoder = new TextEncoder();\nconst invertObject = (object) => {\n    return Object.fromEntries(Object.entries(object).map(([key, value]) => [value, key]));\n};\n// For the color space mappings, see Rec. ITU-T H.273.\nexport const COLOR_PRIMARIES_MAP = {\n    bt709: 1, // ITU-R BT.709\n    bt470bg: 5, // ITU-R BT.470BG\n    smpte170m: 6, // ITU-R BT.601 525 - SMPTE 170M\n    bt2020: 9, // ITU-R BT.202\n    smpte432: 12, // SMPTE EG 432-1\n};\nexport const COLOR_PRIMARIES_MAP_INVERSE = invertObject(COLOR_PRIMARIES_MAP);\nexport const TRANSFER_CHARACTERISTICS_MAP = {\n    'bt709': 1, // ITU-R BT.709\n    'smpte170m': 6, // SMPTE 170M\n    'linear': 8, // Linear transfer characteristics\n    'iec61966-2-1': 13, // IEC 61966-2-1\n    'pg': 16, // Rec. ITU-R BT.2100-2 perceptual quantization (PQ) system\n    'hlg': 18, // Rec. ITU-R BT.2100-2 hybrid loggamma (HLG) system\n};\nexport const TRANSFER_CHARACTERISTICS_MAP_INVERSE = invertObject(TRANSFER_CHARACTERISTICS_MAP);\nexport const MATRIX_COEFFICIENTS_MAP = {\n    'rgb': 0, // Identity\n    'bt709': 1, // ITU-R BT.709\n    'bt470bg': 5, // ITU-R BT.470BG\n    'smpte170m': 6, // SMPTE 170M\n    'bt2020-ncl': 9, // ITU-R BT.2020-2 (non-constant luminance)\n};\nexport const MATRIX_COEFFICIENTS_MAP_INVERSE = invertObject(MATRIX_COEFFICIENTS_MAP);\nexport const colorSpaceIsComplete = (colorSpace) => {\n    return (!!colorSpace\n        && !!colorSpace.primaries\n        && !!colorSpace.transfer\n        && !!colorSpace.matrix\n        && colorSpace.fullRange !== undefined);\n};\nexport const isAllowSharedBufferSource = (x) => {\n    return (x instanceof ArrayBuffer\n        || (typeof SharedArrayBuffer !== 'undefined' && x instanceof SharedArrayBuffer)\n        || ArrayBuffer.isView(x));\n};\nexport class AsyncMutex {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n    }\n    async acquire() {\n        let resolver;\n        const nextPromise = new Promise((resolve) => {\n            resolver = resolve;\n        });\n        const currentPromiseAlias = this.currentPromise;\n        this.currentPromise = nextPromise;\n        await currentPromiseAlias;\n        return resolver;\n    }\n}\nexport const bytesToHexString = (bytes) => {\n    return [...bytes].map(x => x.toString(16).padStart(2, '0')).join('');\n};\nexport const reverseBitsU32 = (x) => {\n    x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n    x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);\n    x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);\n    x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);\n    return x >>> 0; // Ensure it's treated as an unsigned 32-bit integer\n};\n/** Returns the smallest index i such that val[i] === key, or -1 if no such index exists. */\nexport const binarySearchExact = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + high) >> 1;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal === key) {\n            ans = mid;\n            high = mid - 1; // Continue searching left to find the lowest index\n        }\n        else if (midVal < key) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Returns the largest index i such that val[i] <= key, or -1 if no such index exists. */\nexport const binarySearchLessOrEqual = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + (high - low + 1) / 2) | 0;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal <= key) {\n            ans = mid;\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Assumes the array is already sorted. */\nexport const insertSorted = (arr, item, valueGetter) => {\n    const insertionIndex = binarySearchLessOrEqual(arr, valueGetter(item), valueGetter);\n    arr.splice(insertionIndex + 1, 0, item); // This even behaves correctly for the -1 case\n};\nexport const promiseWithResolvers = () => {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve: resolve, reject: reject };\n};\nexport const removeItem = (arr, item) => {\n    const index = arr.indexOf(item);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n};\nexport const findLast = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return arr[i];\n        }\n    }\n    return undefined;\n};\nexport const findLastIndex = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n};\nexport const toAsyncIterator = async function* (source) {\n    if (Symbol.iterator in source) {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.iterator]();\n    }\n    else {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.asyncIterator]();\n    }\n};\nexport const validateAnyIterable = (iterable) => {\n    if (!(Symbol.iterator in iterable) && !(Symbol.asyncIterator in iterable)) {\n        throw new TypeError('Argument must be an iterable or async iterable.');\n    }\n};\nexport const assertNever = (x) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new Error(`Unexpected value: ${x}`);\n};\nexport const getUint24 = (view, byteOffset, littleEndian) => {\n    const byte1 = view.getUint8(byteOffset);\n    const byte2 = view.getUint8(byteOffset + 1);\n    const byte3 = view.getUint8(byteOffset + 2);\n    if (littleEndian) {\n        return byte1 | (byte2 << 8) | (byte3 << 16);\n    }\n    else {\n        return (byte1 << 16) | (byte2 << 8) | byte3;\n    }\n};\nexport const getInt24 = (view, byteOffset, littleEndian) => {\n    // The left shift pushes the most significant bit into the sign bit region, and the subsequent right shift\n    // then correctly interprets the sign bit.\n    return getUint24(view, byteOffset, littleEndian) << 8 >> 8;\n};\nexport const setUint24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit unsigned range (0 to 16777215)\n    value = value >>> 0; // Convert to unsigned 32-bit\n    value = value & 0xFFFFFF; // Mask to 24 bits\n    if (littleEndian) {\n        view.setUint8(byteOffset, value & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, (value >>> 16) & 0xFF);\n    }\n    else {\n        view.setUint8(byteOffset, (value >>> 16) & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, value & 0xFF);\n    }\n};\nexport const setInt24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit signed range (-8388608 to 8388607)\n    value = clamp(value, -8388608, 8388607);\n    // Convert negative values to their 24-bit representation\n    if (value < 0) {\n        value = (value + 0x1000000) & 0xFFFFFF;\n    }\n    setUint24(view, byteOffset, value, littleEndian);\n};\nexport const setInt64 = (view, byteOffset, value, littleEndian) => {\n    if (littleEndian) {\n        view.setUint32(byteOffset + 0, value, true);\n        view.setInt32(byteOffset + 4, Math.floor(value / 2 ** 32), true);\n    }\n    else {\n        view.setInt32(byteOffset + 0, Math.floor(value / 2 ** 32), true);\n        view.setUint32(byteOffset + 4, value, true);\n    }\n};\n/**\n * Calls a function on each value spat out by an async generator. The reason for writing this manually instead of\n * using a generator function is that the generator function queues return() calls - here, we forward them immediately.\n */\nexport const mapAsyncGenerator = (generator, map) => {\n    return {\n        async next() {\n            const result = await generator.next();\n            if (result.done) {\n                return { value: undefined, done: true };\n            }\n            else {\n                return { value: map(result.value), done: false };\n            }\n        },\n        return() {\n            return generator.return();\n        },\n        throw(error) {\n            return generator.throw(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n};\nexport const clamp = (value, min, max) => {\n    return Math.max(min, Math.min(max, value));\n};\nexport const UNDETERMINED_LANGUAGE = 'und';\nexport const roundToPrecision = (value, digits) => {\n    const factor = 10 ** digits;\n    return Math.round(value * factor) / factor;\n};\nexport const roundToMultiple = (value, multiple) => {\n    return Math.round(value / multiple) * multiple;\n};\nexport const ilog = (x) => {\n    let ret = 0;\n    while (x) {\n        ret++;\n        x >>= 1;\n    }\n    return ret;\n};\nconst ISO_639_2_REGEX = /^[a-z]{3}$/;\nexport const isIso639Dash2LanguageCode = (x) => {\n    return ISO_639_2_REGEX.test(x);\n};\n// Since the result will be truncated, add a bit of eps to compensate for floating point errors\nexport const SECOND_TO_MICROSECOND_FACTOR = 1e6 * (1 + Number.EPSILON);\nexport const mergeObjectsDeeply = (a, b) => {\n    const result = { ...a };\n    for (const key in b) {\n        if (typeof a[key] === 'object'\n            && a[key] !== null\n            && typeof b[key] === 'object'\n            && b[key] !== null) {\n            result[key] = mergeObjectsDeeply(a[key], b[key]);\n        }\n        else {\n            result[key] = b[key];\n        }\n    }\n    return result;\n};\nexport const retriedFetch = async (url, requestInit, getRetryDelay) => {\n    let attempts = 0;\n    while (true) {\n        try {\n            return await fetch(url, requestInit);\n        }\n        catch (error) {\n            attempts++;\n            const retryDelayInSeconds = getRetryDelay(attempts);\n            if (retryDelayInSeconds === null) {\n                throw error;\n            }\n            console.error('Retrying failed fetch. Error:', error);\n            if (!Number.isFinite(retryDelayInSeconds) || retryDelayInSeconds < 0) {\n                throw new TypeError('Retry delay must be a non-negative finite number.');\n            }\n            if (retryDelayInSeconds > 0) {\n                await new Promise(resolve => setTimeout(resolve, 1000 * retryDelayInSeconds));\n            }\n        }\n    }\n};\nexport const computeRationalApproximation = (x, maxDenominator) => {\n    // Handle negative numbers\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let prevNumerator = 0, prevDenominator = 1;\n    let currNumerator = 1, currDenominator = 0;\n    // Continued fraction algorithm\n    let remainder = x;\n    while (true) {\n        const integer = Math.floor(remainder);\n        // Calculate next convergent\n        const nextNumerator = integer * currNumerator + prevNumerator;\n        const nextDenominator = integer * currDenominator + prevDenominator;\n        if (nextDenominator > maxDenominator) {\n            return {\n                numerator: sign * currNumerator,\n                denominator: currDenominator,\n            };\n        }\n        prevNumerator = currNumerator;\n        prevDenominator = currDenominator;\n        currNumerator = nextNumerator;\n        currDenominator = nextDenominator;\n        remainder = 1 / (remainder - integer);\n        // Guard against precision issues\n        if (!isFinite(remainder)) {\n            break;\n        }\n    }\n    return {\n        numerator: sign * currNumerator,\n        denominator: currDenominator,\n    };\n};\nexport class CallSerializer {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n    }\n    call(fn) {\n        return this.currentPromise = this.currentPromise.then(fn);\n    }\n}\nlet isSafariCache = null;\nexport const isSafari = () => {\n    if (isSafariCache !== null) {\n        return isSafariCache;\n    }\n    const result = !!(typeof navigator !== 'undefined'\n        && navigator.vendor?.match(/apple/i)\n        && !navigator.userAgent?.match(/crios/i)\n        && !navigator.userAgent?.match(/fxios/i)\n        && !navigator.userAgent?.match(/Opera|OPT\\//));\n    isSafariCache = result;\n    return result;\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/codec.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { customAudioEncoders, customVideoEncoders } from './custom-coder.js';\nimport { Bitstream, COLOR_PRIMARIES_MAP, MATRIX_COEFFICIENTS_MAP, TRANSFER_CHARACTERISTICS_MAP, assert, bytesToHexString, isAllowSharedBufferSource, last, reverseBitsU32, toDataView, } from './misc.js';\n/**\n * List of known video codecs, ordered by encoding preference.\n * @public\n */\nexport const VIDEO_CODECS = [\n    'avc',\n    'hevc',\n    'vp9',\n    'av1',\n    'vp8',\n];\n/**\n * List of known PCM (uncompressed) audio codecs, ordered by encoding preference.\n * @public\n */\nexport const PCM_AUDIO_CODECS = [\n    'pcm-s16', // We don't prefix 'le' so we're compatible with the WebCodecs-registered PCM codec strings\n    'pcm-s16be',\n    'pcm-s24',\n    'pcm-s24be',\n    'pcm-s32',\n    'pcm-s32be',\n    'pcm-f32',\n    'pcm-f32be',\n    'pcm-f64',\n    'pcm-f64be',\n    'pcm-u8',\n    'pcm-s8',\n    'ulaw',\n    'alaw',\n];\n/**\n * List of known compressed audio codecs, ordered by encoding preference.\n * @public\n */\nexport const NON_PCM_AUDIO_CODECS = [\n    'aac',\n    'opus',\n    'mp3',\n    'vorbis',\n    'flac',\n];\n/**\n * List of known audio codecs, ordered by encoding preference.\n * @public\n */\nexport const AUDIO_CODECS = [\n    ...NON_PCM_AUDIO_CODECS,\n    ...PCM_AUDIO_CODECS,\n];\n/**\n * List of known subtitle codecs, ordered by encoding preference.\n * @public\n */\nexport const SUBTITLE_CODECS = [\n    'webvtt',\n]; // TODO add the rest\n// https://en.wikipedia.org/wiki/Advanced_Video_Coding\nconst AVC_LEVEL_TABLE = [\n    { maxMacroblocks: 99, maxBitrate: 64000, level: 0x0A }, // Level 1\n    { maxMacroblocks: 396, maxBitrate: 192000, level: 0x0B }, // Level 1.1\n    { maxMacroblocks: 396, maxBitrate: 384000, level: 0x0C }, // Level 1.2\n    { maxMacroblocks: 396, maxBitrate: 768000, level: 0x0D }, // Level 1.3\n    { maxMacroblocks: 396, maxBitrate: 2000000, level: 0x14 }, // Level 2\n    { maxMacroblocks: 792, maxBitrate: 4000000, level: 0x15 }, // Level 2.1\n    { maxMacroblocks: 1620, maxBitrate: 4000000, level: 0x16 }, // Level 2.2\n    { maxMacroblocks: 1620, maxBitrate: 10000000, level: 0x1E }, // Level 3\n    { maxMacroblocks: 3600, maxBitrate: 14000000, level: 0x1F }, // Level 3.1\n    { maxMacroblocks: 5120, maxBitrate: 20000000, level: 0x20 }, // Level 3.2\n    { maxMacroblocks: 8192, maxBitrate: 20000000, level: 0x28 }, // Level 4\n    { maxMacroblocks: 8192, maxBitrate: 50000000, level: 0x29 }, // Level 4.1\n    { maxMacroblocks: 8704, maxBitrate: 50000000, level: 0x2A }, // Level 4.2\n    { maxMacroblocks: 22080, maxBitrate: 135000000, level: 0x32 }, // Level 5\n    { maxMacroblocks: 36864, maxBitrate: 240000000, level: 0x33 }, // Level 5.1\n    { maxMacroblocks: 36864, maxBitrate: 240000000, level: 0x34 }, // Level 5.2\n    { maxMacroblocks: 139264, maxBitrate: 240000000, level: 0x3C }, // Level 6\n    { maxMacroblocks: 139264, maxBitrate: 480000000, level: 0x3D }, // Level 6.1\n    { maxMacroblocks: 139264, maxBitrate: 800000000, level: 0x3E }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding\nconst HEVC_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 128000, tier: 'L', level: 30 }, // Level 1 (Low Tier)\n    { maxPictureSize: 122880, maxBitrate: 1500000, tier: 'L', level: 60 }, // Level 2 (Low Tier)\n    { maxPictureSize: 245760, maxBitrate: 3000000, tier: 'L', level: 63 }, // Level 2.1 (Low Tier)\n    { maxPictureSize: 552960, maxBitrate: 6000000, tier: 'L', level: 90 }, // Level 3 (Low Tier)\n    { maxPictureSize: 983040, maxBitrate: 10000000, tier: 'L', level: 93 }, // Level 3.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 12000000, tier: 'L', level: 120 }, // Level 4 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 30000000, tier: 'H', level: 120 }, // Level 4 (High Tier)\n    { maxPictureSize: 2228224, maxBitrate: 20000000, tier: 'L', level: 123 }, // Level 4.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 50000000, tier: 'H', level: 123 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 25000000, tier: 'L', level: 150 }, // Level 5 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 150 }, // Level 5 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'L', level: 153 }, // Level 5.1 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 153 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'L', level: 156 }, // Level 5.2 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 156 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'L', level: 180 }, // Level 6 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 180 }, // Level 6 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 120000000, tier: 'L', level: 183 }, // Level 6.1 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 183 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'L', level: 186 }, // Level 6.2 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 186 }, // Level 6.2 (High Tier)\n];\n// https://en.wikipedia.org/wiki/VP9\nexport const VP9_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 200000, level: 10 }, // Level 1\n    { maxPictureSize: 73728, maxBitrate: 800000, level: 11 }, // Level 1.1\n    { maxPictureSize: 122880, maxBitrate: 1800000, level: 20 }, // Level 2\n    { maxPictureSize: 245760, maxBitrate: 3600000, level: 21 }, // Level 2.1\n    { maxPictureSize: 552960, maxBitrate: 7200000, level: 30 }, // Level 3\n    { maxPictureSize: 983040, maxBitrate: 12000000, level: 31 }, // Level 3.1\n    { maxPictureSize: 2228224, maxBitrate: 18000000, level: 40 }, // Level 4\n    { maxPictureSize: 2228224, maxBitrate: 30000000, level: 41 }, // Level 4.1\n    { maxPictureSize: 8912896, maxBitrate: 60000000, level: 50 }, // Level 5\n    { maxPictureSize: 8912896, maxBitrate: 120000000, level: 51 }, // Level 5.1\n    { maxPictureSize: 8912896, maxBitrate: 180000000, level: 52 }, // Level 5.2\n    { maxPictureSize: 35651584, maxBitrate: 180000000, level: 60 }, // Level 6\n    { maxPictureSize: 35651584, maxBitrate: 240000000, level: 61 }, // Level 6.1\n    { maxPictureSize: 35651584, maxBitrate: 480000000, level: 62 }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/AV1\nconst AV1_LEVEL_TABLE = [\n    { maxPictureSize: 147456, maxBitrate: 1500000, tier: 'M', level: 0 }, // Level 2.0 (Main Tier)\n    { maxPictureSize: 278784, maxBitrate: 3000000, tier: 'M', level: 1 }, // Level 2.1 (Main Tier)\n    { maxPictureSize: 665856, maxBitrate: 6000000, tier: 'M', level: 4 }, // Level 3.0 (Main Tier)\n    { maxPictureSize: 1065024, maxBitrate: 10000000, tier: 'M', level: 5 }, // Level 3.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 12000000, tier: 'M', level: 8 }, // Level 4.0 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 30000000, tier: 'H', level: 8 }, // Level 4.0 (High Tier)\n    { maxPictureSize: 2359296, maxBitrate: 20000000, tier: 'M', level: 9 }, // Level 4.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 50000000, tier: 'H', level: 9 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 30000000, tier: 'M', level: 12 }, // Level 5.0 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 12 }, // Level 5.0 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'M', level: 13 }, // Level 5.1 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 13 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'M', level: 14 }, // Level 5.2 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 14 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 15 }, // Level 5.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 15 }, // Level 5.3 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 16 }, // Level 6.0 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 16 }, // Level 6.0 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 100000000, tier: 'M', level: 17 }, // Level 6.1 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 17 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 18 }, // Level 6.2 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 18 }, // Level 6.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 19 }, // Level 6.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 19 }, // Level 6.3 (High Tier)\n];\nconst VP9_DEFAULT_SUFFIX = '.01.01.01.01.00';\nconst AV1_DEFAULT_SUFFIX = '.0.110.01.01.01.0';\nexport const buildVideoCodecString = (codec, width, height, bitrate) => {\n    if (codec === 'avc') {\n        const profileIndication = 0x64; // High Profile\n        const totalMacroblocks = Math.ceil(width / 16) * Math.ceil(height / 16);\n        // Determine the level based on the table\n        const levelInfo = AVC_LEVEL_TABLE.find(level => totalMacroblocks <= level.maxMacroblocks && bitrate <= level.maxBitrate) ?? last(AVC_LEVEL_TABLE);\n        const levelIndication = levelInfo ? levelInfo.level : 0;\n        const hexProfileIndication = profileIndication.toString(16).padStart(2, '0');\n        const hexProfileCompatibility = '00';\n        const hexLevelIndication = levelIndication.toString(16).padStart(2, '0');\n        return `avc1.${hexProfileIndication}${hexProfileCompatibility}${hexLevelIndication}`;\n    }\n    else if (codec === 'hevc') {\n        const profilePrefix = ''; // Profile space 0\n        const profileIdc = 1; // Main Profile\n        const compatibilityFlags = '6'; // Taken from the example in ISO 14496-15\n        const pictureSize = width * height;\n        const levelInfo = HEVC_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(HEVC_LEVEL_TABLE);\n        const constraintFlags = 'B0'; // Progressive source flag\n        return 'hev1.'\n            + `${profilePrefix}${profileIdc}.`\n            + `${compatibilityFlags}.`\n            + `${levelInfo.tier}${levelInfo.level}.`\n            + `${constraintFlags}`;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        const profile = '00'; // Profile 0\n        const pictureSize = width * height;\n        const levelInfo = VP9_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(VP9_LEVEL_TABLE);\n        const bitDepth = '08'; // 8-bit\n        return `vp09.${profile}.${levelInfo.level.toString().padStart(2, '0')}.${bitDepth}`;\n    }\n    else if (codec === 'av1') {\n        const profile = 0; // Main Profile, single digit\n        const pictureSize = width * height;\n        const levelInfo = AV1_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(AV1_LEVEL_TABLE);\n        const level = levelInfo.level.toString().padStart(2, '0');\n        const bitDepth = '08'; // 8-bit\n        return `av01.${profile}.${level}${levelInfo.tier}.${bitDepth}`;\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const generateVp9CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://www.webmproject.org/docs/container/#vp9-codec-feature-metadata-codecprivate\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1;\n    return [\n        1, 1, profile,\n        2, 1, level,\n        3, 1, bitDepth,\n        4, 1, chromaSubsampling,\n    ];\n};\nexport const generateAv1CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://aomediacodec.github.io/av1-isobmff/\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const marker = 1;\n    const version = 1;\n    const firstByte = (marker << 7) + version;\n    const profile = Number(parts[1]);\n    const levelAndTier = parts[2];\n    const level = Number(levelAndTier.slice(0, -1));\n    const secondByte = (profile << 5) + level;\n    const tier = levelAndTier.slice(-1) === 'H' ? 1 : 0;\n    const bitDepth = Number(parts[3]);\n    const highBitDepth = bitDepth === 8 ? 0 : 1;\n    const twelveBit = 0;\n    const monochrome = parts[4] ? Number(parts[4]) : 0;\n    const chromaSubsamplingX = parts[5] ? Number(parts[5][0]) : 1;\n    const chromaSubsamplingY = parts[5] ? Number(parts[5][1]) : 1;\n    const chromaSamplePosition = parts[5] ? Number(parts[5][2]) : 0; // CSP_UNKNOWN\n    const thirdByte = (tier << 7)\n        + (highBitDepth << 6)\n        + (twelveBit << 5)\n        + (monochrome << 4)\n        + (chromaSubsamplingX << 3)\n        + (chromaSubsamplingY << 2)\n        + chromaSamplePosition;\n    const initialPresentationDelayPresent = 0; // Should be fine\n    const fourthByte = initialPresentationDelayPresent;\n    return [firstByte, secondByte, thirdByte, fourthByte];\n};\nexport const extractVideoCodecString = (trackInfo) => {\n    const { codec, codecDescription, colorSpace, avcCodecInfo, hevcCodecInfo, vp9CodecInfo, av1CodecInfo } = trackInfo;\n    if (codec === 'avc') {\n        if (avcCodecInfo) {\n            const bytes = new Uint8Array([\n                avcCodecInfo.avcProfileIndication,\n                avcCodecInfo.profileCompatibility,\n                avcCodecInfo.avcLevelIndication,\n            ]);\n            return `avc1.${bytesToHexString(bytes)}`;\n        }\n        if (!codecDescription || codecDescription.byteLength < 4) {\n            throw new TypeError('AVC decoder description is not provided or is not at least 4 bytes long.');\n        }\n        return `avc1.${bytesToHexString(codecDescription.subarray(1, 4))}`;\n    }\n    else if (codec === 'hevc') {\n        let generalProfileSpace;\n        let generalProfileIdc;\n        let compatibilityFlags;\n        let generalTierFlag;\n        let generalLevelIdc;\n        let constraintFlags;\n        if (hevcCodecInfo) {\n            generalProfileSpace = hevcCodecInfo.generalProfileSpace;\n            generalProfileIdc = hevcCodecInfo.generalProfileIdc;\n            compatibilityFlags = reverseBitsU32(hevcCodecInfo.generalProfileCompatibilityFlags);\n            generalTierFlag = hevcCodecInfo.generalTierFlag;\n            generalLevelIdc = hevcCodecInfo.generalLevelIdc;\n            constraintFlags = [...hevcCodecInfo.generalConstraintIndicatorFlags];\n        }\n        else {\n            if (!codecDescription || codecDescription.byteLength < 23) {\n                throw new TypeError('HEVC decoder description is not provided or is not at least 23 bytes long.');\n            }\n            const view = toDataView(codecDescription);\n            const profileByte = view.getUint8(1);\n            generalProfileSpace = (profileByte >> 6) & 0x03;\n            generalProfileIdc = profileByte & 0x1F;\n            compatibilityFlags = reverseBitsU32(view.getUint32(2));\n            generalTierFlag = (profileByte >> 5) & 0x01;\n            generalLevelIdc = view.getUint8(12);\n            constraintFlags = [];\n            for (let i = 0; i < 6; i++) {\n                constraintFlags.push(view.getUint8(6 + i));\n            }\n        }\n        let codecString = 'hev1.';\n        codecString += ['', 'A', 'B', 'C'][generalProfileSpace] + generalProfileIdc;\n        codecString += '.';\n        codecString += compatibilityFlags.toString(16).toUpperCase();\n        codecString += '.';\n        codecString += generalTierFlag === 0 ? 'L' : 'H';\n        codecString += generalLevelIdc;\n        while (constraintFlags.length > 0 && constraintFlags[constraintFlags.length - 1] === 0) {\n            constraintFlags.pop();\n        }\n        if (constraintFlags.length > 0) {\n            codecString += '.';\n            codecString += constraintFlags.map(x => x.toString(16).toUpperCase()).join('.');\n        }\n        return codecString;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        if (!vp9CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `vp09.00.${level.toString().padStart(2, '0')}.08`;\n        }\n        const profile = vp9CodecInfo.profile.toString().padStart(2, '0');\n        const level = vp9CodecInfo.level.toString().padStart(2, '0');\n        const bitDepth = vp9CodecInfo.bitDepth.toString().padStart(2, '0');\n        const chromaSubsampling = vp9CodecInfo.chromaSubsampling.toString().padStart(2, '0');\n        const colourPrimaries = vp9CodecInfo.colourPrimaries.toString().padStart(2, '0');\n        const transferCharacteristics = vp9CodecInfo.transferCharacteristics.toString().padStart(2, '0');\n        const matrixCoefficients = vp9CodecInfo.matrixCoefficients.toString().padStart(2, '0');\n        const videoFullRangeFlag = vp9CodecInfo.videoFullRangeFlag.toString().padStart(2, '0');\n        let string = `vp09.${profile}.${level}.${bitDepth}.${chromaSubsampling}`;\n        string += `.${colourPrimaries}.${transferCharacteristics}.${matrixCoefficients}.${videoFullRangeFlag}`;\n        if (string.endsWith(VP9_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -VP9_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    else if (codec === 'av1') {\n        if (!av1CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `av01.0.${level.toString().padStart(2, '0')}M.08`;\n        }\n        // https://aomediacodec.github.io/av1-isobmff/#codecsparam\n        const profile = av1CodecInfo.profile; // Single digit\n        const level = av1CodecInfo.level.toString().padStart(2, '0');\n        const tier = av1CodecInfo.tier ? 'H' : 'M';\n        const bitDepth = av1CodecInfo.bitDepth.toString().padStart(2, '0');\n        const monochrome = av1CodecInfo.monochrome ? '1' : '0';\n        const chromaSubsampling = 100 * av1CodecInfo.chromaSubsamplingX\n            + 10 * av1CodecInfo.chromaSubsamplingY\n            + 1 * (av1CodecInfo.chromaSubsamplingX && av1CodecInfo.chromaSubsamplingY\n                ? av1CodecInfo.chromaSamplePosition\n                : 0);\n        // The defaults are 1 (ITU-R BT.709)\n        const colorPrimaries = colorSpace?.primaries ? COLOR_PRIMARIES_MAP[colorSpace.primaries] : 1;\n        const transferCharacteristics = colorSpace?.transfer ? TRANSFER_CHARACTERISTICS_MAP[colorSpace.transfer] : 1;\n        const matrixCoefficients = colorSpace?.matrix ? MATRIX_COEFFICIENTS_MAP[colorSpace.matrix] : 1;\n        const videoFullRangeFlag = colorSpace?.fullRange ? 1 : 0;\n        let string = `av01.${profile}.${level}${tier}.${bitDepth}`;\n        string += `.${monochrome}.${chromaSubsampling.toString().padStart(3, '0')}`;\n        string += `.${colorPrimaries.toString().padStart(2, '0')}`;\n        string += `.${transferCharacteristics.toString().padStart(2, '0')}`;\n        string += `.${matrixCoefficients.toString().padStart(2, '0')}`;\n        string += `.${videoFullRangeFlag}`;\n        if (string.endsWith(AV1_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -AV1_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const buildAudioCodecString = (codec, numberOfChannels, sampleRate) => {\n    if (codec === 'aac') {\n        // If stereo or higher channels and lower sample rate, likely using HE-AAC v2 with PS\n        if (numberOfChannels >= 2 && sampleRate <= 24000) {\n            return 'mp4a.40.29'; // HE-AAC v2 (AAC LC + SBR + PS)\n        }\n        // If sample rate is low, likely using HE-AAC v1 with SBR\n        if (sampleRate <= 24000) {\n            return 'mp4a.40.5'; // HE-AAC v1 (AAC LC + SBR)\n        }\n        // Default to standard AAC-LC for higher sample rates\n        return 'mp4a.40.2'; // AAC-LC\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const extractAudioCodecString = (trackInfo) => {\n    const { codec, codecDescription, aacCodecInfo } = trackInfo;\n    if (codec === 'aac') {\n        if (!aacCodecInfo) {\n            throw new TypeError('AAC codec info must be provided.');\n        }\n        if (aacCodecInfo.isMpeg2) {\n            return 'mp4a.67';\n        }\n        else {\n            const audioSpecificConfig = parseAacAudioSpecificConfig(codecDescription);\n            return `mp4a.40.${audioSpecificConfig.objectType}`;\n        }\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (codec && PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const aacFrequencyTable = [\n    96000, 88200, 64000, 48000, 44100, 32000,\n    24000, 22050, 16000, 12000, 11025, 8000, 7350,\n];\nexport const aacChannelMap = [-1, 1, 2, 3, 4, 5, 6, 8];\nexport const parseAacAudioSpecificConfig = (bytes) => {\n    if (!bytes || bytes.byteLength < 2) {\n        throw new TypeError('AAC description must be at least 2 bytes long.');\n    }\n    const bitstream = new Bitstream(bytes);\n    let objectType = bitstream.readBits(5);\n    if (objectType === 31) {\n        objectType = 32 + bitstream.readBits(6);\n    }\n    const frequencyIndex = bitstream.readBits(4);\n    let sampleRate = null;\n    if (frequencyIndex === 15) {\n        sampleRate = bitstream.readBits(24);\n    }\n    else {\n        if (frequencyIndex < aacFrequencyTable.length) {\n            sampleRate = aacFrequencyTable[frequencyIndex];\n        }\n    }\n    const channelConfiguration = bitstream.readBits(4);\n    let numberOfChannels = null;\n    if (channelConfiguration >= 1 && channelConfiguration <= 7) {\n        numberOfChannels = aacChannelMap[channelConfiguration];\n    }\n    return {\n        objectType,\n        frequencyIndex,\n        sampleRate,\n        channelConfiguration,\n        numberOfChannels,\n    };\n};\nexport const OPUS_INTERNAL_SAMPLE_RATE = 48000;\nconst PCM_CODEC_REGEX = /^pcm-([usf])(\\d+)+(be)?$/;\nexport const parsePcmCodec = (codec) => {\n    assert(PCM_AUDIO_CODECS.includes(codec));\n    if (codec === 'ulaw') {\n        return { dataType: 'ulaw', sampleSize: 1, littleEndian: true, silentValue: 255 };\n    }\n    else if (codec === 'alaw') {\n        return { dataType: 'alaw', sampleSize: 1, littleEndian: true, silentValue: 213 };\n    }\n    const match = PCM_CODEC_REGEX.exec(codec);\n    assert(match);\n    let dataType;\n    if (match[1] === 'u') {\n        dataType = 'unsigned';\n    }\n    else if (match[1] === 's') {\n        dataType = 'signed';\n    }\n    else {\n        dataType = 'float';\n    }\n    const sampleSize = (Number(match[2]) / 8);\n    const littleEndian = match[3] !== 'be';\n    const silentValue = codec === 'pcm-u8' ? 2 ** 7 : 0;\n    return { dataType, sampleSize, littleEndian, silentValue };\n};\nexport const inferCodecFromCodecString = (codecString) => {\n    // Video codecs\n    if (codecString.startsWith('avc1') || codecString.startsWith('avc3')) {\n        return 'avc';\n    }\n    else if (codecString.startsWith('hev1') || codecString.startsWith('hvc1')) {\n        return 'hevc';\n    }\n    else if (codecString === 'vp8') {\n        return 'vp8';\n    }\n    else if (codecString.startsWith('vp09')) {\n        return 'vp9';\n    }\n    else if (codecString.startsWith('av01')) {\n        return 'av1';\n    }\n    // Audio codecs\n    if (codecString.startsWith('mp4a.40') || codecString === 'mp4a.67') {\n        return 'aac';\n    }\n    else if (codecString === 'mp3'\n        || codecString === 'mp4a.69'\n        || codecString === 'mp4a.6B'\n        || codecString === 'mp4a.6b') {\n        return 'mp3';\n    }\n    else if (codecString === 'opus') {\n        return 'opus';\n    }\n    else if (codecString === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codecString === 'flac') {\n        return 'flac';\n    }\n    else if (codecString === 'ulaw') {\n        return 'ulaw';\n    }\n    else if (codecString === 'alaw') {\n        return 'alaw';\n    }\n    else if (PCM_CODEC_REGEX.test(codecString)) {\n        return codecString;\n    }\n    // Subtitle codecs\n    if (codecString === 'webvtt') {\n        return 'webvtt';\n    }\n    return null;\n};\nexport const getVideoEncoderConfigExtension = (codec) => {\n    if (codec === 'avc') {\n        return {\n            avc: {\n                format: 'avc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    else if (codec === 'hevc') {\n        return {\n            hevc: {\n                format: 'hevc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    return {};\n};\nexport const getAudioEncoderConfigExtension = (codec) => {\n    if (codec === 'aac') {\n        return {\n            aac: {\n                format: 'aac', // Ensure the format is not ADTS\n            },\n        };\n    }\n    else if (codec === 'opus') {\n        return {\n            opus: {\n                format: 'opus',\n            },\n        };\n    }\n    return {};\n};\n/**\n * Represents a subjective media quality level.\n * @public\n */\nexport class Quality {\n    /** @internal */\n    constructor(factor) {\n        this._factor = factor;\n    }\n    /** @internal */\n    _toVideoBitrate(codec, width, height) {\n        const pixels = width * height;\n        const codecEfficiencyFactors = {\n            avc: 1.0, // H.264/AVC (baseline)\n            hevc: 0.6, // H.265/HEVC (~40% more efficient than AVC)\n            vp9: 0.6, // Similar to HEVC\n            av1: 0.4, // ~60% more efficient than AVC\n            vp8: 1.2, // Slightly less efficient than AVC\n        };\n        const referencePixels = 1920 * 1080;\n        const referenceBitrate = 3000000;\n        const scaleFactor = Math.pow(pixels / referencePixels, 0.95); // Slight non-linear scaling\n        const baseBitrate = referenceBitrate * scaleFactor;\n        const codecAdjustedBitrate = baseBitrate * codecEfficiencyFactors[codec];\n        const finalBitrate = codecAdjustedBitrate * this._factor;\n        return Math.ceil(finalBitrate / 1000) * 1000;\n    }\n    /** @internal */\n    _toAudioBitrate(codec) {\n        if (PCM_AUDIO_CODECS.includes(codec) || codec === 'flac') {\n            return undefined;\n        }\n        const baseRates = {\n            aac: 128000, // 128kbps base for AAC\n            opus: 64000, // 64kbps base for Opus\n            mp3: 160000, // 160kbps base for MP3\n            vorbis: 64000, // 64kbps base for Vorbis\n        };\n        const baseBitrate = baseRates[codec];\n        if (!baseBitrate) {\n            throw new Error(`Unhandled codec: ${codec}`);\n        }\n        let finalBitrate = baseBitrate * this._factor;\n        if (codec === 'aac') {\n            // AAC only works with specific bitrates, let's find the closest\n            const validRates = [96000, 128000, 160000, 192000];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        else if (codec === 'opus' || codec === 'vorbis') {\n            finalBitrate = Math.max(6000, finalBitrate);\n        }\n        else if (codec === 'mp3') {\n            const validRates = [\n                8000, 16000, 24000, 32000, 40000, 48000, 64000, 80000,\n                96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000,\n            ];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        return Math.round(finalBitrate / 1000) * 1000;\n    }\n}\n/**\n * Represents a very low media quality.\n * @public\n */\nexport const QUALITY_VERY_LOW = new Quality(0.3);\n/**\n * Represents a low media quality.\n * @public\n */\nexport const QUALITY_LOW = new Quality(0.6);\n/**\n * Represents a medium media quality.\n * @public\n */\nexport const QUALITY_MEDIUM = new Quality(1);\n/**\n * Represents a high media quality.\n * @public\n */\nexport const QUALITY_HIGH = new Quality(2);\n/**\n * Represents a very high media quality.\n * @public\n */\nexport const QUALITY_VERY_HIGH = new Quality(4);\nconst VALID_VIDEO_CODEC_STRING_PREFIXES = ['avc1', 'avc3', 'hev1', 'hvc1', 'vp8', 'vp09', 'av01'];\nconst AVC_CODEC_STRING_REGEX = /^(avc1|avc3)\\.[0-9a-fA-F]{6}$/;\nconst HEVC_CODEC_STRING_REGEX = /^(hev1|hvc1)\\.(?:[ABC]?\\d+)\\.[0-9a-fA-F]{1,8}\\.[LH]\\d+(?:\\.[0-9a-fA-F]{1,2}){0,6}$/;\nconst VP9_CODEC_STRING_REGEX = /^vp09(?:\\.\\d{2}){3}(?:(?:\\.\\d{2}){5})?$/;\nconst AV1_CODEC_STRING_REGEX = /^av01\\.\\d\\.\\d{2}[MH]\\.\\d{2}(?:\\.\\d\\.\\d{3}\\.\\d{2}\\.\\d{2}\\.\\d{2}\\.\\d)?$/;\nexport const validateVideoChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Video chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Video chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Video chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Video chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_VIDEO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedWidth) || metadata.decoderConfig.codedWidth <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedHeight) || metadata.decoderConfig.codedHeight <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!isAllowSharedBufferSource(metadata.decoderConfig.description)) {\n            throw new TypeError('Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.colorSpace !== undefined) {\n        const { colorSpace } = metadata.decoderConfig;\n        if (typeof colorSpace !== 'object') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace, when provided, must be an object.');\n        }\n        const primariesValues = Object.keys(COLOR_PRIMARIES_MAP);\n        if (colorSpace.primaries != null && !primariesValues.includes(colorSpace.primaries)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of`\n                + ` ${primariesValues.join(', ')}.`);\n        }\n        const transferValues = Object.keys(TRANSFER_CHARACTERISTICS_MAP);\n        if (colorSpace.transfer != null && !transferValues.includes(colorSpace.transfer)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of`\n                + ` ${transferValues.join(', ')}.`);\n        }\n        const matrixValues = Object.keys(MATRIX_COEFFICIENTS_MAP);\n        if (colorSpace.matrix != null && !matrixValues.includes(colorSpace.matrix)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of`\n                + ` ${matrixValues.join(', ')}.`);\n        }\n        if (colorSpace.fullRange != null && typeof colorSpace.fullRange !== 'boolean') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('avc1') || metadata.decoderConfig.codec.startsWith('avc3')) {\n        // AVC-specific validation\n        if (!AVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as'\n                + ' specified in Section 3.4 of RFC 6381.');\n        }\n        // `description` may or may not be set, depending on if the format is AVCC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-avc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('hev1') || metadata.decoderConfig.codec.startsWith('hvc1')) {\n        // HEVC-specific validation\n        if (!HEVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as'\n                + ' specified in Section E.3 of ISO 14496-15.');\n        }\n        // `description` may or may not be set, depending on if the format is HEVC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-hevc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp8')) {\n        // VP8-specific validation\n        if (metadata.decoderConfig.codec !== 'vp8') {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be \"vp8\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp09')) {\n        // VP9-specific validation\n        if (!VP9_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://www.webmproject.org/vp9/mp4/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('av01')) {\n        // AV1-specific validation\n        if (!AV1_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://aomediacodec.github.io/av1-isobmff/.');\n        }\n    }\n};\nconst VALID_AUDIO_CODEC_STRING_PREFIXES = ['mp4a', 'mp3', 'opus', 'vorbis', 'flac', 'ulaw', 'alaw', 'pcm'];\nexport const validateAudioChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Audio chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Audio chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Audio chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Audio chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_AUDIO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.sampleRate) || metadata.decoderConfig.sampleRate <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.numberOfChannels) || metadata.decoderConfig.numberOfChannels <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!isAllowSharedBufferSource(metadata.decoderConfig.description)) {\n            throw new TypeError('Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('mp4a')\n        // These three refer to MP3:\n        && metadata.decoderConfig.codec !== 'mp4a.69'\n        && metadata.decoderConfig.codec !== 'mp4a.6B'\n        && metadata.decoderConfig.codec !== 'mp4a.6b') {\n        // AAC-specific validation\n        const validStrings = ['mp4a.40.2', 'mp4a.40.02', 'mp4a.40.5', 'mp4a.40.05', 'mp4a.40.29', 'mp4a.67'];\n        if (!validStrings.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as'\n                + ' specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.');\n        }\n        if (!metadata.decoderConfig.description) {\n            throw new TypeError('Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be'\n                + ' an AudioSpecificConfig as specified in ISO 14496-3.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('mp3') || metadata.decoderConfig.codec.startsWith('mp4a')) {\n        // MP3-specific validation\n        if (metadata.decoderConfig.codec !== 'mp3'\n            && metadata.decoderConfig.codec !== 'mp4a.69'\n            && metadata.decoderConfig.codec !== 'mp4a.6B'\n            && metadata.decoderConfig.codec !== 'mp4a.6b') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be \"mp3\", \"mp4a.69\" or'\n                + ' \"mp4a.6B\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('opus')) {\n        // Opus-specific validation\n        if (metadata.decoderConfig.codec !== 'opus') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be \"opus\".');\n        }\n        if (metadata.decoderConfig.description && metadata.decoderConfig.description.byteLength < 18) {\n            // Description is optional for Opus per-spec, so we shouldn't enforce it\n            throw new TypeError('Audio chunk metadata decoder configuration description, when specified, is expected to be an'\n                + ' Identification Header as specified in Section 5.1 of RFC 7845.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vorbis')) {\n        // Vorbis-specific validation\n        if (metadata.decoderConfig.codec !== 'vorbis') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be \"vorbis\".');\n        }\n        if (!metadata.decoderConfig.description) {\n            throw new TypeError('Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('flac')) {\n        // FLAC-specific validation\n        if (metadata.decoderConfig.codec !== 'flac') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be \"flac\".');\n        }\n        const minDescriptionSize = 4 + 4 + 34; // 'fLaC' + metadata block header + STREAMINFO block\n        if (!metadata.decoderConfig.description || metadata.decoderConfig.description.byteLength < minDescriptionSize) {\n            throw new TypeError('Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('pcm')\n        || metadata.decoderConfig.codec.startsWith('ulaw')\n        || metadata.decoderConfig.codec.startsWith('alaw')) {\n        // PCM-specific validation\n        if (!PCM_AUDIO_CODECS.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM'\n                + ` codecs (${PCM_AUDIO_CODECS.join(', ')}).`);\n        }\n    }\n};\nexport const validateSubtitleMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Subtitle metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Subtitle metadata must be an object.');\n    }\n    if (!metadata.config) {\n        throw new TypeError('Subtitle metadata must include a config object.');\n    }\n    if (typeof metadata.config !== 'object') {\n        throw new TypeError('Subtitle metadata config must be an object.');\n    }\n    if (typeof metadata.config.description !== 'string') {\n        throw new TypeError('Subtitle metadata config description must be a string.');\n    }\n};\n/**\n * Checks if the browser is able to encode the given codec.\n * @public\n */\nexport const canEncode = (codec) => {\n    if (VIDEO_CODECS.includes(codec)) {\n        return canEncodeVideo(codec);\n    }\n    else if (AUDIO_CODECS.includes(codec)) {\n        return canEncodeAudio(codec);\n    }\n    else if (SUBTITLE_CODECS.includes(codec)) {\n        return canEncodeSubtitles(codec);\n    }\n    throw new TypeError(`Unknown codec '${codec}'.`);\n};\n/**\n * Checks if the browser is able to encode the given video codec with the given parameters.\n * @public\n */\nexport const canEncodeVideo = async (codec, { width = 1280, height = 720, bitrate = 1e6 } = {}) => {\n    if (!VIDEO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(width) || width <= 0) {\n        throw new TypeError('width must be a positive integer.');\n    }\n    if (!Number.isInteger(height) || height <= 0) {\n        throw new TypeError('height must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer or a quality.');\n    }\n    const resolvedBitrate = bitrate instanceof Quality\n        ? bitrate._toVideoBitrate(codec, width, height)\n        : bitrate;\n    if (customVideoEncoders.length > 0) {\n        const encoderConfig = {\n            codec: buildVideoCodecString(codec, width, height, resolvedBitrate),\n            width,\n            height,\n            bitrate: resolvedBitrate,\n            ...getVideoEncoderConfigExtension(codec),\n        };\n        if (customVideoEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (typeof VideoEncoder === 'undefined') {\n        return false;\n    }\n    const support = await VideoEncoder.isConfigSupported({\n        codec: buildVideoCodecString(codec, width, height, resolvedBitrate),\n        width,\n        height,\n        bitrate: resolvedBitrate,\n        ...getVideoEncoderConfigExtension(codec),\n    });\n    return support.supported === true;\n};\n/**\n * Checks if the browser is able to encode the given audio codec with the given parameters.\n * @public\n */\nexport const canEncodeAudio = async (codec, { numberOfChannels = 2, sampleRate = 48000, bitrate = 128e3 } = {}) => {\n    if (!AUDIO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(numberOfChannels) || numberOfChannels <= 0) {\n        throw new TypeError('numberOfChannels must be a positive integer.');\n    }\n    if (!Number.isInteger(sampleRate) || sampleRate <= 0) {\n        throw new TypeError('sampleRate must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer.');\n    }\n    const resolvedBitrate = bitrate instanceof Quality\n        ? bitrate._toAudioBitrate(codec)\n        : bitrate;\n    if (customAudioEncoders.length > 0) {\n        const encoderConfig = {\n            codec: buildAudioCodecString(codec, numberOfChannels, sampleRate),\n            numberOfChannels,\n            sampleRate,\n            bitrate: resolvedBitrate,\n            ...getAudioEncoderConfigExtension(codec),\n        };\n        if (customAudioEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (PCM_AUDIO_CODECS.includes(codec)) {\n        return true; // Because we encode these ourselves\n    }\n    if (typeof AudioEncoder === 'undefined') {\n        return false;\n    }\n    const support = await AudioEncoder.isConfigSupported({\n        codec: buildAudioCodecString(codec, numberOfChannels, sampleRate),\n        numberOfChannels,\n        sampleRate,\n        bitrate: resolvedBitrate,\n        ...getAudioEncoderConfigExtension(codec),\n    });\n    return support.supported === true;\n};\n/**\n * Checks if the browser is able to encode the given subtitle codec.\n * @public\n */\nexport const canEncodeSubtitles = async (codec) => {\n    if (!SUBTITLE_CODECS.includes(codec)) {\n        return false;\n    }\n    return true;\n};\n/**\n * Returns the list of all media codecs that can be encoded by the browser.\n * @public\n */\nexport const getEncodableCodecs = async () => {\n    const [videoCodecs, audioCodecs, subtitleCodecs] = await Promise.all([\n        getEncodableVideoCodecs(),\n        getEncodableAudioCodecs(),\n        getEncodableSubtitleCodecs(),\n    ]);\n    return [...videoCodecs, ...audioCodecs, ...subtitleCodecs];\n};\n/**\n * Returns the list of all video codecs that can be encoded by the browser.\n * @public\n */\nexport const getEncodableVideoCodecs = async (checkedCodecs = VIDEO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeVideo(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all audio codecs that can be encoded by the browser.\n * @public\n */\nexport const getEncodableAudioCodecs = async (checkedCodecs = AUDIO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeAudio(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all subtitle codecs that can be encoded by the browser.\n * @public\n */\nexport const getEncodableSubtitleCodecs = async (checkedCodecs = SUBTITLE_CODECS) => {\n    const bools = await Promise.all(checkedCodecs.map(canEncodeSubtitles));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the first video codec from the given list that can be encoded by the browser.\n * @public\n */\nexport const getFirstEncodableVideoCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeVideo(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first audio codec from the given list that can be encoded by the browser.\n * @public\n */\nexport const getFirstEncodableAudioCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeAudio(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first subtitle codec from the given list that can be encoded by the browser.\n * @public\n */\nexport const getFirstEncodableSubtitleCodec = async (checkedCodecs) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeSubtitles(codec)) {\n            return codec;\n        }\n    }\n    return null;\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2030, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/codec-data.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { VP9_LEVEL_TABLE } from './codec.js';\nimport { assert, assertNever, Bitstream, last, readExpGolomb, readSignedExpGolomb, toDataView, toUint8Array, } from './misc.js';\n// References for AVC/HEVC code:\n// ISO 14496-15\n// Rec. ITU-T H.264\n// Rec. ITU-T H.265\n// https://stackoverflow.com/questions/24884827\n/** Finds all NAL units in an AVC packet in Annex B format. */\nconst findNalUnitsInAnnexB = (packetData) => {\n    const nalUnits = [];\n    let i = 0;\n    while (i < packetData.length) {\n        let startCodePos = -1;\n        let startCodeLength = 0;\n        for (let j = i; j < packetData.length - 3; j++) {\n            // Check for 3-byte start code (0x000001)\n            if (packetData[j] === 0 && packetData[j + 1] === 0 && packetData[j + 2] === 1) {\n                startCodePos = j;\n                startCodeLength = 3;\n                break;\n            }\n            // Check for 4-byte start code (0x00000001)\n            if (j < packetData.length - 4\n                && packetData[j] === 0\n                && packetData[j + 1] === 0\n                && packetData[j + 2] === 0\n                && packetData[j + 3] === 1) {\n                startCodePos = j;\n                startCodeLength = 4;\n                break;\n            }\n        }\n        if (startCodePos === -1) {\n            break; // No more start codes found\n        }\n        // If this isn't the first start code, extract the previous NAL unit\n        if (i > 0 && startCodePos > i) {\n            const nalData = packetData.subarray(i, startCodePos);\n            if (nalData.length > 0) {\n                nalUnits.push(nalData);\n            }\n        }\n        i = startCodePos + startCodeLength;\n    }\n    // Extract the last NAL unit if there is one\n    if (i < packetData.length) {\n        const nalData = packetData.subarray(i);\n        if (nalData.length > 0) {\n            nalUnits.push(nalData);\n        }\n    }\n    return nalUnits;\n};\n/** Finds all NAL units in an AVC packet in length-prefixed format. */\nconst findNalUnitsInLengthPrefixed = (packetData, lengthSize) => {\n    const nalUnits = [];\n    let offset = 0;\n    const dataView = new DataView(packetData.buffer, packetData.byteOffset, packetData.byteLength);\n    while (offset + lengthSize <= packetData.length) {\n        let nalUnitLength;\n        if (lengthSize === 1) {\n            nalUnitLength = dataView.getUint8(offset);\n        }\n        else if (lengthSize === 2) {\n            nalUnitLength = dataView.getUint16(offset, false);\n        }\n        else if (lengthSize === 3) {\n            nalUnitLength = (dataView.getUint16(offset, false) << 8) + dataView.getUint8(offset + 2);\n        }\n        else if (lengthSize === 4) {\n            nalUnitLength = dataView.getUint32(offset, false);\n        }\n        else {\n            assertNever(lengthSize);\n            assert(false);\n        }\n        offset += lengthSize;\n        const nalUnit = packetData.subarray(offset, offset + nalUnitLength);\n        nalUnits.push(nalUnit);\n        offset += nalUnitLength;\n    }\n    return nalUnits;\n};\nconst removeEmulationPreventionBytes = (data) => {\n    const result = [];\n    const len = data.length;\n    for (let i = 0; i < len; i++) {\n        // Look for the 0x000003 pattern\n        if (i + 2 < len && data[i] === 0x00 && data[i + 1] === 0x00 && data[i + 2] === 0x03) {\n            result.push(0x00, 0x00); // Push the first two bytes\n            i += 2; // Skip the 0x03 byte\n        }\n        else {\n            result.push(data[i]);\n        }\n    }\n    return new Uint8Array(result);\n};\n/** Converts an AVC packet in Annex B format to length-prefixed format. */\nexport const transformAnnexBToLengthPrefixed = (packetData) => {\n    const NAL_UNIT_LENGTH_SIZE = 4;\n    const nalUnits = findNalUnitsInAnnexB(packetData);\n    if (nalUnits.length === 0) {\n        // If no NAL units were found, it's not valid Annex B data\n        return null;\n    }\n    let totalSize = 0;\n    for (const nalUnit of nalUnits) {\n        totalSize += NAL_UNIT_LENGTH_SIZE + nalUnit.byteLength;\n    }\n    const avccData = new Uint8Array(totalSize);\n    const dataView = new DataView(avccData.buffer);\n    let offset = 0;\n    // Write each NAL unit with its length prefix\n    for (const nalUnit of nalUnits) {\n        const length = nalUnit.byteLength;\n        dataView.setUint32(offset, length, false);\n        offset += 4;\n        avccData.set(nalUnit, offset);\n        offset += nalUnit.byteLength;\n    }\n    return avccData;\n};\nconst extractNalUnitTypeForAvc = (data) => {\n    return data[0] & 0x1F;\n};\n/** Builds an AvcDecoderConfigurationRecord from an AVC packet in Annex B format. */\nexport const extractAvcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const nalUnits = findNalUnitsInAnnexB(packetData);\n        const spsUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === 7);\n        const ppsUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === 8);\n        const spsExtUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === 13);\n        if (spsUnits.length === 0) {\n            return null;\n        }\n        if (ppsUnits.length === 0) {\n            return null;\n        }\n        // Let's get the first SPS for profile and level information\n        const spsData = spsUnits[0];\n        const bitstream = new Bitstream(removeEmulationPreventionBytes(spsData));\n        bitstream.skipBits(1); // forbidden_zero_bit\n        bitstream.skipBits(2); // nal_ref_idc\n        const nal_unit_type = bitstream.readBits(5);\n        if (nal_unit_type !== 7) { // SPS NAL unit type is 7\n            console.error('Invalid SPS NAL unit type');\n            return null;\n        }\n        const profile_idc = bitstream.readAlignedByte();\n        const constraint_flags = bitstream.readAlignedByte();\n        const level_idc = bitstream.readAlignedByte();\n        const record = {\n            configurationVersion: 1,\n            avcProfileIndication: profile_idc,\n            profileCompatibility: constraint_flags,\n            avcLevelIndication: level_idc,\n            lengthSizeMinusOne: 3, // Typically 4 bytes for length field\n            sequenceParameterSets: spsUnits,\n            pictureParameterSets: ppsUnits,\n            chromaFormat: null,\n            bitDepthLumaMinus8: null,\n            bitDepthChromaMinus8: null,\n            sequenceParameterSetExt: null,\n        };\n        if (profile_idc === 100\n            || profile_idc === 110\n            || profile_idc === 122\n            || profile_idc === 144) {\n            readExpGolomb(bitstream); // seq_parameter_set_id\n            const chroma_format_idc = readExpGolomb(bitstream);\n            if (chroma_format_idc === 3) {\n                bitstream.skipBits(1); // separate_colour_plane_flag\n            }\n            const bit_depth_luma_minus8 = readExpGolomb(bitstream);\n            const bit_depth_chroma_minus8 = readExpGolomb(bitstream);\n            record.chromaFormat = chroma_format_idc;\n            record.bitDepthLumaMinus8 = bit_depth_luma_minus8;\n            record.bitDepthChromaMinus8 = bit_depth_chroma_minus8;\n            record.sequenceParameterSetExt = spsExtUnits;\n        }\n        return record;\n    }\n    catch (error) {\n        console.error('Error building AVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\n/** Serializes an AvcDecoderConfigurationRecord into the format specified in Section 5.3.3.1 of ISO 14496-15. */\nexport const serializeAvcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    // Write header\n    bytes.push(record.configurationVersion);\n    bytes.push(record.avcProfileIndication);\n    bytes.push(record.profileCompatibility);\n    bytes.push(record.avcLevelIndication);\n    bytes.push(0xFC | (record.lengthSizeMinusOne & 0x03)); // Reserved bits (6) + lengthSizeMinusOne (2)\n    // Reserved bits (3) + numOfSequenceParameterSets (5)\n    bytes.push(0xE0 | (record.sequenceParameterSets.length & 0x1F));\n    // Write SPS\n    for (const sps of record.sequenceParameterSets) {\n        const length = sps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(sps[i]);\n        }\n    }\n    bytes.push(record.pictureParameterSets.length);\n    // Write PPS\n    for (const pps of record.pictureParameterSets) {\n        const length = pps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(pps[i]);\n        }\n    }\n    if (record.avcProfileIndication === 100\n        || record.avcProfileIndication === 110\n        || record.avcProfileIndication === 122\n        || record.avcProfileIndication === 144) {\n        assert(record.chromaFormat !== null);\n        assert(record.bitDepthLumaMinus8 !== null);\n        assert(record.bitDepthChromaMinus8 !== null);\n        assert(record.sequenceParameterSetExt !== null);\n        bytes.push(0xFC | (record.chromaFormat & 0x03)); // Reserved bits + chroma_format\n        bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07)); // Reserved bits + bit_depth_luma_minus8\n        bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07)); // Reserved bits + bit_depth_chroma_minus8\n        bytes.push(record.sequenceParameterSetExt.length);\n        // Write SPS Ext\n        for (const spsExt of record.sequenceParameterSetExt) {\n            const length = spsExt.byteLength;\n            bytes.push(length >> 8); // High byte\n            bytes.push(length & 0xFF); // Low byte\n            for (let i = 0; i < length; i++) {\n                bytes.push(spsExt[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\nconst NALU_TYPE_VPS = 32;\nconst NALU_TYPE_SPS = 33;\nconst NALU_TYPE_PPS = 34;\nconst NALU_TYPE_SEI_PREFIX = 39;\nconst NALU_TYPE_SEI_SUFFIX = 40;\nconst extractNalUnitTypeForHevc = (data) => {\n    return (data[0] >> 1) & 0x3F;\n};\n/** Builds a HevcDecoderConfigurationRecord from an HEVC packet in Annex B format. */\nexport const extractHevcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const nalUnits = findNalUnitsInAnnexB(packetData);\n        const vpsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === NALU_TYPE_VPS);\n        const spsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === NALU_TYPE_SPS);\n        const ppsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === NALU_TYPE_PPS);\n        const seiUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === NALU_TYPE_SEI_PREFIX\n            || extractNalUnitTypeForHevc(unit) === NALU_TYPE_SEI_SUFFIX);\n        if (spsUnits.length === 0 || ppsUnits.length === 0)\n            return null;\n        const sps = spsUnits[0];\n        const bitstream = new Bitstream(removeEmulationPreventionBytes(sps));\n        bitstream.skipBits(16); // NAL header\n        bitstream.readBits(4); // sps_video_parameter_set_id\n        const sps_max_sub_layers_minus1 = bitstream.readBits(3);\n        const sps_temporal_id_nesting_flag = bitstream.readBits(1);\n        const { general_profile_space, general_tier_flag, general_profile_idc, general_profile_compatibility_flags, general_constraint_indicator_flags, general_level_idc, } = parseProfileTierLevel(bitstream, sps_max_sub_layers_minus1);\n        readExpGolomb(bitstream); // sps_seq_parameter_set_id\n        const chroma_format_idc = readExpGolomb(bitstream);\n        if (chroma_format_idc === 3)\n            bitstream.skipBits(1); // separate_colour_plane_flag\n        readExpGolomb(bitstream); // pic_width_in_luma_samples\n        readExpGolomb(bitstream); // pic_height_in_luma_samples\n        if (bitstream.readBits(1)) { // conformance_window_flag\n            readExpGolomb(bitstream); // conf_win_left_offset\n            readExpGolomb(bitstream); // conf_win_right_offset\n            readExpGolomb(bitstream); // conf_win_top_offset\n            readExpGolomb(bitstream); // conf_win_bottom_offset\n        }\n        const bit_depth_luma_minus8 = readExpGolomb(bitstream);\n        const bit_depth_chroma_minus8 = readExpGolomb(bitstream);\n        readExpGolomb(bitstream); // log2_max_pic_order_cnt_lsb_minus4\n        const sps_sub_layer_ordering_info_present_flag = bitstream.readBits(1);\n        const maxNum = sps_sub_layer_ordering_info_present_flag ? 0 : sps_max_sub_layers_minus1;\n        for (let i = maxNum; i <= sps_max_sub_layers_minus1; i++) {\n            readExpGolomb(bitstream); // sps_max_dec_pic_buffering_minus1[i]\n            readExpGolomb(bitstream); // sps_max_num_reorder_pics[i]\n            readExpGolomb(bitstream); // sps_max_latency_increase_plus1[i]\n        }\n        readExpGolomb(bitstream); // log2_min_luma_coding_block_size_minus3\n        readExpGolomb(bitstream); // log2_diff_max_min_luma_coding_block_size\n        readExpGolomb(bitstream); // log2_min_luma_transform_block_size_minus2\n        readExpGolomb(bitstream); // log2_diff_max_min_luma_transform_block_size\n        readExpGolomb(bitstream); // max_transform_hierarchy_depth_inter\n        readExpGolomb(bitstream); // max_transform_hierarchy_depth_intra\n        if (bitstream.readBits(1)) { // scaling_list_enabled_flag\n            if (bitstream.readBits(1)) {\n                skipScalingListData(bitstream);\n            }\n        }\n        bitstream.skipBits(1); // amp_enabled_flag\n        bitstream.skipBits(1); // sample_adaptive_offset_enabled_flag\n        if (bitstream.readBits(1)) { // pcm_enabled_flag\n            bitstream.skipBits(4); // pcm_sample_bit_depth_luma_minus1\n            bitstream.skipBits(4); // pcm_sample_bit_depth_chroma_minus1\n            readExpGolomb(bitstream); // log2_min_pcm_luma_coding_block_size_minus3\n            readExpGolomb(bitstream); // log2_diff_max_min_pcm_luma_coding_block_size\n            bitstream.skipBits(1); // pcm_loop_filter_disabled_flag\n        }\n        const num_short_term_ref_pic_sets = readExpGolomb(bitstream);\n        skipAllStRefPicSets(bitstream, num_short_term_ref_pic_sets);\n        if (bitstream.readBits(1)) { // long_term_ref_pics_present_flag\n            const num_long_term_ref_pics_sps = readExpGolomb(bitstream);\n            for (let i = 0; i < num_long_term_ref_pics_sps; i++) {\n                readExpGolomb(bitstream); // lt_ref_pic_poc_lsb_sps[i]\n                bitstream.skipBits(1); // used_by_curr_pic_lt_sps_flag[i]\n            }\n        }\n        bitstream.skipBits(1); // sps_temporal_mvp_enabled_flag\n        bitstream.skipBits(1); // strong_intra_smoothing_enabled_flag\n        let min_spatial_segmentation_idc = 0;\n        if (bitstream.readBits(1)) { // vui_parameters_present_flag\n            min_spatial_segmentation_idc = parseVuiForMinSpatialSegmentationIdc(bitstream, sps_max_sub_layers_minus1);\n        }\n        // Parse PPS for parallelismType\n        let parallelismType = 0;\n        if (ppsUnits.length > 0) {\n            const pps = ppsUnits[0];\n            const ppsBitstream = new Bitstream(removeEmulationPreventionBytes(pps));\n            ppsBitstream.skipBits(16); // NAL header\n            readExpGolomb(ppsBitstream); // pps_pic_parameter_set_id\n            readExpGolomb(ppsBitstream); // pps_seq_parameter_set_id\n            ppsBitstream.skipBits(1); // dependent_slice_segments_enabled_flag\n            ppsBitstream.skipBits(1); // output_flag_present_flag\n            ppsBitstream.skipBits(3); // num_extra_slice_header_bits\n            ppsBitstream.skipBits(1); // sign_data_hiding_enabled_flag\n            ppsBitstream.skipBits(1); // cabac_init_present_flag\n            readExpGolomb(ppsBitstream); // num_ref_idx_l0_default_active_minus1\n            readExpGolomb(ppsBitstream); // num_ref_idx_l1_default_active_minus1\n            readSignedExpGolomb(ppsBitstream); // init_qp_minus26\n            ppsBitstream.skipBits(1); // constrained_intra_pred_flag\n            ppsBitstream.skipBits(1); // transform_skip_enabled_flag\n            if (ppsBitstream.readBits(1)) { // cu_qp_delta_enabled_flag\n                readExpGolomb(ppsBitstream); // diff_cu_qp_delta_depth\n            }\n            readSignedExpGolomb(ppsBitstream); // pps_cb_qp_offset\n            readSignedExpGolomb(ppsBitstream); // pps_cr_qp_offset\n            ppsBitstream.skipBits(1); // pps_slice_chroma_qp_offsets_present_flag\n            ppsBitstream.skipBits(1); // weighted_pred_flag\n            ppsBitstream.skipBits(1); // weighted_bipred_flag\n            ppsBitstream.skipBits(1); // transquant_bypass_enabled_flag\n            const tiles_enabled_flag = ppsBitstream.readBits(1);\n            const entropy_coding_sync_enabled_flag = ppsBitstream.readBits(1);\n            if (!tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 0;\n            else if (tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 2;\n            else if (!tiles_enabled_flag && entropy_coding_sync_enabled_flag)\n                parallelismType = 3;\n            else\n                parallelismType = 0;\n        }\n        const arrays = [\n            ...(vpsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: NALU_TYPE_VPS,\n                        nalUnits: vpsUnits,\n                    },\n                ]\n                : []),\n            ...(spsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: NALU_TYPE_SPS,\n                        nalUnits: spsUnits,\n                    },\n                ]\n                : []),\n            ...(ppsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: NALU_TYPE_PPS,\n                        nalUnits: ppsUnits,\n                    },\n                ]\n                : []),\n            ...(seiUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: extractNalUnitTypeForHevc(seiUnits[0]),\n                        nalUnits: seiUnits,\n                    },\n                ]\n                : []),\n        ];\n        const record = {\n            configurationVersion: 1,\n            generalProfileSpace: general_profile_space,\n            generalTierFlag: general_tier_flag,\n            generalProfileIdc: general_profile_idc,\n            generalProfileCompatibilityFlags: general_profile_compatibility_flags,\n            generalConstraintIndicatorFlags: general_constraint_indicator_flags,\n            generalLevelIdc: general_level_idc,\n            minSpatialSegmentationIdc: min_spatial_segmentation_idc,\n            parallelismType,\n            chromaFormatIdc: chroma_format_idc,\n            bitDepthLumaMinus8: bit_depth_luma_minus8,\n            bitDepthChromaMinus8: bit_depth_chroma_minus8,\n            avgFrameRate: 0,\n            constantFrameRate: 0,\n            numTemporalLayers: sps_max_sub_layers_minus1 + 1,\n            temporalIdNested: sps_temporal_id_nesting_flag,\n            lengthSizeMinusOne: 3,\n            arrays,\n        };\n        return record;\n    }\n    catch (error) {\n        console.error('Error building HEVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\nconst parseProfileTierLevel = (bitstream, maxNumSubLayersMinus1) => {\n    const general_profile_space = bitstream.readBits(2);\n    const general_tier_flag = bitstream.readBits(1);\n    const general_profile_idc = bitstream.readBits(5);\n    let general_profile_compatibility_flags = 0;\n    for (let i = 0; i < 32; i++) {\n        general_profile_compatibility_flags = (general_profile_compatibility_flags << 1) | bitstream.readBits(1);\n    }\n    const general_constraint_indicator_flags = new Uint8Array(6);\n    for (let i = 0; i < 6; i++) {\n        general_constraint_indicator_flags[i] = bitstream.readBits(8);\n    }\n    const general_level_idc = bitstream.readBits(8);\n    const sub_layer_profile_present_flag = [];\n    const sub_layer_level_present_flag = [];\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        sub_layer_profile_present_flag.push(bitstream.readBits(1));\n        sub_layer_level_present_flag.push(bitstream.readBits(1));\n    }\n    if (maxNumSubLayersMinus1 > 0) {\n        for (let i = maxNumSubLayersMinus1; i < 8; i++) {\n            bitstream.skipBits(2); // reserved_zero_2bits\n        }\n    }\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        if (sub_layer_profile_present_flag[i])\n            bitstream.skipBits(88);\n        if (sub_layer_level_present_flag[i])\n            bitstream.skipBits(8);\n    }\n    return {\n        general_profile_space,\n        general_tier_flag,\n        general_profile_idc,\n        general_profile_compatibility_flags,\n        general_constraint_indicator_flags,\n        general_level_idc,\n    };\n};\nconst skipScalingListData = (bitstream) => {\n    for (let sizeId = 0; sizeId < 4; sizeId++) {\n        for (let matrixId = 0; matrixId < (sizeId === 3 ? 2 : 6); matrixId++) {\n            const scaling_list_pred_mode_flag = bitstream.readBits(1);\n            if (!scaling_list_pred_mode_flag) {\n                readExpGolomb(bitstream); // scaling_list_pred_matrix_id_delta\n            }\n            else {\n                const coefNum = Math.min(64, 1 << (4 + (sizeId << 1)));\n                if (sizeId > 1) {\n                    readSignedExpGolomb(bitstream); // scaling_list_dc_coef_minus8\n                }\n                for (let i = 0; i < coefNum; i++) {\n                    readSignedExpGolomb(bitstream); // scaling_list_delta_coef\n                }\n            }\n        }\n    }\n};\nconst skipAllStRefPicSets = (bitstream, num_short_term_ref_pic_sets) => {\n    const NumDeltaPocs = [];\n    for (let stRpsIdx = 0; stRpsIdx < num_short_term_ref_pic_sets; stRpsIdx++) {\n        NumDeltaPocs[stRpsIdx] = skipStRefPicSet(bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs);\n    }\n};\nconst skipStRefPicSet = (bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs) => {\n    let NumDeltaPocsThis = 0;\n    let inter_ref_pic_set_prediction_flag = 0;\n    let RefRpsIdx = 0;\n    if (stRpsIdx !== 0) {\n        inter_ref_pic_set_prediction_flag = bitstream.readBits(1);\n    }\n    if (inter_ref_pic_set_prediction_flag) {\n        if (stRpsIdx === num_short_term_ref_pic_sets) {\n            const delta_idx_minus1 = readExpGolomb(bitstream);\n            RefRpsIdx = stRpsIdx - (delta_idx_minus1 + 1);\n        }\n        else {\n            RefRpsIdx = stRpsIdx - 1;\n        }\n        bitstream.readBits(1); // delta_rps_sign\n        readExpGolomb(bitstream); // abs_delta_rps_minus1\n        // The number of iterations is NumDeltaPocs[RefRpsIdx] + 1\n        const numDelta = NumDeltaPocs[RefRpsIdx] ?? 0;\n        for (let j = 0; j <= numDelta; j++) {\n            const used_by_curr_pic_flag = bitstream.readBits(1);\n            if (!used_by_curr_pic_flag) {\n                bitstream.readBits(1); // use_delta_flag\n            }\n        }\n        NumDeltaPocsThis = NumDeltaPocs[RefRpsIdx];\n    }\n    else {\n        const num_negative_pics = readExpGolomb(bitstream);\n        const num_positive_pics = readExpGolomb(bitstream);\n        for (let i = 0; i < num_negative_pics; i++) {\n            readExpGolomb(bitstream); // delta_poc_s0_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s0_flag[i]\n        }\n        for (let i = 0; i < num_positive_pics; i++) {\n            readExpGolomb(bitstream); // delta_poc_s1_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s1_flag[i]\n        }\n        NumDeltaPocsThis = num_negative_pics + num_positive_pics;\n    }\n    return NumDeltaPocsThis;\n};\nconst parseVuiForMinSpatialSegmentationIdc = (bitstream, sps_max_sub_layers_minus1) => {\n    if (bitstream.readBits(1)) { // aspect_ratio_info_present_flag\n        const aspect_ratio_idc = bitstream.readBits(8);\n        if (aspect_ratio_idc === 255) {\n            bitstream.readBits(16); // sar_width\n            bitstream.readBits(16); // sar_height\n        }\n    }\n    if (bitstream.readBits(1)) { // overscan_info_present_flag\n        bitstream.readBits(1); // overscan_appropriate_flag\n    }\n    if (bitstream.readBits(1)) { // video_signal_type_present_flag\n        bitstream.readBits(3); // video_format\n        bitstream.readBits(1); // video_full_range_flag\n        if (bitstream.readBits(1)) {\n            bitstream.readBits(8); // colour_primaries\n            bitstream.readBits(8); // transfer_characteristics\n            bitstream.readBits(8); // matrix_coeffs\n        }\n    }\n    if (bitstream.readBits(1)) { // chroma_loc_info_present_flag\n        readExpGolomb(bitstream); // chroma_sample_loc_type_top_field\n        readExpGolomb(bitstream); // chroma_sample_loc_type_bottom_field\n    }\n    bitstream.readBits(1); // neutral_chroma_indication_flag\n    bitstream.readBits(1); // field_seq_flag\n    bitstream.readBits(1); // frame_field_info_present_flag\n    if (bitstream.readBits(1)) { // default_display_window_flag\n        readExpGolomb(bitstream); // def_disp_win_left_offset\n        readExpGolomb(bitstream); // def_disp_win_right_offset\n        readExpGolomb(bitstream); // def_disp_win_top_offset\n        readExpGolomb(bitstream); // def_disp_win_bottom_offset\n    }\n    if (bitstream.readBits(1)) { // vui_timing_info_present_flag\n        bitstream.readBits(32); // vui_num_units_in_tick\n        bitstream.readBits(32); // vui_time_scale\n        if (bitstream.readBits(1)) { // vui_poc_proportional_to_timing_flag\n            readExpGolomb(bitstream); // vui_num_ticks_poc_diff_one_minus1\n        }\n        if (bitstream.readBits(1)) {\n            skipHrdParameters(bitstream, true, sps_max_sub_layers_minus1);\n        }\n    }\n    if (bitstream.readBits(1)) { // bitstream_restriction_flag\n        bitstream.readBits(1); // tiles_fixed_structure_flag\n        bitstream.readBits(1); // motion_vectors_over_pic_boundaries_flag\n        bitstream.readBits(1); // restricted_ref_pic_lists_flag\n        const min_spatial_segmentation_idc = readExpGolomb(bitstream);\n        // skip the rest\n        readExpGolomb(bitstream); // max_bytes_per_pic_denom\n        readExpGolomb(bitstream); // max_bits_per_min_cu_denom\n        readExpGolomb(bitstream); // log2_max_mv_length_horizontal\n        readExpGolomb(bitstream); // log2_max_mv_length_vertical\n        return min_spatial_segmentation_idc;\n    }\n    return 0;\n};\nconst skipHrdParameters = (bitstream, commonInfPresentFlag, maxNumSubLayersMinus1) => {\n    let nal_hrd_parameters_present_flag = false;\n    let vcl_hrd_parameters_present_flag = false;\n    let sub_pic_hrd_params_present_flag = false;\n    if (commonInfPresentFlag) {\n        nal_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        vcl_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n            sub_pic_hrd_params_present_flag = bitstream.readBits(1) === 1;\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(8); // tick_divisor_minus2\n                bitstream.readBits(5); // du_cpb_removal_delay_increment_length_minus1\n                bitstream.readBits(1); // sub_pic_cpb_params_in_pic_timing_sei_flag\n                bitstream.readBits(5); // dpb_output_delay_du_length_minus1\n            }\n            bitstream.readBits(4); // bit_rate_scale\n            bitstream.readBits(4); // cpb_size_scale\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(4); // cpb_size_du_scale\n            }\n            bitstream.readBits(5); // initial_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // au_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // dpb_output_delay_length_minus1\n        }\n    }\n    for (let i = 0; i <= maxNumSubLayersMinus1; i++) {\n        const fixed_pic_rate_general_flag = bitstream.readBits(1) === 1;\n        let fixed_pic_rate_within_cvs_flag = true; // Default assumption if general is true\n        if (!fixed_pic_rate_general_flag) {\n            fixed_pic_rate_within_cvs_flag = bitstream.readBits(1) === 1;\n        }\n        let low_delay_hrd_flag = false; // Default assumption\n        if (fixed_pic_rate_within_cvs_flag) {\n            readExpGolomb(bitstream); // elemental_duration_in_tc_minus1[i]\n        }\n        else {\n            low_delay_hrd_flag = bitstream.readBits(1) === 1;\n        }\n        let CpbCnt = 1; // Default if low_delay is true\n        if (!low_delay_hrd_flag) {\n            const cpb_cnt_minus1 = readExpGolomb(bitstream); // cpb_cnt_minus1[i]\n            CpbCnt = cpb_cnt_minus1 + 1;\n        }\n        if (nal_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n        if (vcl_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n    }\n};\nconst skipSubLayerHrdParameters = (bitstream, CpbCnt, sub_pic_hrd_params_present_flag) => {\n    for (let i = 0; i < CpbCnt; i++) {\n        readExpGolomb(bitstream); // bit_rate_value_minus1[i]\n        readExpGolomb(bitstream); // cpb_size_value_minus1[i]\n        if (sub_pic_hrd_params_present_flag) {\n            readExpGolomb(bitstream); // cpb_size_du_value_minus1[i]\n            readExpGolomb(bitstream); // bit_rate_du_value_minus1[i]\n        }\n        bitstream.readBits(1); // cbr_flag[i]\n    }\n};\n/** Serializes an HevcDecoderConfigurationRecord into the format specified in Section 8.3.3.1 of ISO 14496-15. */\nexport const serializeHevcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    bytes.push(record.configurationVersion);\n    bytes.push(((record.generalProfileSpace & 0x3) << 6)\n        | ((record.generalTierFlag & 0x1) << 5)\n        | (record.generalProfileIdc & 0x1F));\n    bytes.push((record.generalProfileCompatibilityFlags >>> 24) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 16) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 8) & 0xFF);\n    bytes.push(record.generalProfileCompatibilityFlags & 0xFF);\n    bytes.push(...record.generalConstraintIndicatorFlags);\n    bytes.push(record.generalLevelIdc & 0xFF);\n    bytes.push(0xF0 | ((record.minSpatialSegmentationIdc >> 8) & 0x0F)); // Reserved + high nibble\n    bytes.push(record.minSpatialSegmentationIdc & 0xFF); // Low byte\n    bytes.push(0xFC | (record.parallelismType & 0x03));\n    bytes.push(0xFC | (record.chromaFormatIdc & 0x03));\n    bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07));\n    bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07));\n    bytes.push((record.avgFrameRate >> 8) & 0xFF); // High byte\n    bytes.push(record.avgFrameRate & 0xFF); // Low byte\n    bytes.push(((record.constantFrameRate & 0x03) << 6)\n        | ((record.numTemporalLayers & 0x07) << 3)\n        | ((record.temporalIdNested & 0x01) << 2)\n        | (record.lengthSizeMinusOne & 0x03));\n    bytes.push(record.arrays.length & 0xFF);\n    for (const arr of record.arrays) {\n        bytes.push(((arr.arrayCompleteness & 0x01) << 7)\n            | (0 << 6)\n            | (arr.nalUnitType & 0x3F));\n        bytes.push((arr.nalUnits.length >> 8) & 0xFF); // High byte\n        bytes.push(arr.nalUnits.length & 0xFF); // Low byte\n        for (const nal of arr.nalUnits) {\n            bytes.push((nal.length >> 8) & 0xFF); // High byte\n            bytes.push(nal.length & 0xFF); // Low byte\n            for (let i = 0; i < nal.length; i++) {\n                bytes.push(nal[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\nexport const extractVp9CodecInfoFromPacket = (packet) => {\n    // eslint-disable-next-line @stylistic/max-len\n    // https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.7-20170222-draft.pdf\n    // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf\n    const bitstream = new Bitstream(packet);\n    // Frame marker (0b10)\n    const frameMarker = bitstream.readBits(2);\n    if (frameMarker !== 2) {\n        return null;\n    }\n    // Profile\n    const profileLowBit = bitstream.readBits(1);\n    const profileHighBit = bitstream.readBits(1);\n    const profile = (profileHighBit << 1) + profileLowBit;\n    // Skip reserved bit for profile 3\n    if (profile === 3) {\n        bitstream.skipBits(1);\n    }\n    // show_existing_frame\n    const showExistingFrame = bitstream.readBits(1);\n    if (showExistingFrame === 1) {\n        return null;\n    }\n    // frame_type (0 = key frame)\n    const frameType = bitstream.readBits(1);\n    if (frameType !== 0) {\n        return null;\n    }\n    // Skip show_frame and error_resilient_mode\n    bitstream.skipBits(2);\n    // Sync code (0x498342)\n    const syncCode = bitstream.readBits(24);\n    if (syncCode !== 0x498342) {\n        return null;\n    }\n    // Color config\n    let bitDepth = 8;\n    if (profile >= 2) {\n        const tenOrTwelveBit = bitstream.readBits(1);\n        bitDepth = tenOrTwelveBit ? 12 : 10;\n    }\n    // Color space\n    const colorSpace = bitstream.readBits(3);\n    let chromaSubsampling = 0;\n    let videoFullRangeFlag = 0;\n    if (colorSpace !== 7) { // 7 is CS_RGB\n        const colorRange = bitstream.readBits(1);\n        videoFullRangeFlag = colorRange;\n        if (profile === 1 || profile === 3) {\n            const subsamplingX = bitstream.readBits(1);\n            const subsamplingY = bitstream.readBits(1);\n            // 0 = 4:2:0 vertical\n            // 1 = 4:2:0 colocated\n            // 2 = 4:2:2\n            // 3 = 4:4:4\n            chromaSubsampling = !subsamplingX && !subsamplingY\n                ? 3 // 0,0 = 4:4:4\n                : subsamplingX && !subsamplingY\n                    ? 2 // 1,0 = 4:2:2\n                    : 1; // 1,1 = 4:2:0 colocated (default)\n            // Skip reserved bit\n            bitstream.skipBits(1);\n        }\n        else {\n            // For profile 0 and 2, always 4:2:0\n            chromaSubsampling = 1; // Using colocated as default\n        }\n    }\n    else {\n        // RGB is always 4:4:4\n        chromaSubsampling = 3;\n        videoFullRangeFlag = 1;\n    }\n    // Parse frame size\n    const widthMinusOne = bitstream.readBits(16);\n    const heightMinusOne = bitstream.readBits(16);\n    const width = widthMinusOne + 1;\n    const height = heightMinusOne + 1;\n    // Calculate level based on dimensions\n    const pictureSize = width * height;\n    let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n    for (const entry of VP9_LEVEL_TABLE) {\n        if (pictureSize <= entry.maxPictureSize) {\n            level = entry.level;\n            break;\n        }\n    }\n    // Map color_space to standard values\n    const matrixCoefficients = colorSpace === 7\n        ? 0\n        : colorSpace === 2\n            ? 1\n            : colorSpace === 1\n                ? 6\n                : 2;\n    const colourPrimaries = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    const transferCharacteristics = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    return {\n        profile,\n        level,\n        bitDepth,\n        chromaSubsampling,\n        videoFullRangeFlag,\n        colourPrimaries,\n        transferCharacteristics,\n        matrixCoefficients,\n    };\n};\n/** Iterates over all OBUs in an AV1 packet bistream. */\nexport function* iterateAv1PacketObus(packet) {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    const bitstream = new Bitstream(packet);\n    const readLeb128 = () => {\n        let value = 0;\n        for (let i = 0; i < 8; i++) {\n            const byte = bitstream.readAlignedByte();\n            value |= ((byte & 0x7f) << (i * 7));\n            if (!(byte & 0x80)) {\n                break;\n            }\n            // Spec requirement\n            if (i === 7 && (byte & 0x80)) {\n                return null;\n            }\n        }\n        // Spec requirement\n        if (value >= 2 ** 32 - 1) {\n            return null;\n        }\n        return value;\n    };\n    while (bitstream.getBitsLeft() >= 8) {\n        // Parse OBU header\n        bitstream.skipBits(1);\n        const obuType = bitstream.readBits(4);\n        const obuExtension = bitstream.readBits(1);\n        const obuHasSizeField = bitstream.readBits(1);\n        bitstream.skipBits(1);\n        // Skip extension header if present\n        if (obuExtension) {\n            bitstream.skipBits(8);\n        }\n        // Read OBU size if present\n        let obuSize;\n        if (obuHasSizeField) {\n            const obuSizeValue = readLeb128();\n            if (obuSizeValue === null)\n                return; // It was invalid\n            obuSize = obuSizeValue;\n        }\n        else {\n            // Calculate remaining bits and convert to bytes, rounding down\n            obuSize = Math.floor(bitstream.getBitsLeft() / 8);\n        }\n        assert(bitstream.pos % 8 === 0);\n        yield {\n            type: obuType,\n            data: packet.subarray(bitstream.pos / 8, bitstream.pos / 8 + obuSize),\n        };\n        // Move to next OBU\n        bitstream.skipBits(obuSize * 8);\n    }\n}\n;\n/**\n * When AV1 codec information is not provided by the container, we can still try to extract the information by digging\n * into the AV1 bitstream.\n */\nexport const extractAv1CodecInfoFromPacket = (packet) => {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    for (const { type, data } of iterateAv1PacketObus(packet)) {\n        if (type !== 1) {\n            continue; // 1 == OBU_SEQUENCE_HEADER\n        }\n        const bitstream = new Bitstream(data);\n        // Read sequence header fields\n        const seqProfile = bitstream.readBits(3);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const stillPicture = bitstream.readBits(1);\n        const reducedStillPictureHeader = bitstream.readBits(1);\n        let seqLevel = 0;\n        let seqTier = 0;\n        let bufferDelayLengthMinus1 = 0;\n        if (reducedStillPictureHeader) {\n            seqLevel = bitstream.readBits(5);\n        }\n        else {\n            // Parse timing_info_present_flag\n            const timingInfoPresentFlag = bitstream.readBits(1);\n            if (timingInfoPresentFlag) {\n                // Skip timing info (num_units_in_display_tick, time_scale, equal_picture_interval)\n                bitstream.skipBits(32); // num_units_in_display_tick\n                bitstream.skipBits(32); // time_scale\n                const equalPictureInterval = bitstream.readBits(1);\n                if (equalPictureInterval) {\n                    // Skip num_ticks_per_picture_minus_1 (uvlc)\n                    // Since this is variable length, we'd need to implement uvlc reading\n                    // For now, we'll return null as this is rare\n                    return null;\n                }\n            }\n            // Parse decoder_model_info_present_flag\n            const decoderModelInfoPresentFlag = bitstream.readBits(1);\n            if (decoderModelInfoPresentFlag) {\n                // Store buffer_delay_length_minus_1 instead of just skipping\n                bufferDelayLengthMinus1 = bitstream.readBits(5);\n                bitstream.skipBits(32); // num_units_in_decoding_tick\n                bitstream.skipBits(5); // buffer_removal_time_length_minus_1\n                bitstream.skipBits(5); // frame_presentation_time_length_minus_1\n            }\n            // Parse operating_points_cnt_minus_1\n            const operatingPointsCntMinus1 = bitstream.readBits(5);\n            // For each operating point\n            for (let i = 0; i <= operatingPointsCntMinus1; i++) {\n                // operating_point_idc[i]\n                bitstream.skipBits(12);\n                // seq_level_idx[i]\n                const seqLevelIdx = bitstream.readBits(5);\n                if (i === 0) {\n                    seqLevel = seqLevelIdx;\n                }\n                if (seqLevelIdx > 7) {\n                    // seq_tier[i]\n                    const seqTierTemp = bitstream.readBits(1);\n                    if (i === 0) {\n                        seqTier = seqTierTemp;\n                    }\n                }\n                if (decoderModelInfoPresentFlag) {\n                    // decoder_model_present_for_this_op[i]\n                    const decoderModelPresentForThisOp = bitstream.readBits(1);\n                    if (decoderModelPresentForThisOp) {\n                        const n = bufferDelayLengthMinus1 + 1;\n                        bitstream.skipBits(n); // decoder_buffer_delay[op]\n                        bitstream.skipBits(n); // encoder_buffer_delay[op]\n                        bitstream.skipBits(1); // low_delay_mode_flag[op]\n                    }\n                }\n                // initial_display_delay_present_flag\n                const initialDisplayDelayPresentFlag = bitstream.readBits(1);\n                if (initialDisplayDelayPresentFlag) {\n                    // initial_display_delay_minus_1[i]\n                    bitstream.skipBits(4);\n                }\n            }\n        }\n        const highBitdepth = bitstream.readBits(1);\n        let bitDepth = 8;\n        if (seqProfile === 2 && highBitdepth) {\n            const twelveBit = bitstream.readBits(1);\n            bitDepth = twelveBit ? 12 : 10;\n        }\n        else if (seqProfile <= 2) {\n            bitDepth = highBitdepth ? 10 : 8;\n        }\n        let monochrome = 0;\n        if (seqProfile !== 1) {\n            monochrome = bitstream.readBits(1);\n        }\n        let chromaSubsamplingX = 1;\n        let chromaSubsamplingY = 1;\n        let chromaSamplePosition = 0;\n        if (!monochrome) {\n            if (seqProfile === 0) {\n                chromaSubsamplingX = 1;\n                chromaSubsamplingY = 1;\n            }\n            else if (seqProfile === 1) {\n                chromaSubsamplingX = 0;\n                chromaSubsamplingY = 0;\n            }\n            else {\n                if (bitDepth === 12) {\n                    chromaSubsamplingX = bitstream.readBits(1);\n                    if (chromaSubsamplingX) {\n                        chromaSubsamplingY = bitstream.readBits(1);\n                    }\n                }\n            }\n            if (chromaSubsamplingX && chromaSubsamplingY) {\n                chromaSamplePosition = bitstream.readBits(2);\n            }\n        }\n        return {\n            profile: seqProfile,\n            level: seqLevel,\n            tier: seqTier,\n            bitDepth,\n            monochrome,\n            chromaSubsamplingX,\n            chromaSubsamplingY,\n            chromaSamplePosition,\n        };\n    }\n    return null;\n};\nexport const parseOpusIdentificationHeader = (bytes) => {\n    const view = toDataView(bytes);\n    const outputChannelCount = view.getUint8(9);\n    const preSkip = view.getUint16(10, true);\n    const inputSampleRate = view.getUint32(12, true);\n    const outputGain = view.getInt16(16, true);\n    const channelMappingFamily = view.getUint8(18);\n    let channelMappingTable = null;\n    if (channelMappingFamily) {\n        channelMappingTable = bytes.subarray(19, 19 + 2 + outputChannelCount);\n    }\n    return {\n        outputChannelCount,\n        preSkip,\n        inputSampleRate,\n        outputGain,\n        channelMappingFamily,\n        channelMappingTable,\n    };\n};\n// From https://datatracker.ietf.org/doc/html/rfc6716, in 48 kHz samples\nconst OPUS_FRAME_DURATION_TABLE = [\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960,\n    480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n];\nexport const parseOpusTocByte = (packet) => {\n    const config = packet[0] >> 3;\n    return {\n        durationInSamples: OPUS_FRAME_DURATION_TABLE[config],\n    };\n};\n// Based on vorbis_parser.c from FFmpeg.\nexport const parseModesFromVorbisSetupPacket = (setupHeader) => {\n    // Verify that this is a Setup header.\n    if (setupHeader.length < 7) {\n        throw new Error('Setup header is too short.');\n    }\n    if (setupHeader[0] !== 5) {\n        throw new Error('Wrong packet type in Setup header.');\n    }\n    const signature = String.fromCharCode(...setupHeader.slice(1, 7));\n    if (signature !== 'vorbis') {\n        throw new Error('Invalid packet signature in Setup header.');\n    }\n    // Reverse the entire buffer.\n    const bufSize = setupHeader.length;\n    const revBuffer = new Uint8Array(bufSize);\n    for (let i = 0; i < bufSize; i++) {\n        revBuffer[i] = setupHeader[bufSize - 1 - i];\n    }\n    // Initialize a Bitstream on the reversed buffer.\n    const bitstream = new Bitstream(revBuffer);\n    // --- Find the framing bit.\n    // In FFmpeg code, we scan until get_bits1() returns 1.\n    let gotFramingBit = 0;\n    while (bitstream.getBitsLeft() > 97) {\n        if (bitstream.readBits(1) === 1) {\n            gotFramingBit = bitstream.pos;\n            break;\n        }\n    }\n    if (gotFramingBit === 0) {\n        throw new Error('Invalid Setup header: framing bit not found.');\n    }\n    // --- Search backwards for a valid mode header.\n    // We try to “guess” the number of modes by reading a fixed pattern.\n    let modeCount = 0;\n    let gotModeHeader = false;\n    let lastModeCount = 0;\n    while (bitstream.getBitsLeft() >= 97) {\n        const tempPos = bitstream.pos;\n        const a = bitstream.readBits(8);\n        const b = bitstream.readBits(16);\n        const c = bitstream.readBits(16);\n        // If a > 63 or b or c nonzero, assume we’ve gone too far.\n        if (a > 63 || b !== 0 || c !== 0) {\n            bitstream.pos = tempPos;\n            break;\n        }\n        bitstream.skipBits(1);\n        modeCount++;\n        if (modeCount > 64) {\n            break;\n        }\n        const bsClone = bitstream.clone();\n        const candidate = bsClone.readBits(6) + 1;\n        if (candidate === modeCount) {\n            gotModeHeader = true;\n            lastModeCount = modeCount;\n        }\n    }\n    if (!gotModeHeader) {\n        throw new Error('Invalid Setup header: mode header not found.');\n    }\n    if (lastModeCount > 63) {\n        throw new Error(`Unsupported mode count: ${lastModeCount}.`);\n    }\n    const finalModeCount = lastModeCount;\n    // --- Reinitialize the bitstream.\n    bitstream.pos = 0;\n    // Skip the bits up to the found framing bit.\n    bitstream.skipBits(gotFramingBit);\n    // --- Now read, for each mode (in reverse order), 40 bits then one bit.\n    // That one bit is the mode blockflag.\n    const modeBlockflags = Array(finalModeCount).fill(0);\n    for (let i = finalModeCount - 1; i >= 0; i--) {\n        bitstream.skipBits(40);\n        modeBlockflags[i] = bitstream.readBits(1);\n    }\n    return { modeBlockflags };\n};\n/** Determines a packet's type (key or delta) by digging into the packet bitstream. */\nexport const determineVideoPacketType = async (videoTrack, packet) => {\n    assert(videoTrack.codec);\n    switch (videoTrack.codec) {\n        case 'avc':\n            {\n                const decoderConfig = await videoTrack.getDecoderConfig();\n                assert(decoderConfig);\n                let nalUnits;\n                if (decoderConfig.description) {\n                    // Stream is length-prefixed. Let's extract the size of the length prefix from the decoder config\n                    const bytes = toUint8Array(decoderConfig.description);\n                    const lengthSizeMinusOne = bytes[4] & 0b11;\n                    const lengthSize = (lengthSizeMinusOne + 1);\n                    nalUnits = findNalUnitsInLengthPrefixed(packet.data, lengthSize);\n                }\n                else {\n                    // Stream is in Annex B format\n                    nalUnits = findNalUnitsInAnnexB(packet.data);\n                }\n                const isKeyframe = nalUnits.some(x => extractNalUnitTypeForAvc(x) === 5);\n                return isKeyframe ? 'key' : 'delta';\n            }\n            ;\n        case 'hevc':\n            {\n                const decoderConfig = await videoTrack.getDecoderConfig();\n                assert(decoderConfig);\n                let nalUnits;\n                if (decoderConfig.description) {\n                    // Stream is length-prefixed. Let's extract the size of the length prefix from the decoder config\n                    const bytes = toUint8Array(decoderConfig.description);\n                    const lengthSizeMinusOne = bytes[21] & 0b11;\n                    const lengthSize = (lengthSizeMinusOne + 1);\n                    nalUnits = findNalUnitsInLengthPrefixed(packet.data, lengthSize);\n                }\n                else {\n                    // Stream is in Annex B format\n                    nalUnits = findNalUnitsInAnnexB(packet.data);\n                }\n                const isKeyframe = nalUnits.some((x) => {\n                    const type = extractNalUnitTypeForHevc(x);\n                    return 16 <= type && type <= 23;\n                });\n                return isKeyframe ? 'key' : 'delta';\n            }\n            ;\n        case 'vp8':\n            {\n                // VP8, once again, by far the easiest to deal with.\n                const frameType = packet.data[0] & 0b1;\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'vp9':\n            {\n                const bitstream = new Bitstream(packet.data);\n                if (bitstream.readBits(2) !== 2) {\n                    return null;\n                }\n                ;\n                const profileLowBit = bitstream.readBits(1);\n                const profileHighBit = bitstream.readBits(1);\n                const profile = (profileHighBit << 1) + profileLowBit;\n                // Skip reserved bit for profile 3\n                if (profile === 3) {\n                    bitstream.skipBits(1);\n                }\n                const showExistingFrame = bitstream.readBits(1);\n                if (showExistingFrame) {\n                    return null;\n                }\n                const frameType = bitstream.readBits(1);\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'av1':\n            {\n                let reducedStillPictureHeader = false;\n                for (const { type, data } of iterateAv1PacketObus(packet.data)) {\n                    if (type === 1) { // OBU_SEQUENCE_HEADER\n                        const bitstream = new Bitstream(data);\n                        bitstream.skipBits(4);\n                        reducedStillPictureHeader = !!bitstream.readBits(1);\n                    }\n                    else if (type === 3 // OBU_FRAME_HEADER\n                        || type === 6 // OBU_FRAME\n                        || type === 7 // OBU_REDUNDANT_FRAME_HEADER\n                    ) {\n                        if (reducedStillPictureHeader) {\n                            return 'key';\n                        }\n                        const bitstream = new Bitstream(data);\n                        const showExistingFrame = bitstream.readBits(1);\n                        if (showExistingFrame) {\n                            return null;\n                        }\n                        const frameType = bitstream.readBits(2);\n                        return frameType === 0 ? 'key' : 'delta';\n                    }\n                }\n                return null;\n            }\n            ;\n        default:\n            {\n                assertNever(videoTrack.codec);\n                assert(false);\n            }\n            ;\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3229, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/demuxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport class Demuxer {\n    constructor(input) {\n        this.input = input;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AACM,MAAM;IACT,YAAY,KAAK,CAAE;QACf,IAAI,CAAC,KAAK,GAAG;IACjB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3247, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/packet.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { SECOND_TO_MICROSECOND_FACTOR } from './misc.js';\nexport const PLACEHOLDER_DATA = new Uint8Array(0);\n/**\n * Represents an encoded chunk of media. Mainly used as an expressive wrapper around WebCodecs API's EncodedVideoChunk\n * and EncodedAudioChunk, but can also be used standalone.\n * @public\n */\nexport class EncodedPacket {\n    constructor(\n    /** The encoded data of this packet. */\n    data, \n    /** The type of this packet. */\n    type, \n    /**\n     * The presentation timestamp of this packet in seconds. May be negative. Samples with negative end timestamps\n     * should not be presented.\n     */\n    timestamp, \n    /** The duration of this packet in seconds. */\n    duration, \n    /**\n     * The sequence number indicates the decode order of the packets. Packet A  must be decoded before packet B if A\n     * has a lower sequence number than B. If two packets have the same sequence number, they are the same packet.\n     * Otherwise, sequence numbers are arbitrary and are not guaranteed to have any meaning besides their relative\n     * ordering. Negative sequence numbers mean the sequence number is undefined.\n     */\n    sequenceNumber = -1, byteLength) {\n        this.data = data;\n        this.type = type;\n        this.timestamp = timestamp;\n        this.duration = duration;\n        this.sequenceNumber = sequenceNumber;\n        if (data === PLACEHOLDER_DATA && byteLength === undefined) {\n            throw new Error('Internal error: byteLength must be explicitly provided when constructing metadata-only packets.');\n        }\n        if (byteLength === undefined) {\n            byteLength = data.byteLength;\n        }\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (type !== 'key' && type !== 'delta') {\n            throw new TypeError('type must be either \"key\" or \"delta\".');\n        }\n        if (!Number.isFinite(timestamp)) {\n            throw new TypeError('timestamp must be a number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        if (!Number.isFinite(sequenceNumber)) {\n            throw new TypeError('sequenceNumber must be a number.');\n        }\n        if (!Number.isInteger(byteLength) || byteLength < 0) {\n            throw new TypeError('byteLength must be a non-negative integer.');\n        }\n        this.byteLength = byteLength;\n    }\n    /** If this packet is a metadata-only packet. Metadata-only packets don't contain their packet data. */\n    get isMetadataOnly() {\n        return this.data === PLACEHOLDER_DATA;\n    }\n    /** The timestamp of this packet in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of this packet in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /** Converts this packet to an EncodedVideoChunk for use with the WebCodecs API. */\n    toEncodedVideoChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to a video chunk.');\n        }\n        if (typeof EncodedVideoChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedVideoChunk.');\n        }\n        return new EncodedVideoChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /** Converts this packet to an EncodedAudioChunk for use with the WebCodecs API. */\n    toEncodedAudioChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to an audio chunk.');\n        }\n        if (typeof EncodedAudioChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedAudioChunk.');\n        }\n        return new EncodedAudioChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /**\n     * Creates an EncodedPacket from an EncodedVideoChunk or EncodedAudioChunk. This method is useful for converting\n     * chunks from the WebCodecs API to EncodedPackets.\n     */\n    static fromEncodedChunk(chunk) {\n        if (!(chunk instanceof EncodedVideoChunk || chunk instanceof EncodedAudioChunk)) {\n            throw new TypeError('chunk must be an EncodedVideoChunk or EncodedAudioChunk.');\n        }\n        const data = new Uint8Array(chunk.byteLength);\n        chunk.copyTo(data);\n        return new EncodedPacket(data, chunk.type, chunk.timestamp / 1e6, (chunk.duration ?? 0) / 1e6);\n    }\n    /** Clones this packet while optionally updating timing information. */\n    clone(options) {\n        if (options !== undefined && (typeof options !== 'object' || options === null)) {\n            throw new TypeError('options, when provided, must be an object.');\n        }\n        if (options?.timestamp !== undefined && !Number.isFinite(options.timestamp)) {\n            throw new TypeError('options.timestamp, when provided, must be a number.');\n        }\n        if (options?.duration !== undefined && !Number.isFinite(options.duration)) {\n            throw new TypeError('options.duration, when provided, must be a number.');\n        }\n        return new EncodedPacket(this.data, this.type, options?.timestamp ?? this.timestamp, options?.duration ?? this.duration, this.sequenceNumber, this.byteLength);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3366, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/pcm.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n// https://github.com/dystopiancode/pcm-g711/blob/master/pcm-g711/g711.c\nexport const toUlaw = (s16) => {\n    const MULAW_MAX = 0x1FFF;\n    const MULAW_BIAS = 33;\n    let number = s16;\n    let mask = 0x1000;\n    let sign = 0;\n    let position = 12;\n    let lsb = 0;\n    if (number < 0) {\n        number = -number;\n        sign = 0x80;\n    }\n    number += MULAW_BIAS;\n    if (number > MULAW_MAX) {\n        number = MULAW_MAX;\n    }\n    while ((number & mask) !== mask && position >= 5) {\n        mask >>= 1;\n        position--;\n    }\n    lsb = (number >> (position - 4)) & 0x0f;\n    return ~(sign | ((position - 5) << 4) | lsb) & 0xFF;\n};\nexport const fromUlaw = (u8) => {\n    const MULAW_BIAS = 33;\n    let sign = 0;\n    let position = 0;\n    let number = ~u8;\n    if (number & 0x80) {\n        number &= ~(1 << 7);\n        sign = -1;\n    }\n    position = ((number & 0xF0) >> 4) + 5;\n    const decoded = ((1 << position) | ((number & 0x0F) << (position - 4))\n        | (1 << (position - 5))) - MULAW_BIAS;\n    return (sign === 0) ? decoded : -decoded;\n};\nexport const toAlaw = (s16) => {\n    const ALAW_MAX = 0xFFF;\n    let mask = 0x800;\n    let sign = 0;\n    let position = 11;\n    let lsb = 0;\n    let number = s16;\n    if (number < 0) {\n        number = -number;\n        sign = 0x80;\n    }\n    if (number > ALAW_MAX) {\n        number = ALAW_MAX;\n    }\n    while ((number & mask) !== mask && position >= 5) {\n        mask >>= 1;\n        position--;\n    }\n    lsb = (number >> ((position === 4) ? 1 : (position - 4))) & 0x0f;\n    return (sign | ((position - 4) << 4) | lsb) ^ 0x55;\n};\nexport const fromAlaw = (u8) => {\n    let sign = 0x00;\n    let position = 0;\n    let number = u8 ^ 0x55;\n    if (number & 0x80) {\n        number &= ~(1 << 7);\n        sign = -1;\n    }\n    position = ((number & 0xF0) >> 4) + 4;\n    let decoded = 0;\n    if (position !== 4) {\n        decoded = ((1 << position) | ((number & 0x0F) << (position - 4))\n            | (1 << (position - 5)));\n    }\n    else {\n        decoded = (number << 1) | 1;\n    }\n    return (sign === 0) ? decoded : -decoded;\n};\n"],"names":[],"mappings":"AAAA;;;;;;CAMC,GACD,wEAAwE;;;;;;;AACjE,MAAM,SAAS,CAAC;IACnB,MAAM,YAAY;IAClB,MAAM,aAAa;IACnB,IAAI,SAAS;IACb,IAAI,OAAO;IACX,IAAI,OAAO;IACX,IAAI,WAAW;IACf,IAAI,MAAM;IACV,IAAI,SAAS,GAAG;QACZ,SAAS,CAAC;QACV,OAAO;IACX;IACA,UAAU;IACV,IAAI,SAAS,WAAW;QACpB,SAAS;IACb;IACA,MAAO,CAAC,SAAS,IAAI,MAAM,QAAQ,YAAY,EAAG;QAC9C,SAAS;QACT;IACJ;IACA,MAAM,AAAC,UAAW,WAAW,IAAM;IACnC,OAAO,CAAC,CAAC,OAAQ,AAAC,WAAW,KAAM,IAAK,GAAG,IAAI;AACnD;AACO,MAAM,WAAW,CAAC;IACrB,MAAM,aAAa;IACnB,IAAI,OAAO;IACX,IAAI,WAAW;IACf,IAAI,SAAS,CAAC;IACd,IAAI,SAAS,MAAM;QACf,UAAU,CAAC,CAAC,KAAK,CAAC;QAClB,OAAO,CAAC;IACZ;IACA,WAAW,CAAC,CAAC,SAAS,IAAI,KAAK,CAAC,IAAI;IACpC,MAAM,UAAU,CAAC,AAAC,KAAK,WAAa,CAAC,SAAS,IAAI,KAAM,WAAW,IAC5D,KAAM,WAAW,CAAG,IAAI;IAC/B,OAAO,AAAC,SAAS,IAAK,UAAU,CAAC;AACrC;AACO,MAAM,SAAS,CAAC;IACnB,MAAM,WAAW;IACjB,IAAI,OAAO;IACX,IAAI,OAAO;IACX,IAAI,WAAW;IACf,IAAI,MAAM;IACV,IAAI,SAAS;IACb,IAAI,SAAS,GAAG;QACZ,SAAS,CAAC;QACV,OAAO;IACX;IACA,IAAI,SAAS,UAAU;QACnB,SAAS;IACb;IACA,MAAO,CAAC,SAAS,IAAI,MAAM,QAAQ,YAAY,EAAG;QAC9C,SAAS;QACT;IACJ;IACA,MAAM,AAAC,UAAU,CAAC,AAAC,aAAa,IAAK,IAAK,WAAW,CAAE,IAAK;IAC5D,OAAO,CAAC,OAAQ,AAAC,WAAW,KAAM,IAAK,GAAG,IAAI;AAClD;AACO,MAAM,WAAW,CAAC;IACrB,IAAI,OAAO;IACX,IAAI,WAAW;IACf,IAAI,SAAS,KAAK;IAClB,IAAI,SAAS,MAAM;QACf,UAAU,CAAC,CAAC,KAAK,CAAC;QAClB,OAAO,CAAC;IACZ;IACA,WAAW,CAAC,CAAC,SAAS,IAAI,KAAK,CAAC,IAAI;IACpC,IAAI,UAAU;IACd,IAAI,aAAa,GAAG;QAChB,UAAW,AAAC,KAAK,WAAa,CAAC,SAAS,IAAI,KAAM,WAAW,IACtD,KAAM,WAAW;IAC5B,OACK;QACD,UAAU,AAAC,UAAU,IAAK;IAC9B;IACA,OAAO,AAAC,SAAS,IAAK,UAAU,CAAC;AACrC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3457, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/sample.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert, clamp, isAllowSharedBufferSource, SECOND_TO_MICROSECOND_FACTOR, toDataView, toUint8Array, } from './misc.js';\n/**\n * Represents a raw, unencoded video sample (frame). Mainly used as an expressive wrapper around WebCodecs API's\n * VideoFrame, but can also be used standalone.\n * @public\n */\nexport class VideoSample {\n    /** The width of the frame in pixels after rotation. */\n    get displayWidth() {\n        return this.rotation % 180 === 0 ? this.codedWidth : this.codedHeight;\n    }\n    /** The height of the frame in pixels after rotation. */\n    get displayHeight() {\n        return this.rotation % 180 === 0 ? this.codedHeight : this.codedWidth;\n    }\n    /** The presentation timestamp of the frame in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the frame in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    constructor(data, init) {\n        /** @internal */\n        this._closed = false;\n        if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (!('format' in init) || typeof init.format !== 'string') {\n                throw new TypeError('init.format must be a string.');\n            }\n            if (!Number.isInteger(init.codedWidth) || init.codedWidth <= 0) {\n                throw new TypeError('init.codedWidth must be a positive integer.');\n            }\n            if (!Number.isInteger(init.codedHeight) || init.codedHeight <= 0) {\n                throw new TypeError('init.codedHeight must be a positive integer.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = toUint8Array(data).slice(); // Copy it\n            this.format = init.format;\n            this.codedWidth = init.codedWidth;\n            this.codedHeight = init.codedHeight;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoColorSpace(init.colorSpace);\n        }\n        else if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n            if (init?.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (init?.timestamp !== undefined && !Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp, when provided, must be a number.');\n            }\n            if (init?.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = data;\n            this.format = data.format;\n            this.codedWidth = data.codedWidth;\n            this.codedHeight = data.codedHeight;\n            this.rotation = init?.rotation ?? 0;\n            this.timestamp = init?.timestamp ?? data.timestamp / 1e6;\n            this.duration = init?.duration ?? (data.duration ?? 0) / 1e6;\n            this.colorSpace = data.colorSpace;\n        }\n        else if ((typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement)\n            || (typeof SVGImageElement !== 'undefined' && data instanceof SVGImageElement)\n            || (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap)\n            || (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement)\n            || (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement)\n            || (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            if (typeof VideoFrame !== 'undefined') {\n                return new VideoSample(new VideoFrame(data, {\n                    timestamp: Math.trunc(init.timestamp * SECOND_TO_MICROSECOND_FACTOR),\n                    duration: Math.trunc((init.duration ?? 0) * SECOND_TO_MICROSECOND_FACTOR),\n                }), init);\n            }\n            let width = 0;\n            let height = 0;\n            // Determine the dimensions of the thing\n            if ('naturalWidth' in data) {\n                width = data.naturalWidth;\n                height = data.naturalHeight;\n            }\n            else if ('videoWidth' in data) {\n                width = data.videoWidth;\n                height = data.videoHeight;\n            }\n            else if ('width' in data) {\n                width = Number(data.width);\n                height = Number(data.height);\n            }\n            if (!width || !height) {\n                throw new TypeError('Could not determine dimensions.');\n            }\n            const canvas = new OffscreenCanvas(width, height);\n            const context = canvas.getContext('2d', { alpha: false, willReadFrequently: true });\n            assert(context);\n            // Draw it to a canvas\n            context.drawImage(data, 0, 0);\n            this._data = canvas;\n            this.format = 'RGBX';\n            this.codedWidth = width;\n            this.codedHeight = height;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoColorSpace({\n                matrix: 'rgb',\n                primaries: 'bt709',\n                transfer: 'iec61966-2-1',\n                fullRange: true,\n            });\n        }\n        else {\n            throw new TypeError('Invalid data type: Must be a BufferSource or CanvasImageSource.');\n        }\n    }\n    /** Clones this video sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoSample(this._data.clone(), {\n                timestamp: this.timestamp,\n                duration: this.duration,\n                rotation: this.rotation,\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            return new VideoSample(this._data.slice(), {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n        else {\n            return new VideoSample(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n    }\n    /**\n     * Closes this video sample, releasing held resources. Video samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        if (isVideoFrame(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = null; // GC that shit\n        }\n        this._closed = true;\n    }\n    /** Returns the number of bytes required to hold this video sample's pixel data. */\n    allocationSize() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return this._data.allocationSize();\n        }\n        else if (this._data instanceof Uint8Array) {\n            return this._data.byteLength;\n        }\n        else {\n            return this.codedWidth * this.codedHeight * 4; // RGBX\n        }\n    }\n    /** Copies this video sample's pixel data to an ArrayBuffer or ArrayBufferView. */\n    async copyTo(destination) {\n        if (!isAllowSharedBufferSource(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            await this._data.copyTo(destination);\n        }\n        else if (this._data instanceof Uint8Array) {\n            const dest = toUint8Array(destination);\n            dest.set(this._data);\n        }\n        else {\n            const canvas = this._data;\n            const context = canvas.getContext('2d', { alpha: false });\n            assert(context);\n            const imageData = context.getImageData(0, 0, this.codedWidth, this.codedHeight);\n            const dest = toUint8Array(destination);\n            dest.set(imageData.data);\n        }\n    }\n    /**\n     * Converts this video sample to a VideoFrame for use with the WebCodecs API. The VideoFrame returned by this\n     * method *must* be closed separately from this video sample.\n     */\n    toVideoFrame() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined, // Drag 0 duration to undefined, glitches some codecs\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            return new VideoFrame(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration,\n                colorSpace: this.colorSpace,\n            });\n        }\n        else {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration,\n            });\n        }\n    }\n    draw(context, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n        let sx = 0;\n        let sy = 0;\n        let sWidth = this.displayWidth;\n        let sHeight = this.displayHeight;\n        let dx = 0;\n        let dy = 0;\n        let dWidth = this.displayWidth;\n        let dHeight = this.displayHeight;\n        if (arg5 !== undefined) {\n            sx = arg1;\n            sy = arg2;\n            sWidth = arg3;\n            sHeight = arg4;\n            dx = arg5;\n            dy = arg6;\n            if (arg7 !== undefined) {\n                dWidth = arg7;\n                dHeight = arg8;\n            }\n            else {\n                dWidth = sWidth;\n                dHeight = sHeight;\n            }\n        }\n        else {\n            dx = arg1;\n            dy = arg2;\n            if (arg3 !== undefined) {\n                dWidth = arg3;\n                dHeight = arg4;\n            }\n        }\n        if (!((typeof CanvasRenderingContext2D !== 'undefined' && context instanceof CanvasRenderingContext2D)\n            || (typeof OffscreenCanvasRenderingContext2D !== 'undefined'\n                && context instanceof OffscreenCanvasRenderingContext2D))) {\n            throw new TypeError('context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.');\n        }\n        if (!Number.isFinite(sx)) {\n            throw new TypeError('sx must be a number.');\n        }\n        if (!Number.isFinite(sy)) {\n            throw new TypeError('sy must be a number.');\n        }\n        if (!Number.isFinite(sWidth) || sWidth < 0) {\n            throw new TypeError('sWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(sHeight) || sHeight < 0) {\n            throw new TypeError('sHeight must be a non-negative number.');\n        }\n        if (!Number.isFinite(dx)) {\n            throw new TypeError('dx must be a number.');\n        }\n        if (!Number.isFinite(dy)) {\n            throw new TypeError('dy must be a number.');\n        }\n        if (!Number.isFinite(dWidth) || dWidth < 0) {\n            throw new TypeError('dWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(dHeight) || dHeight < 0) {\n            throw new TypeError('dHeight must be a non-negative number.');\n        }\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        // The provided sx,sy,sWidth,sHeight refer to the final rotated image, but that's not actually how the image is\n        // stored. Therefore, we must map these back onto the original, pre-rotation image.\n        if (this.rotation === 90) {\n            [sx, sy, sWidth, sHeight] = [\n                sy,\n                this.codedHeight - sx - sWidth,\n                sHeight,\n                sWidth,\n            ];\n        }\n        else if (this.rotation === 180) {\n            [sx, sy] = [\n                this.codedWidth - sx - sWidth,\n                this.codedHeight - sy - sHeight,\n            ];\n        }\n        else if (this.rotation === 270) {\n            [sx, sy, sWidth, sHeight] = [\n                this.codedWidth - sy - sHeight,\n                sx,\n                sHeight,\n                sWidth,\n            ];\n        }\n        const source = this.toCanvasImageSource();\n        context.save();\n        const centerX = dx + dWidth / 2;\n        const centerY = dy + dHeight / 2;\n        context.translate(centerX, centerY);\n        context.rotate(this.rotation * Math.PI / 180);\n        const aspectRatioChange = this.rotation % 180 === 0 ? 1 : dWidth / dHeight;\n        // Scale to compensate for aspect ratio changes when rotated\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.drawImage(source, sx, sy, sWidth, sHeight, -dWidth / 2, -dHeight / 2, dWidth, dHeight);\n        // Restore the previous transformation state\n        context.restore();\n    }\n    /**\n     * Converts this video sample to a CanvasImageSource for drawing to a canvas.\n     *\n     * You must use the value returned by this method immediately, as any VideoFrame created internally will\n     * automatically be closed in the next microtask.\n     */\n    toCanvasImageSource() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (this._data instanceof Uint8Array) {\n            // Requires VideoFrame to be defined\n            const videoFrame = this.toVideoFrame();\n            queueMicrotask(() => videoFrame.close()); // Let's automatically close the frame in the next microtask\n            return videoFrame;\n        }\n        else {\n            return this._data;\n        }\n    }\n    /** Sets the rotation metadata of this video sample. */\n    setRotation(newRotation) {\n        if (![0, 90, 180, 270].includes(newRotation)) {\n            throw new TypeError('newRotation must be 0, 90, 180, or 270.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.rotation = newRotation;\n    }\n    /** Sets the presentation timestamp of this video sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** Sets the duration of this video sample, in seconds. */\n    setDuration(newDuration) {\n        if (!Number.isFinite(newDuration) || newDuration < 0) {\n            throw new TypeError('newDuration must be a non-negative number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.duration = newDuration;\n    }\n}\nconst isVideoFrame = (x) => {\n    return typeof VideoFrame !== 'undefined' && x instanceof VideoFrame;\n};\nconst AUDIO_SAMPLE_FORMATS = new Set(['f32', 'f32-planar', 's16', 's16-planar', 's32', 's32-planar', 'u8', 'u8-planar']);\n/**\n * Represents a raw, unencoded audio sample. Mainly used as an expressive wrapper around WebCodecs API's AudioData,\n * but can also be used standalone.\n * @public\n */\nexport class AudioSample {\n    /** The presentation timestamp of the sample in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the sample in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    constructor(init) {\n        /** @internal */\n        this._closed = false;\n        if (isAudioData(init)) {\n            if (init.format === null) {\n                throw new TypeError('AudioData with null format is not supported.');\n            }\n            this._data = init;\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = init.numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp / 1e6;\n            this.duration = init.numberOfFrames / init.sampleRate;\n        }\n        else {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('Invalid AudioDataInit: must be an object.');\n            }\n            if (!AUDIO_SAMPLE_FORMATS.has(init.format)) {\n                throw new TypeError('Invalid AudioDataInit: invalid format.');\n            }\n            if (!Number.isFinite(init.sampleRate) || init.sampleRate <= 0) {\n                throw new TypeError('Invalid AudioDataInit: sampleRate must be > 0.');\n            }\n            if (!Number.isInteger(init.numberOfChannels) || init.numberOfChannels === 0) {\n                throw new TypeError('Invalid AudioDataInit: numberOfChannels must be an integer > 0.');\n            }\n            if (!Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            const numberOfFrames = init.data.byteLength / (getBytesPerSample(init.format) * init.numberOfChannels);\n            if (!Number.isInteger(numberOfFrames)) {\n                throw new TypeError('Invalid AudioDataInit: data size is not a multiple of frame size.');\n            }\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp;\n            this.duration = numberOfFrames / init.sampleRate;\n            let dataBuffer;\n            if (init.data instanceof ArrayBuffer) {\n                dataBuffer = new Uint8Array(init.data);\n            }\n            else if (ArrayBuffer.isView(init.data)) {\n                dataBuffer = new Uint8Array(init.data.buffer, init.data.byteOffset, init.data.byteLength);\n            }\n            else {\n                throw new TypeError('Invalid AudioDataInit: data is not a BufferSource.');\n            }\n            const expectedSize = this.numberOfFrames * this.numberOfChannels * getBytesPerSample(this.format);\n            if (dataBuffer.byteLength < expectedSize) {\n                throw new TypeError('Invalid AudioDataInit: insufficient data size.');\n            }\n            this._data = dataBuffer;\n        }\n    }\n    /** Returns the number of bytes required to hold the audio sample's data as specified by the given options. */\n    allocationSize(options) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const destFormat = options.format ?? this.format;\n        const frameOffset = options.frameOffset ?? 0;\n        if (frameOffset >= this.numberOfFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = options.frameCount !== undefined ? options.frameCount : (this.numberOfFrames - frameOffset);\n        if (copyFrameCount > (this.numberOfFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const bytesPerSample = getBytesPerSample(destFormat);\n        const isPlanar = formatIsPlanar(destFormat);\n        if (isPlanar && options.planeIndex >= this.numberOfChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!isPlanar && options.planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const elementCount = isPlanar ? copyFrameCount : copyFrameCount * this.numberOfChannels;\n        return elementCount * bytesPerSample;\n    }\n    /** Copies the audio sample's data to an ArrayBuffer or ArrayBufferView as specified by the given options. */\n    copyTo(destination, options) {\n        if (!isAllowSharedBufferSource(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const { planeIndex, format, frameCount: optFrameCount, frameOffset: optFrameOffset } = options;\n        const destFormat = format ?? this.format;\n        if (!destFormat)\n            throw new Error('Destination format not determined');\n        const numFrames = this.numberOfFrames;\n        const numChannels = this.numberOfChannels;\n        const frameOffset = optFrameOffset ?? 0;\n        if (frameOffset >= numFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = optFrameCount !== undefined ? optFrameCount : (numFrames - frameOffset);\n        if (copyFrameCount > (numFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const destBytesPerSample = getBytesPerSample(destFormat);\n        const destIsPlanar = formatIsPlanar(destFormat);\n        if (destIsPlanar && planeIndex >= numChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!destIsPlanar && planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const destElementCount = destIsPlanar ? copyFrameCount : copyFrameCount * numChannels;\n        const requiredSize = destElementCount * destBytesPerSample;\n        if (destination.byteLength < requiredSize) {\n            throw new RangeError('Destination buffer is too small');\n        }\n        const destView = toDataView(destination);\n        const writeFn = getWriteFunction(destFormat);\n        if (isAudioData(this._data)) {\n            if (destIsPlanar) {\n                if (destFormat === 'f32-planar') {\n                    // Simple, since the browser must support f32-planar, we can just delegate here\n                    this._data.copyTo(destination, {\n                        planeIndex,\n                        frameOffset,\n                        frameCount: copyFrameCount,\n                        format: 'f32-planar',\n                    });\n                }\n                else {\n                    // Allocate temporary buffer for f32-planar data\n                    const tempBuffer = new ArrayBuffer(copyFrameCount * 4);\n                    const tempArray = new Float32Array(tempBuffer);\n                    this._data.copyTo(tempArray, {\n                        planeIndex,\n                        frameOffset,\n                        frameCount: copyFrameCount,\n                        format: 'f32-planar',\n                    });\n                    // Convert each f32 sample to destination format\n                    const tempView = new DataView(tempBuffer);\n                    for (let i = 0; i < copyFrameCount; i++) {\n                        const destOffset = i * destBytesPerSample;\n                        const sample = tempView.getFloat32(i * 4, true);\n                        writeFn(destView, destOffset, sample);\n                    }\n                }\n            }\n            else {\n                // Destination is interleaved.\n                // Allocate a temporary Float32Array to hold one channel's worth of data.\n                const numCh = numChannels;\n                const temp = new Float32Array(copyFrameCount);\n                for (let ch = 0; ch < numCh; ch++) {\n                    this._data.copyTo(temp, {\n                        planeIndex: ch,\n                        frameOffset,\n                        frameCount: copyFrameCount,\n                        format: 'f32-planar',\n                    });\n                    for (let i = 0; i < copyFrameCount; i++) {\n                        const destIndex = i * numCh + ch;\n                        const destOffset = destIndex * destBytesPerSample;\n                        writeFn(destView, destOffset, temp[i]);\n                    }\n                }\n            }\n        }\n        else {\n            // Branch for Uint8Array data (non-AudioData)\n            const uint8Data = this._data;\n            const srcView = new DataView(uint8Data.buffer, uint8Data.byteOffset, uint8Data.byteLength);\n            const srcFormat = this.format;\n            const readFn = getReadFunction(srcFormat);\n            const srcBytesPerSample = getBytesPerSample(srcFormat);\n            const srcIsPlanar = formatIsPlanar(srcFormat);\n            for (let i = 0; i < copyFrameCount; i++) {\n                if (destIsPlanar) {\n                    const destOffset = i * destBytesPerSample;\n                    let srcOffset;\n                    if (srcIsPlanar) {\n                        srcOffset = (planeIndex * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                    }\n                    else {\n                        srcOffset = (((i + frameOffset) * numChannels) + planeIndex) * srcBytesPerSample;\n                    }\n                    const normalized = readFn(srcView, srcOffset);\n                    writeFn(destView, destOffset, normalized);\n                }\n                else {\n                    for (let ch = 0; ch < numChannels; ch++) {\n                        const destIndex = i * numChannels + ch;\n                        const destOffset = destIndex * destBytesPerSample;\n                        let srcOffset;\n                        if (srcIsPlanar) {\n                            srcOffset = (ch * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                        }\n                        else {\n                            srcOffset = (((i + frameOffset) * numChannels) + ch) * srcBytesPerSample;\n                        }\n                        const normalized = readFn(srcView, srcOffset);\n                        writeFn(destView, destOffset, normalized);\n                    }\n                }\n            }\n        }\n    }\n    /** Clones this audio sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            const sample = new AudioSample(this._data.clone());\n            sample.setTimestamp(this.timestamp); // Make sure the timestamp is precise (beyond microsecond accuracy)\n            return sample;\n        }\n        else {\n            return new AudioSample({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.timestamp,\n                data: this._data,\n            });\n        }\n    }\n    /**\n     * Closes this audio sample, releasing held resources. Audio samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        if (isAudioData(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = new Uint8Array(0);\n        }\n        this._closed = true;\n    }\n    /**\n     * Converts this audio sample to an AudioData for use with the WebCodecs API. The AudioData returned by this\n     * method *must* be closed separately from this audio sample.\n     */\n    toAudioData() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            if (this._data.timestamp === this.microsecondTimestamp) {\n                // Timestamp matches, let's just return the data (but cloned)\n                return this._data.clone();\n            }\n            else {\n                // It's impossible to simply change an AudioData's timestamp, so we'll need to create a new one\n                if (formatIsPlanar(this.format)) {\n                    const size = this.allocationSize({ planeIndex: 0, format: this.format });\n                    const data = new ArrayBuffer(size * this.numberOfChannels);\n                    // We gotta read out each plane individually\n                    for (let i = 0; i < this.numberOfChannels; i++) {\n                        this.copyTo(new Uint8Array(data, i * size, size), { planeIndex: i, format: this.format });\n                    }\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n                else {\n                    const data = new ArrayBuffer(this.allocationSize({ planeIndex: 0, format: this.format }));\n                    this.copyTo(data, { planeIndex: 0, format: this.format });\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n            }\n        }\n        else {\n            return new AudioData({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.microsecondTimestamp,\n                data: this._data,\n            });\n        }\n    }\n    /** Convert this audio sample to an AudioBuffer for use with the Web Audio API. */\n    toAudioBuffer() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const audioBuffer = new AudioBuffer({\n            numberOfChannels: this.numberOfChannels,\n            length: this.numberOfFrames,\n            sampleRate: this.sampleRate,\n        });\n        const dataBytes = new Float32Array(this.allocationSize({ planeIndex: 0, format: 'f32-planar' }) / 4);\n        for (let i = 0; i < this.numberOfChannels; i++) {\n            this.copyTo(dataBytes, { planeIndex: i, format: 'f32-planar' });\n            audioBuffer.copyToChannel(dataBytes, i);\n        }\n        return audioBuffer;\n    }\n    /** Sets the presentation timestamp of this audio sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** @internal */\n    static *_fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            yield new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n    }\n    /**\n     * Creates AudioSamples from an AudioBuffer, starting at the given timestamp in seconds. Typically creates exactly\n     * one sample, but may create multiple if the AudioBuffer is exceedingly large.\n     */\n    static fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        const result = [];\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            const audioSample = new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            result.push(audioSample);\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n        return result;\n    }\n}\nconst getBytesPerSample = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return 1;\n        case 's16':\n        case 's16-planar':\n            return 2;\n        case 's32':\n        case 's32-planar':\n            return 4;\n        case 'f32':\n        case 'f32-planar':\n            return 4;\n        default:\n            throw new Error('Unknown AudioSampleFormat');\n    }\n};\nconst formatIsPlanar = (format) => {\n    switch (format) {\n        case 'u8-planar':\n        case 's16-planar':\n        case 's32-planar':\n        case 'f32-planar':\n            return true;\n        default:\n            return false;\n    }\n};\nconst getReadFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset) => (view.getUint8(offset) - 128) / 128;\n        case 's16':\n        case 's16-planar':\n            return (view, offset) => view.getInt16(offset, true) / 32768;\n        case 's32':\n        case 's32-planar':\n            return (view, offset) => view.getInt32(offset, true) / 2147483648;\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset) => view.getFloat32(offset, true);\n    }\n};\nconst getWriteFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset, value) => view.setUint8(offset, clamp((value + 1) * 127.5, 0, 255));\n        case 's16':\n        case 's16-planar':\n            return (view, offset, value) => view.setInt16(offset, clamp(Math.round(value * 32767), -32768, 32767), true);\n        case 's32':\n        case 's32-planar':\n            return (view, offset, value) => view.setInt32(offset, clamp(Math.round(value * 2147483647), -2147483648, 2147483647), true);\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset, value) => view.setFloat32(offset, value, true);\n    }\n};\nconst isAudioData = (x) => {\n    return typeof AudioData !== 'undefined' && x instanceof AudioData;\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4369, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/media-sink.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { parsePcmCodec, PCM_AUDIO_CODECS } from './codec.js';\nimport { customVideoDecoders, customAudioDecoders } from './custom-coder.js';\nimport { InputAudioTrack, InputTrack, InputVideoTrack } from './input-track.js';\nimport { assert, assertNever, CallSerializer, getInt24, getUint24, insertSorted, isSafari, last, mapAsyncGenerator, promiseWithResolvers, toAsyncIterator, toDataView, validateAnyIterable, } from './misc.js';\nimport { EncodedPacket } from './packet.js';\nimport { fromAlaw, fromUlaw } from './pcm.js';\nimport { AudioSample, VideoSample } from './sample.js';\nconst validatePacketRetrievalOptions = (options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('options must be an object.');\n    }\n    if (options.metadataOnly !== undefined && typeof options.metadataOnly !== 'boolean') {\n        throw new TypeError('options.metadataOnly, when defined, must be a boolean.');\n    }\n    if (options.verifyKeyPackets !== undefined && typeof options.verifyKeyPackets !== 'boolean') {\n        throw new TypeError('options.verifyKeyPackets, when defined, must be a boolean.');\n    }\n    if (options.verifyKeyPackets && options.metadataOnly) {\n        throw new TypeError('options.verifyKeyPackets and options.metadataOnly cannot be enabled together.');\n    }\n};\nconst validateTimestamp = (timestamp) => {\n    if (typeof timestamp !== 'number' || Number.isNaN(timestamp)) {\n        throw new TypeError('timestamp must be a number.'); // It can be non-finite, that's fine\n    }\n};\nconst maybeFixPacketType = (track, promise, options) => {\n    if (options.verifyKeyPackets) {\n        return promise.then(async (packet) => {\n            if (!packet || packet.type === 'delta') {\n                return packet;\n            }\n            const determinedType = await track.determinePacketType(packet);\n            if (determinedType) {\n                // @ts-expect-error Technically readonly\n                packet.type = determinedType;\n            }\n            return packet;\n        });\n    }\n    else {\n        return promise;\n    }\n};\n/**\n * Sink for retrieving encoded packets from an input track.\n * @public\n */\nexport class EncodedPacketSink {\n    constructor(track) {\n        if (!(track instanceof InputTrack)) {\n            throw new TypeError('track must be an InputTrack.');\n        }\n        this._track = track;\n    }\n    /**\n     * Retrieves the track's first packet (in decode order), or null if it has no packets. The first packet is very\n     * likely to be a key packet.\n     */\n    getFirstPacket(options = {}) {\n        validatePacketRetrievalOptions(options);\n        return maybeFixPacketType(this._track, this._track._backing.getFirstPacket(options), options);\n    }\n    /**\n     * Retrieves the packet corresponding to the given timestamp, in seconds. More specifically, returns the last packet\n     * (in presentation order) with a start timestamp less than or equal to the given timestamp. This method can be\n     * used to retrieve a track's last packet using `getPacket(Infinity)`. The method returns null if the timestamp\n     * is before the first packet in the track.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    getPacket(timestamp, options = {}) {\n        validateTimestamp(timestamp);\n        validatePacketRetrievalOptions(options);\n        return maybeFixPacketType(this._track, this._track._backing.getPacket(timestamp, options), options);\n    }\n    /**\n     * Retrieves the packet following the given packet (in decode order), or null if the given packet is the\n     * last packet.\n     */\n    getNextPacket(packet, options = {}) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        validatePacketRetrievalOptions(options);\n        return maybeFixPacketType(this._track, this._track._backing.getNextPacket(packet, options), options);\n    }\n    /**\n     * Retrieves the key packet corresponding to the given timestamp, in seconds. More specifically, returns the last\n     * key packet (in presentation order) with a start timestamp less than or equal to the given timestamp. A key packet\n     * is a packet that doesn't require previous packets to be decoded. This method can be used to retrieve a track's\n     * last key packet using `getKeyPacket(Infinity)`. The method returns null if the timestamp is before the first\n     * key packet in the track.\n     *\n     * To ensure that the returned packet is guaranteed to be a real key frame, enable `options.verifyKeyPackets`.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getKeyPacket(timestamp, options = {}) {\n        validateTimestamp(timestamp);\n        validatePacketRetrievalOptions(options);\n        if (!options.verifyKeyPackets) {\n            return this._track._backing.getKeyPacket(timestamp, options);\n        }\n        const packet = await this._track._backing.getKeyPacket(timestamp, options);\n        if (!packet || packet.type === 'delta') {\n            return packet;\n        }\n        const determinedType = await this._track.determinePacketType(packet);\n        if (determinedType === 'delta') {\n            // Try returning the previous key packet (in hopes that it's actually a key packet)\n            return this.getKeyPacket(packet.timestamp - 1 / this._track.timeResolution, options);\n        }\n        return packet;\n    }\n    /**\n     * Retrieves the key packet following the given packet (in decode order), or null if the given packet is the last\n     * key packet.\n     *\n     * To ensure that the returned packet is guaranteed to be a real key frame, enable `options.verifyKeyPackets`.\n     */\n    async getNextKeyPacket(packet, options = {}) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        validatePacketRetrievalOptions(options);\n        if (!options.verifyKeyPackets) {\n            return this._track._backing.getNextKeyPacket(packet, options);\n        }\n        const nextPacket = await this._track._backing.getNextKeyPacket(packet, options);\n        if (!nextPacket || nextPacket.type === 'delta') {\n            return nextPacket;\n        }\n        const determinedType = await this._track.determinePacketType(nextPacket);\n        if (determinedType === 'delta') {\n            // Try returning the next key packet (in hopes that it's actually a key packet)\n            return this.getNextKeyPacket(nextPacket, options);\n        }\n        return nextPacket;\n    }\n    /**\n     * Creates an async iterator that yields the packets in this track in decode order. To enable fast iteration, this\n     * method will intelligently preload packets based on the speed of the consumer.\n     *\n     * @param startPacket - (optional) The packet from which iteration should begin. This packet will also be yielded.\n     * @param endTimestamp - (optional) The timestamp at which iteration should end. This packet will _not_ be yielded.\n     */\n    packets(startPacket, endPacket, options = {}) {\n        if (startPacket !== undefined && !(startPacket instanceof EncodedPacket)) {\n            throw new TypeError('startPacket must be an EncodedPacket.');\n        }\n        if (startPacket !== undefined && startPacket.isMetadataOnly && !options?.metadataOnly) {\n            throw new TypeError('startPacket can only be metadata-only if options.metadataOnly is enabled.');\n        }\n        if (endPacket !== undefined && !(endPacket instanceof EncodedPacket)) {\n            throw new TypeError('endPacket must be an EncodedPacket.');\n        }\n        validatePacketRetrievalOptions(options);\n        const packetQueue = [];\n        let { promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers();\n        let { promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers();\n        let ended = false;\n        let terminated = false;\n        // This stores errors that are \"out of band\" in the sense that they didn't occur in the normal flow of this\n        // method but instead in a different context. This error should not go unnoticed and must be bubbled up to\n        // the consumer.\n        let outOfBandError = null;\n        const timestamps = [];\n        // The queue should always be big enough to hold 1 second worth of packets\n        const maxQueueSize = () => Math.max(2, timestamps.length);\n        // The following is the \"pump\" process that keeps pumping packets into the queue\n        (async () => {\n            let packet = startPacket ?? await this.getFirstPacket(options);\n            while (packet && !terminated) {\n                if (endPacket && packet.sequenceNumber >= endPacket?.sequenceNumber) {\n                    break;\n                }\n                if (packetQueue.length > maxQueueSize()) {\n                    ({ promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers());\n                    await queueDequeue;\n                    continue;\n                }\n                packetQueue.push(packet);\n                onQueueNotEmpty();\n                ({ promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers());\n                packet = await this.getNextPacket(packet, options);\n            }\n            ended = true;\n            onQueueNotEmpty();\n        })().catch((error) => {\n            if (!outOfBandError) {\n                outOfBandError = error;\n                onQueueNotEmpty();\n            }\n        });\n        return {\n            async next() {\n                while (true) {\n                    if (terminated) {\n                        return { value: undefined, done: true };\n                    }\n                    else if (outOfBandError) {\n                        throw outOfBandError;\n                    }\n                    else if (packetQueue.length > 0) {\n                        const value = packetQueue.shift();\n                        const now = performance.now();\n                        timestamps.push(now);\n                        while (timestamps.length > 0 && now - timestamps[0] >= 1000) {\n                            timestamps.shift();\n                        }\n                        onQueueDequeue();\n                        return { value, done: false };\n                    }\n                    else if (ended) {\n                        return { value: undefined, done: true };\n                    }\n                    else {\n                        await queueNotEmpty;\n                    }\n                }\n            },\n            async return() {\n                terminated = true;\n                onQueueDequeue();\n                onQueueNotEmpty();\n                return { value: undefined, done: true };\n            },\n            async throw(error) {\n                throw error;\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n}\nclass DecoderWrapper {\n    constructor(onSample, onError) {\n        this.onSample = onSample;\n        this.onError = onError;\n    }\n}\n/**\n * Base class for decoded media sample sinks.\n * @public\n */\nexport class BaseMediaSampleSink {\n    /** @internal */\n    mediaSamplesInRange(startTimestamp = 0, endTimestamp = Infinity) {\n        validateTimestamp(startTimestamp);\n        validateTimestamp(endTimestamp);\n        const sampleQueue = [];\n        let firstSampleQueued = false;\n        let lastSample = null;\n        let { promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers();\n        let { promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers();\n        let decoderIsFlushed = false;\n        let ended = false;\n        let terminated = false;\n        // This stores errors that are \"out of band\" in the sense that they didn't occur in the normal flow of this\n        // method but instead in a different context. This error should not go unnoticed and must be bubbled up to\n        // the consumer.\n        let outOfBandError = null;\n        // The following is the \"pump\" process that keeps pumping packets into the decoder\n        (async () => {\n            const decoderError = new Error();\n            const decoder = await this._createDecoder((sample) => {\n                onQueueDequeue();\n                if (sample.timestamp >= endTimestamp) {\n                    ended = true;\n                }\n                if (ended) {\n                    sample.close();\n                    return;\n                }\n                if (lastSample) {\n                    if (sample.timestamp > startTimestamp) {\n                        // We don't know ahead of time what the first first is. This is because the first first is the\n                        // last first whose timestamp is less than or equal to the start timestamp. Therefore we need to\n                        // wait for the first first after the start timestamp, and then we'll know that the previous\n                        // first was the first first.\n                        sampleQueue.push(lastSample);\n                        firstSampleQueued = true;\n                    }\n                    else {\n                        lastSample.close();\n                    }\n                }\n                if (sample.timestamp >= startTimestamp) {\n                    sampleQueue.push(sample);\n                    firstSampleQueued = true;\n                }\n                lastSample = firstSampleQueued ? null : sample;\n                if (sampleQueue.length > 0) {\n                    onQueueNotEmpty();\n                    ({ promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers());\n                }\n            }, (error) => {\n                if (!outOfBandError) {\n                    error.stack = decoderError.stack; // Provide a more useful stack trace\n                    outOfBandError = error;\n                    onQueueNotEmpty();\n                }\n            });\n            const packetSink = this._createPacketSink();\n            const keyPacket = await packetSink.getKeyPacket(startTimestamp, { verifyKeyPackets: true })\n                ?? await packetSink.getFirstPacket();\n            if (!keyPacket) {\n                return;\n            }\n            let currentPacket = keyPacket;\n            let endPacket = undefined;\n            if (endTimestamp < Infinity) {\n                // When an end timestamp is set, we cannot simply use that for the packet iterator due to out-of-order\n                // frames (B-frames). Instead, we'll need to keep decoding packets until we get a frame that exceeds\n                // this end time. However, we can still put a bound on it: Since key frames are by definition never\n                // out of order, we can stop at the first key frame after the end timestamp.\n                const packet = await packetSink.getPacket(endTimestamp);\n                const keyPacket = !packet\n                    ? null\n                    : packet.type === 'key' && packet.timestamp === endTimestamp\n                        ? packet\n                        : await packetSink.getNextKeyPacket(packet, { verifyKeyPackets: true });\n                if (keyPacket) {\n                    endPacket = keyPacket;\n                }\n            }\n            const packets = packetSink.packets(keyPacket, endPacket);\n            await packets.next(); // Skip the start packet as we already have it\n            while (currentPacket && !ended) {\n                const maxQueueSize = computeMaxQueueSize(sampleQueue.length);\n                if (sampleQueue.length + decoder.getDecodeQueueSize() > maxQueueSize) {\n                    ({ promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers());\n                    await queueDequeue;\n                    continue;\n                }\n                decoder.decode(currentPacket);\n                const packetResult = await packets.next();\n                if (packetResult.done) {\n                    break;\n                }\n                currentPacket = packetResult.value;\n            }\n            await packets.return();\n            if (!terminated)\n                await decoder.flush();\n            decoder.close();\n            if (!firstSampleQueued && lastSample) {\n                sampleQueue.push(lastSample);\n            }\n            decoderIsFlushed = true;\n            onQueueNotEmpty(); // To unstuck the generator\n        })().catch((error) => {\n            if (!outOfBandError) {\n                outOfBandError = error;\n                onQueueNotEmpty();\n            }\n        });\n        return {\n            async next() {\n                while (true) {\n                    if (terminated) {\n                        return { value: undefined, done: true };\n                    }\n                    else if (outOfBandError) {\n                        throw outOfBandError;\n                    }\n                    else if (sampleQueue.length > 0) {\n                        const value = sampleQueue.shift();\n                        onQueueDequeue();\n                        return { value, done: false };\n                    }\n                    else if (!decoderIsFlushed) {\n                        await queueNotEmpty;\n                    }\n                    else {\n                        return { value: undefined, done: true };\n                    }\n                }\n            },\n            async return() {\n                terminated = true;\n                ended = true;\n                onQueueDequeue();\n                onQueueNotEmpty();\n                lastSample?.close();\n                for (const sample of sampleQueue) {\n                    sample.close();\n                }\n                return { value: undefined, done: true };\n            },\n            async throw(error) {\n                throw error;\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /** @internal */\n    mediaSamplesAtTimestamps(timestamps) {\n        validateAnyIterable(timestamps);\n        const timestampIterator = toAsyncIterator(timestamps);\n        const timestampsOfInterest = [];\n        const sampleQueue = [];\n        let { promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers();\n        let { promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers();\n        let decoderIsFlushed = false;\n        let terminated = false;\n        // This stores errors that are \"out of band\" in the sense that they didn't occur in the normal flow of this\n        // method but instead in a different context. This error should not go unnoticed and must be bubbled up to\n        // the consumer.\n        let outOfBandError = null;\n        const pushToQueue = (sample) => {\n            sampleQueue.push(sample);\n            onQueueNotEmpty();\n            ({ promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers());\n        };\n        // The following is the \"pump\" process that keeps pumping packets into the decoder\n        (async () => {\n            const decoderError = new Error();\n            const decoder = await this._createDecoder((sample) => {\n                onQueueDequeue();\n                if (terminated) {\n                    sample.close();\n                    return;\n                }\n                let sampleUses = 0;\n                while (timestampsOfInterest.length > 0\n                    && sample.timestamp - timestampsOfInterest[0] > -1e-10 // Give it a little epsilon\n                ) {\n                    sampleUses++;\n                    timestampsOfInterest.shift();\n                }\n                if (sampleUses > 0) {\n                    for (let i = 0; i < sampleUses; i++) {\n                        // Clone the sample if we need to emit it multiple times\n                        pushToQueue((i < sampleUses - 1 ? sample.clone() : sample));\n                    }\n                }\n                else {\n                    sample.close();\n                }\n            }, (error) => {\n                if (!outOfBandError) {\n                    error.stack = decoderError.stack; // Provide a more useful stack trace\n                    outOfBandError = error;\n                    onQueueNotEmpty();\n                }\n            });\n            const packetSink = this._createPacketSink();\n            let lastPacket = null;\n            let lastKeyPacket = null;\n            // The end sequence number (inclusive) in the next batch of packets that will be decoded. The batch starts\n            // at the last key frame and goes until this sequence number.\n            let maxSequenceNumber = -1;\n            const decodePackets = async () => {\n                assert(lastKeyPacket);\n                // Start at the current key packet\n                let currentPacket = lastKeyPacket;\n                decoder.decode(currentPacket);\n                while (currentPacket.sequenceNumber < maxSequenceNumber) {\n                    const maxQueueSize = computeMaxQueueSize(sampleQueue.length);\n                    while (sampleQueue.length + decoder.getDecodeQueueSize() > maxQueueSize && !terminated) {\n                        ({ promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers());\n                        await queueDequeue;\n                    }\n                    if (terminated) {\n                        break;\n                    }\n                    const nextPacket = await packetSink.getNextPacket(currentPacket);\n                    assert(nextPacket);\n                    currentPacket = nextPacket;\n                    decoder.decode(nextPacket);\n                }\n                maxSequenceNumber = -1;\n            };\n            const flushDecoder = async () => {\n                await decoder.flush();\n                // We don't expect this list to have any elements in it anymore, but in case it does, let's emit\n                // nulls for every remaining element, then clear it.\n                for (let i = 0; i < timestampsOfInterest.length; i++) {\n                    pushToQueue(null);\n                }\n                timestampsOfInterest.length = 0;\n            };\n            for await (const timestamp of timestampIterator) {\n                validateTimestamp(timestamp);\n                if (terminated) {\n                    break;\n                }\n                const targetPacket = await packetSink.getPacket(timestamp);\n                const keyPacket = targetPacket && await packetSink.getKeyPacket(timestamp, { verifyKeyPackets: true });\n                if (!keyPacket) {\n                    if (maxSequenceNumber !== -1) {\n                        await decodePackets();\n                        await flushDecoder();\n                    }\n                    pushToQueue(null);\n                    lastPacket = null;\n                    continue;\n                }\n                // Check if the key packet has changed or if we're going back in time\n                if (lastPacket\n                    && (keyPacket.sequenceNumber !== lastKeyPacket.sequenceNumber\n                        || targetPacket.timestamp < lastPacket.timestamp)) {\n                    await decodePackets();\n                    await flushDecoder(); // Always flush here, improves decoder compatibility\n                }\n                timestampsOfInterest.push(targetPacket.timestamp);\n                maxSequenceNumber = Math.max(targetPacket.sequenceNumber, maxSequenceNumber);\n                lastPacket = targetPacket;\n                lastKeyPacket = keyPacket;\n            }\n            if (!terminated) {\n                if (maxSequenceNumber !== -1) {\n                    // We still need to decode packets\n                    await decodePackets();\n                }\n                await flushDecoder();\n            }\n            decoder.close();\n            decoderIsFlushed = true;\n            onQueueNotEmpty(); // To unstuck the generator\n        })().catch((error) => {\n            if (!outOfBandError) {\n                outOfBandError = error;\n                onQueueNotEmpty();\n            }\n        });\n        return {\n            async next() {\n                while (true) {\n                    if (terminated) {\n                        return { value: undefined, done: true };\n                    }\n                    else if (outOfBandError) {\n                        throw outOfBandError;\n                    }\n                    else if (sampleQueue.length > 0) {\n                        const value = sampleQueue.shift();\n                        assert(value !== undefined);\n                        onQueueDequeue();\n                        return { value, done: false };\n                    }\n                    else if (!decoderIsFlushed) {\n                        await queueNotEmpty;\n                    }\n                    else {\n                        return { value: undefined, done: true };\n                    }\n                }\n            },\n            async return() {\n                terminated = true;\n                onQueueDequeue();\n                onQueueNotEmpty();\n                for (const sample of sampleQueue) {\n                    sample?.close();\n                }\n                return { value: undefined, done: true };\n            },\n            async throw(error) {\n                throw error;\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n}\nconst computeMaxQueueSize = (decodedSampleQueueSize) => {\n    // If we have decoded samples lying around, limit the total queue size to a small value (decoded samples can use up\n    // a lot of memory). If not, we're fine with a much bigger queue of encoded packets waiting to be decoded. In fact,\n    // some decoders only start flushing out decoded chunks when the packet queue is large enough.\n    return decodedSampleQueueSize === 0 ? 40 : 8;\n};\nclass VideoDecoderWrapper extends DecoderWrapper {\n    constructor(onSample, onError, codec, decoderConfig, rotation, timeResolution) {\n        super(onSample, onError);\n        this.rotation = rotation;\n        this.timeResolution = timeResolution;\n        this.decoder = null;\n        this.customDecoder = null;\n        this.customDecoderCallSerializer = new CallSerializer();\n        this.customDecoderQueueSize = 0;\n        this.inputTimestamps = []; // Timestamps input into the decoder, sorted.\n        this.sampleQueue = []; // Safari-specific thing, check usage.\n        const MatchingCustomDecoder = customVideoDecoders.find(x => x.supports(codec, decoderConfig));\n        if (MatchingCustomDecoder) {\n            // @ts-expect-error \"Can't create instance of abstract class 🤓\"\n            this.customDecoder = new MatchingCustomDecoder();\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.codec = codec;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.config = decoderConfig;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.onSample = (sample) => {\n                if (!(sample instanceof VideoSample)) {\n                    throw new TypeError('The argument passed to onSample must be a VideoSample.');\n                }\n                this.finalizeAndEmitSample(sample);\n            };\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.init());\n        }\n        else {\n            // Specific handler for the WebCodecs VideoDecoder to iron out browser differences\n            const sampleHandler = (sample) => {\n                if (isSafari()) {\n                    // For correct B-frame handling, we don't just hand over the frames directly but instead add them to\n                    // a queue, because we want to ensure frames are emitted in presentation order. We flush the queue\n                    // each time we receive a frame with a timestamp larger than the highest we've seen so far, as we\n                    // can sure that is not a B-frame. Typically, WebCodecs automatically guarantees that frames are\n                    // emitted in presentation order, but Safari doesn't always follow this rule.\n                    if (this.sampleQueue.length > 0 && (sample.timestamp >= last(this.sampleQueue).timestamp)) {\n                        for (const sample of this.sampleQueue) {\n                            this.finalizeAndEmitSample(sample);\n                        }\n                        this.sampleQueue.length = 0;\n                    }\n                    insertSorted(this.sampleQueue, sample, x => x.timestamp);\n                }\n                else {\n                    // Assign it the next earliest timestamp from the input. We do this because browsers, by spec, are\n                    // required to emit decoded frames in presentation order *while* retaining the timestamp of their\n                    // originating EncodedVideoChunk. For files with B-frames but no out-of-order timestamps (like a\n                    // missing ctts box, for example), this causes a mismatch. We therefore fix the timestamps and\n                    // ensure they are sorted by doing this.\n                    const timestamp = this.inputTimestamps.shift();\n                    // There's no way we'd have more decoded frames than encoded packets we passed in. Actually, the\n                    // correspondence should be 1:1.\n                    assert(timestamp !== undefined);\n                    sample.setTimestamp(timestamp);\n                    this.finalizeAndEmitSample(sample);\n                }\n            };\n            this.decoder = new VideoDecoder({\n                output: frame => sampleHandler(new VideoSample(frame)),\n                error: onError,\n            });\n            this.decoder.configure(decoderConfig);\n        }\n    }\n    finalizeAndEmitSample(sample) {\n        // Round the timestamps to the time resolution\n        sample.setTimestamp(Math.round(sample.timestamp * this.timeResolution) / this.timeResolution);\n        sample.setDuration(Math.round(sample.duration * this.timeResolution) / this.timeResolution);\n        sample.setRotation(this.rotation);\n        this.onSample(sample);\n    }\n    getDecodeQueueSize() {\n        if (this.customDecoder) {\n            return this.customDecoderQueueSize;\n        }\n        else {\n            assert(this.decoder);\n            return this.decoder.decodeQueueSize;\n        }\n    }\n    decode(packet) {\n        if (this.customDecoder) {\n            this.customDecoderQueueSize++;\n            void this.customDecoderCallSerializer\n                .call(() => this.customDecoder.decode(packet))\n                .then(() => this.customDecoderQueueSize--);\n        }\n        else {\n            assert(this.decoder);\n            if (!isSafari()) {\n                insertSorted(this.inputTimestamps, packet.timestamp, x => x);\n            }\n            this.decoder.decode(packet.toEncodedVideoChunk());\n        }\n    }\n    async flush() {\n        if (this.customDecoder) {\n            await this.customDecoderCallSerializer.call(() => this.customDecoder.flush());\n        }\n        else {\n            assert(this.decoder);\n            await this.decoder.flush();\n        }\n        if (isSafari()) {\n            for (const sample of this.sampleQueue) {\n                this.finalizeAndEmitSample(sample);\n            }\n            this.sampleQueue.length = 0;\n        }\n    }\n    close() {\n        if (this.customDecoder) {\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.close());\n        }\n        else {\n            assert(this.decoder);\n            this.decoder.close();\n        }\n        for (const sample of this.sampleQueue) {\n            sample.close();\n        }\n        this.sampleQueue.length = 0;\n    }\n}\n/**\n * A sink that retrieves decoded video samples (video frames) from a video track.\n * @public\n */\nexport class VideoSampleSink extends BaseMediaSampleSink {\n    constructor(videoTrack) {\n        if (!(videoTrack instanceof InputVideoTrack)) {\n            throw new TypeError('videoTrack must be an InputVideoTrack.');\n        }\n        super();\n        this._videoTrack = videoTrack;\n    }\n    /** @internal */\n    async _createDecoder(onSample, onError) {\n        if (!(await this._videoTrack.canDecode())) {\n            throw new Error('This video track cannot be decoded by this browser. Make sure to check decodability before using'\n                + ' a track.');\n        }\n        const codec = this._videoTrack.codec;\n        const rotation = this._videoTrack.rotation;\n        const decoderConfig = await this._videoTrack.getDecoderConfig();\n        const timeResolution = this._videoTrack.timeResolution;\n        assert(codec && decoderConfig);\n        return new VideoDecoderWrapper(onSample, onError, codec, decoderConfig, rotation, timeResolution);\n    }\n    /** @internal */\n    _createPacketSink() {\n        return new EncodedPacketSink(this._videoTrack);\n    }\n    /**\n     * Retrieves the video sample (frame) corresponding to the given timestamp, in seconds. More specifically, returns\n     * the last video sample (in presentation order) with a start timestamp less than or equal to the given timestamp.\n     * Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getSample(timestamp) {\n        validateTimestamp(timestamp);\n        for await (const sample of this.mediaSamplesAtTimestamps([timestamp])) {\n            return sample;\n        }\n        throw new Error('Internal error: Iterator returned nothing.');\n    }\n    /**\n     * Creates an async iterator that yields the video samples (frames) of this track in presentation order. This method\n     * will intelligently pre-decode a few frames ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding samples (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding samples (exclusive).\n     */\n    samples(startTimestamp = 0, endTimestamp = Infinity) {\n        return this.mediaSamplesInRange(startTimestamp, endTimestamp);\n    }\n    /**\n     * Creates an async iterator that yields a video sample (frame) for each timestamp in the argument. This method\n     * uses an optimized decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most\n     * once, and is therefore more efficient than manually getting the sample for every timestamp. The iterator may\n     * yield null if no frame is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    samplesAtTimestamps(timestamps) {\n        return this.mediaSamplesAtTimestamps(timestamps);\n    }\n}\n/**\n * A sink that renders video samples (frames) of the given video track to canvases. This is often more useful than\n * directly retrieving frames, as it comes with common preprocessing steps such as resizing or applying rotation\n * metadata.\n *\n * This sink will yield HTMLCanvasElements when in a DOM context, and OffscreenCanvases otherwise.\n * @public\n */\nexport class CanvasSink {\n    constructor(videoTrack, options = {}) {\n        /** @internal */\n        this._nextCanvasIndex = 0;\n        if (!(videoTrack instanceof InputVideoTrack)) {\n            throw new TypeError('videoTrack must be an InputVideoTrack.');\n        }\n        if (options && typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.width !== undefined && (!Number.isInteger(options.width) || options.width <= 0)) {\n            throw new TypeError('options.width, when defined, must be a positive integer.');\n        }\n        if (options.height !== undefined && (!Number.isInteger(options.height) || options.height <= 0)) {\n            throw new TypeError('options.height, when defined, must be a positive integer.');\n        }\n        if (options.fit !== undefined && !['fill', 'contain', 'cover'].includes(options.fit)) {\n            throw new TypeError('options.fit, when provided, must be one of \"fill\", \"contain\", or \"cover\".');\n        }\n        if (options.width !== undefined\n            && options.height !== undefined\n            && options.fit === undefined) {\n            throw new TypeError('When both options.width and options.height are provided, options.fit must also be provided.');\n        }\n        if (options.rotation !== undefined && ![0, 90, 180, 270].includes(options.rotation)) {\n            throw new TypeError('options.rotation, when provided, must be 0, 90, 180 or 270.');\n        }\n        if (options.poolSize !== undefined\n            && (typeof options.poolSize !== 'number' || !Number.isInteger(options.poolSize) || options.poolSize < 0)) {\n            throw new TypeError('poolSize must be a non-negative integer.');\n        }\n        const rotation = options.rotation ?? videoTrack.rotation;\n        let [width, height] = rotation % 180 === 0\n            ? [videoTrack.codedWidth, videoTrack.codedHeight]\n            : [videoTrack.codedHeight, videoTrack.codedWidth];\n        const originalAspectRatio = width / height;\n        // If width and height aren't defined together, deduce the missing value using the aspect ratio\n        if (options.width !== undefined && options.height === undefined) {\n            width = options.width;\n            height = Math.round(width / originalAspectRatio);\n        }\n        else if (options.width === undefined && options.height !== undefined) {\n            height = options.height;\n            width = Math.round(height * originalAspectRatio);\n        }\n        else if (options.width !== undefined && options.height !== undefined) {\n            width = options.width;\n            height = options.height;\n        }\n        this._videoTrack = videoTrack;\n        this._width = width;\n        this._height = height;\n        this._rotation = rotation;\n        this._fit = options.fit ?? 'fill';\n        this._videoSampleSink = new VideoSampleSink(videoTrack);\n        this._canvasPool = Array.from({ length: options.poolSize ?? 0 }, () => null);\n    }\n    /** @internal */\n    _videoSampleToWrappedCanvas(sample) {\n        let canvas = this._canvasPool[this._nextCanvasIndex];\n        if (!canvas) {\n            if (typeof document !== 'undefined') {\n                // Prefer an HTMLCanvasElement\n                canvas = document.createElement('canvas');\n                canvas.width = this._width;\n                canvas.height = this._height;\n            }\n            else {\n                canvas = new OffscreenCanvas(this._width, this._height);\n            }\n            if (this._canvasPool.length > 0) {\n                this._canvasPool[this._nextCanvasIndex] = canvas;\n            }\n        }\n        if (this._canvasPool.length > 0) {\n            this._nextCanvasIndex = (this._nextCanvasIndex + 1) % this._canvasPool.length;\n        }\n        const context = canvas.getContext('2d', { alpha: false });\n        assert(context);\n        context.resetTransform();\n        // These variables specify where the final sample will be drawn on the canvas\n        let dx;\n        let dy;\n        let newWidth;\n        let newHeight;\n        if (this._fit === 'fill') {\n            dx = 0;\n            dy = 0;\n            newWidth = this._width;\n            newHeight = this._height;\n        }\n        else {\n            const [sampleWidth, sampleHeight] = this._rotation % 180 === 0\n                ? [sample.codedWidth, sample.codedHeight]\n                : [sample.codedHeight, sample.codedWidth];\n            const scale = this._fit === 'contain'\n                ? Math.min(this._width / sampleWidth, this._height / sampleHeight)\n                : Math.max(this._width / sampleWidth, this._height / sampleHeight);\n            newWidth = sampleWidth * scale;\n            newHeight = sampleHeight * scale;\n            dx = (this._width - newWidth) / 2;\n            dy = (this._height - newHeight) / 2;\n        }\n        const aspectRatioChange = this._rotation % 180 === 0 ? 1 : newWidth / newHeight;\n        context.translate(this._width / 2, this._height / 2);\n        context.rotate(this._rotation * Math.PI / 180);\n        // This aspect ratio compensation is done so that we can draw the sample with the intended dimensions and\n        // don't need to think about how those dimensions change after the rotation\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.translate(-this._width / 2, -this._height / 2);\n        context.drawImage(sample.toCanvasImageSource(), dx, dy, newWidth, newHeight);\n        const result = {\n            canvas,\n            timestamp: sample.timestamp,\n            duration: sample.duration,\n        };\n        sample.close();\n        return result;\n    }\n    /**\n     * Retrieves a canvas with the video frame corresponding to the given timestamp, in seconds. More specifically,\n     * returns the last video frame (in presentation order) with a start timestamp less than or equal to the given\n     * timestamp. Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getCanvas(timestamp) {\n        validateTimestamp(timestamp);\n        const sample = await this._videoSampleSink.getSample(timestamp);\n        return sample && this._videoSampleToWrappedCanvas(sample);\n    }\n    /**\n     * Creates an async iterator that yields canvases with the video frames of this track in presentation order. This\n     * method will intelligently pre-decode a few frames ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding canvases (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding canvases (exclusive).\n     */\n    canvases(startTimestamp = 0, endTimestamp = Infinity) {\n        return mapAsyncGenerator(this._videoSampleSink.samples(startTimestamp, endTimestamp), sample => this._videoSampleToWrappedCanvas(sample));\n    }\n    /**\n     * Creates an async iterator that yields a canvas for each timestamp in the argument. This method uses an optimized\n     * decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most once, and is\n     * therefore more efficient than manually getting the canvas for every timestamp. The iterator may yield null if\n     * no frame is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    canvasesAtTimestamps(timestamps) {\n        return mapAsyncGenerator(this._videoSampleSink.samplesAtTimestamps(timestamps), sample => sample && this._videoSampleToWrappedCanvas(sample));\n    }\n}\nclass AudioDecoderWrapper extends DecoderWrapper {\n    constructor(onSample, onError, codec, decoderConfig) {\n        super(onSample, onError);\n        this.decoder = null;\n        this.customDecoder = null;\n        this.customDecoderCallSerializer = new CallSerializer();\n        this.customDecoderQueueSize = 0;\n        const sampleHandler = (sample) => {\n            if (sample.numberOfFrames === 0) {\n                // We skip zero-data (empty) AudioSamples. These are sometimes emitted, for example, by Firefox when it\n                // decodes Vorbis (at the start).\n                sample.close();\n                return;\n            }\n            // Round the timestamp to the sample rate\n            const sampleRate = decoderConfig.sampleRate;\n            sample.setTimestamp(Math.round(sample.timestamp * sampleRate) / sampleRate);\n            onSample(sample);\n        };\n        const MatchingCustomDecoder = customAudioDecoders.find(x => x.supports(codec, decoderConfig));\n        if (MatchingCustomDecoder) {\n            // @ts-expect-error \"Can't create instance of abstract class 🤓\"\n            this.customDecoder = new MatchingCustomDecoder();\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.codec = codec;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.config = decoderConfig;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.onSample = (sample) => {\n                if (!(sample instanceof AudioSample)) {\n                    throw new TypeError('The argument passed to onSample must be an AudioSample.');\n                }\n                sampleHandler(sample);\n            };\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.init());\n        }\n        else {\n            this.decoder = new AudioDecoder({\n                output: data => sampleHandler(new AudioSample(data)),\n                error: onError,\n            });\n            this.decoder.configure(decoderConfig);\n        }\n    }\n    getDecodeQueueSize() {\n        if (this.customDecoder) {\n            return this.customDecoderQueueSize;\n        }\n        else {\n            assert(this.decoder);\n            return this.decoder.decodeQueueSize;\n        }\n    }\n    decode(packet) {\n        if (this.customDecoder) {\n            this.customDecoderQueueSize++;\n            void this.customDecoderCallSerializer\n                .call(() => this.customDecoder.decode(packet))\n                .then(() => this.customDecoderQueueSize--);\n        }\n        else {\n            assert(this.decoder);\n            this.decoder.decode(packet.toEncodedAudioChunk());\n        }\n    }\n    flush() {\n        if (this.customDecoder) {\n            return this.customDecoderCallSerializer.call(() => this.customDecoder.flush());\n        }\n        else {\n            assert(this.decoder);\n            return this.decoder.flush();\n        }\n    }\n    close() {\n        if (this.customDecoder) {\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.close());\n        }\n        else {\n            assert(this.decoder);\n            this.decoder.close();\n        }\n    }\n}\n// There are a lot of PCM variants not natively supported by the browser and by AudioData. Therefore we need a simple\n// decoder that maps any input PCM format into a PCM format supported by the browser.\nclass PcmAudioDecoderWrapper extends DecoderWrapper {\n    constructor(onSample, onError, decoderConfig) {\n        super(onSample, onError);\n        this.decoderConfig = decoderConfig;\n        // Internal state to accumulate a precise current timestamp based on audio durations, not the (potentially\n        // inaccurate) sample timestamps.\n        this.currentTimestamp = null;\n        assert(PCM_AUDIO_CODECS.includes(decoderConfig.codec));\n        this.codec = decoderConfig.codec;\n        const { dataType, sampleSize, littleEndian } = parsePcmCodec(this.codec);\n        this.inputSampleSize = sampleSize;\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => view.getUint8(byteOffset) - 2 ** 7;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => view.getInt8(byteOffset);\n                    }\n                    else if (dataType === 'ulaw') {\n                        this.readInputValue = (view, byteOffset) => fromUlaw(view.getUint8(byteOffset));\n                    }\n                    else if (dataType === 'alaw') {\n                        this.readInputValue = (view, byteOffset) => fromAlaw(view.getUint8(byteOffset));\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => view.getUint16(byteOffset, littleEndian) - 2 ** 15;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => view.getInt16(byteOffset, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 3:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => getUint24(view, byteOffset, littleEndian) - 2 ** 23;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => getInt24(view, byteOffset, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 4:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => view.getUint32(byteOffset, littleEndian) - 2 ** 31;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => view.getInt32(byteOffset, littleEndian);\n                    }\n                    else if (dataType === 'float') {\n                        this.readInputValue = (view, byteOffset) => view.getFloat32(byteOffset, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    if (dataType === 'float') {\n                        this.readInputValue = (view, byteOffset) => view.getFloat64(byteOffset, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            default:\n                {\n                    assertNever(sampleSize);\n                    assert(false);\n                }\n                ;\n        }\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'ulaw' || dataType === 'alaw') {\n                        this.outputSampleSize = 2;\n                        this.outputFormat = 's16';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, value, true);\n                    }\n                    else {\n                        this.outputSampleSize = 1;\n                        this.outputFormat = 'u8';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint8(byteOffset, value + 2 ** 7);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    this.outputSampleSize = 2;\n                    this.outputFormat = 's16';\n                    this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, value, true);\n                }\n                ;\n                break;\n            case 3:\n                {\n                    this.outputSampleSize = 4;\n                    this.outputFormat = 's32';\n                    // From https://www.w3.org/TR/webcodecs:\n                    // AudioData containing 24-bit samples SHOULD store those samples in s32 or f32. When samples are\n                    // stored in s32, each sample MUST be left-shifted by 8 bits.\n                    this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, value << 8, true);\n                }\n                ;\n                break;\n            case 4:\n                {\n                    this.outputSampleSize = 4;\n                    if (dataType === 'float') {\n                        this.outputFormat = 'f32';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, true);\n                    }\n                    else {\n                        this.outputFormat = 's32';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, value, true);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    this.outputSampleSize = 4;\n                    this.outputFormat = 'f32';\n                    this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, true);\n                }\n                ;\n                break;\n            default:\n                {\n                    assertNever(sampleSize);\n                    assert(false);\n                }\n                ;\n        }\n        ;\n    }\n    getDecodeQueueSize() {\n        return 0;\n    }\n    decode(packet) {\n        const inputView = toDataView(packet.data);\n        const numberOfFrames = packet.byteLength / this.decoderConfig.numberOfChannels / this.inputSampleSize;\n        const outputBufferSize = numberOfFrames * this.decoderConfig.numberOfChannels * this.outputSampleSize;\n        const outputBuffer = new ArrayBuffer(outputBufferSize);\n        const outputView = new DataView(outputBuffer);\n        for (let i = 0; i < numberOfFrames * this.decoderConfig.numberOfChannels; i++) {\n            const inputIndex = i * this.inputSampleSize;\n            const outputIndex = i * this.outputSampleSize;\n            const value = this.readInputValue(inputView, inputIndex);\n            this.writeOutputValue(outputView, outputIndex, value);\n        }\n        const preciseDuration = numberOfFrames / this.decoderConfig.sampleRate;\n        if (this.currentTimestamp === null || Math.abs(packet.timestamp - this.currentTimestamp) >= preciseDuration) {\n            // We need to sync with the packet timestamp again\n            this.currentTimestamp = packet.timestamp;\n        }\n        const preciseTimestamp = this.currentTimestamp;\n        this.currentTimestamp += preciseDuration;\n        const audioSample = new AudioSample({\n            format: this.outputFormat,\n            data: outputBuffer,\n            numberOfChannels: this.decoderConfig.numberOfChannels,\n            sampleRate: this.decoderConfig.sampleRate,\n            numberOfFrames,\n            timestamp: preciseTimestamp,\n        });\n        this.onSample(audioSample);\n    }\n    async flush() {\n        // Do nothing\n    }\n    close() {\n        // Do nothing\n    }\n}\n/**\n * Sink for retrieving decoded audio samples from an audio track.\n * @public\n */\nexport class AudioSampleSink extends BaseMediaSampleSink {\n    constructor(audioTrack) {\n        if (!(audioTrack instanceof InputAudioTrack)) {\n            throw new TypeError('audioTrack must be an InputAudioTrack.');\n        }\n        super();\n        this._audioTrack = audioTrack;\n    }\n    /** @internal */\n    async _createDecoder(onSample, onError) {\n        if (!(await this._audioTrack.canDecode())) {\n            throw new Error('This audio track cannot be decoded by this browser. Make sure to check decodability before using'\n                + ' a track.');\n        }\n        const codec = this._audioTrack.codec;\n        const decoderConfig = await this._audioTrack.getDecoderConfig();\n        assert(codec && decoderConfig);\n        if (PCM_AUDIO_CODECS.includes(decoderConfig.codec)) {\n            return new PcmAudioDecoderWrapper(onSample, onError, decoderConfig);\n        }\n        else {\n            return new AudioDecoderWrapper(onSample, onError, codec, decoderConfig);\n        }\n    }\n    /** @internal */\n    _createPacketSink() {\n        return new EncodedPacketSink(this._audioTrack);\n    }\n    /**\n     * Retrieves the audio sample corresponding to the given timestamp, in seconds. More specifically, returns\n     * the last audio sample (in presentation order) with a start timestamp less than or equal to the given timestamp.\n     * Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getSample(timestamp) {\n        validateTimestamp(timestamp);\n        for await (const sample of this.mediaSamplesAtTimestamps([timestamp])) {\n            return sample;\n        }\n        throw new Error('Internal error: Iterator returned nothing.');\n    }\n    /**\n     * Creates an async iterator that yields the audio samples of this track in presentation order. This method\n     * will intelligently pre-decode a few samples ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding samples (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding samples (exclusive).\n     */\n    samples(startTimestamp = 0, endTimestamp = Infinity) {\n        return this.mediaSamplesInRange(startTimestamp, endTimestamp);\n    }\n    /**\n     * Creates an async iterator that yields an audio sample for each timestamp in the argument. This method\n     * uses an optimized decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most\n     * once, and is therefore more efficient than manually getting the sample for every timestamp. The iterator may\n     * yield null if no sample is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    samplesAtTimestamps(timestamps) {\n        return this.mediaSamplesAtTimestamps(timestamps);\n    }\n}\n/**\n * A sink that retrieves decoded audio samples from an audio track and converts them to AudioBuffers. This is often\n * more useful than directly retrieving audio samples, as AudioBuffers can be directly used with the Web Audio API.\n * @public\n */\nexport class AudioBufferSink {\n    constructor(audioTrack) {\n        if (!(audioTrack instanceof InputAudioTrack)) {\n            throw new TypeError('audioTrack must be an InputAudioTrack.');\n        }\n        this._audioSampleSink = new AudioSampleSink(audioTrack);\n    }\n    /** @internal */\n    _audioSampleToWrappedArrayBuffer(sample) {\n        return {\n            buffer: sample.toAudioBuffer(),\n            timestamp: sample.timestamp,\n            duration: sample.duration,\n        };\n    }\n    /**\n     * Retrieves the audio buffer corresponding to the given timestamp, in seconds. More specifically, returns\n     * the last audio buffer (in presentation order) with a start timestamp less than or equal to the given timestamp.\n     * Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getBuffer(timestamp) {\n        validateTimestamp(timestamp);\n        const data = await this._audioSampleSink.getSample(timestamp);\n        return data && this._audioSampleToWrappedArrayBuffer(data);\n    }\n    /**\n     * Creates an async iterator that yields audio buffers of this track in presentation order. This method\n     * will intelligently pre-decode a few buffers ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding buffers (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding buffers (exclusive).\n     */\n    buffers(startTimestamp = 0, endTimestamp = Infinity) {\n        return mapAsyncGenerator(this._audioSampleSink.samples(startTimestamp, endTimestamp), data => this._audioSampleToWrappedArrayBuffer(data));\n    }\n    /**\n     * Creates an async iterator that yields an audio buffer for each timestamp in the argument. This method\n     * uses an optimized decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most\n     * once, and is therefore more efficient than manually getting the buffer for every timestamp. The iterator may\n     * yield null if no buffer is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    buffersAtTimestamps(timestamps) {\n        return mapAsyncGenerator(this._audioSampleSink.samplesAtTimestamps(timestamps), data => data && this._audioSampleToWrappedArrayBuffer(data));\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5678, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/input-track.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { determineVideoPacketType } from './codec-data.js';\nimport { customAudioDecoders, customVideoDecoders } from './custom-coder.js';\nimport { EncodedPacketSink } from './media-sink.js';\nimport { assert } from './misc.js';\nimport { EncodedPacket } from './packet.js';\n/**\n * Represents a media track in an input file.\n * @public\n */\nexport class InputTrack {\n    /** @internal */\n    constructor(backing) {\n        this._backing = backing;\n    }\n    /** Returns true iff this track is a video track. */\n    isVideoTrack() {\n        return this instanceof InputVideoTrack;\n    }\n    /** Returns true iff this track is an audio track. */\n    isAudioTrack() {\n        return this instanceof InputAudioTrack;\n    }\n    /** The unique ID of this track in the input file. */\n    get id() {\n        return this._backing.getId();\n    }\n    /** The ISO 639-2/T language code for this track. If the language is unknown, this field is 'und' (undetermined). */\n    get languageCode() {\n        return this._backing.getLanguageCode();\n    }\n    /**\n     * A positive number x such that all timestamps and durations of all packets of this track are\n     * integer multiples of 1/x.\n     */\n    get timeResolution() {\n        return this._backing.getTimeResolution();\n    }\n    /**\n     * Returns the start timestamp of the first packet of this track, in seconds. While often near zero, this value\n     * may be positive or even negative. A negative starting timestamp means the track's timing has been offset. Samples\n     * with a negative timestamp should not be presented.\n     */\n    getFirstTimestamp() {\n        return this._backing.getFirstTimestamp();\n    }\n    /** Returns the end timestamp of the last packet of this track, in seconds. */\n    computeDuration() {\n        return this._backing.computeDuration();\n    }\n    /**\n     * Computes aggregate packet statistics for this track, such as average packet rate or bitrate.\n     *\n     * @param targetPacketCount - This optional parameter sets a target for how many packets this method must have\n     * looked at before it can return early; this means, you can use it to aggregate only a subset (prefix) of all\n     * packets. This is very useful for getting a great estimate of video frame rate without having to scan through the\n     * entire file.\n     */\n    async computePacketStats(targetPacketCount = Infinity) {\n        const sink = new EncodedPacketSink(this);\n        let startTimestamp = Infinity;\n        let endTimestamp = -Infinity;\n        let packetCount = 0;\n        let totalPacketBytes = 0;\n        for await (const packet of sink.packets(undefined, undefined, { metadataOnly: true })) {\n            if (packetCount >= targetPacketCount\n                // This additional condition is needed to produce correct results with out-of-presentation-order packets\n                && packet.timestamp >= endTimestamp) {\n                break;\n            }\n            startTimestamp = Math.min(startTimestamp, packet.timestamp);\n            endTimestamp = Math.max(endTimestamp, packet.timestamp + packet.duration);\n            packetCount++;\n            totalPacketBytes += packet.byteLength;\n        }\n        return {\n            packetCount,\n            averagePacketRate: packetCount\n                ? Number((packetCount / (endTimestamp - startTimestamp)).toPrecision(16))\n                : 0,\n            averageBitrate: packetCount\n                ? Number((8 * totalPacketBytes / (endTimestamp - startTimestamp)).toPrecision(16))\n                : 0,\n        };\n    }\n}\n/**\n * Represents a video track in an input file.\n * @public\n */\nexport class InputVideoTrack extends InputTrack {\n    /** @internal */\n    constructor(backing) {\n        super(backing);\n        this._backing = backing;\n    }\n    get type() {\n        return 'video';\n    }\n    get codec() {\n        return this._backing.getCodec();\n    }\n    /** The width in pixels of the track's coded samples, before any transformations or rotations. */\n    get codedWidth() {\n        return this._backing.getCodedWidth();\n    }\n    /** The height in pixels of the track's coded samples, before any transformations or rotations. */\n    get codedHeight() {\n        return this._backing.getCodedHeight();\n    }\n    /** The angle in degrees by which the track's frames should be rotated (clockwise). */\n    get rotation() {\n        return this._backing.getRotation();\n    }\n    /** The width in pixels of the track's frames after rotation. */\n    get displayWidth() {\n        const rotation = this._backing.getRotation();\n        return rotation % 180 === 0 ? this._backing.getCodedWidth() : this._backing.getCodedHeight();\n    }\n    /** The height in pixels of the track's frames after rotation. */\n    get displayHeight() {\n        const rotation = this._backing.getRotation();\n        return rotation % 180 === 0 ? this._backing.getCodedHeight() : this._backing.getCodedWidth();\n    }\n    /** Returns the color space of the track's samples. */\n    getColorSpace() {\n        return this._backing.getColorSpace();\n    }\n    /** If this method returns true, the track's samples use a high dynamic range (HDR). */\n    async hasHighDynamicRange() {\n        const colorSpace = await this._backing.getColorSpace();\n        return colorSpace.primaries === 'bt2020' || colorSpace.primaries === 'smpte432'\n            || colorSpace.transfer === 'pg' || colorSpace.transfer === 'hlg'\n            || colorSpace.matrix === 'bt2020-ncl';\n    }\n    /**\n     * Returns the decoder configuration for decoding the track's packets using a VideoDecoder. Returns null if the\n     * track's codec is unknown.\n     */\n    getDecoderConfig() {\n        return this._backing.getDecoderConfig();\n    }\n    async getCodecParameterString() {\n        const decoderConfig = await this._backing.getDecoderConfig();\n        return decoderConfig?.codec ?? null;\n    }\n    async canDecode() {\n        try {\n            const decoderConfig = await this._backing.getDecoderConfig();\n            if (!decoderConfig) {\n                return false;\n            }\n            const codec = this._backing.getCodec();\n            assert(codec !== null);\n            if (customVideoDecoders.some(x => x.supports(codec, decoderConfig))) {\n                return true;\n            }\n            if (typeof VideoDecoder === 'undefined') {\n                return false;\n            }\n            const support = await VideoDecoder.isConfigSupported(decoderConfig);\n            return support.supported === true;\n        }\n        catch (error) {\n            console.error('Error during decodability check:', error);\n            return false;\n        }\n    }\n    async determinePacketType(packet) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('packet must not be metadata-only to determine its type.');\n        }\n        if (this.codec === null) {\n            return null;\n        }\n        return determineVideoPacketType(this, packet);\n    }\n}\n/**\n * Represents an audio track in an input file.\n * @public\n */\nexport class InputAudioTrack extends InputTrack {\n    /** @internal */\n    constructor(backing) {\n        super(backing);\n        this._backing = backing;\n    }\n    get type() {\n        return 'audio';\n    }\n    get codec() {\n        return this._backing.getCodec();\n    }\n    /** The number of audio channels in the track. */\n    get numberOfChannels() {\n        return this._backing.getNumberOfChannels();\n    }\n    /** The track's audio sample rate in hertz. */\n    get sampleRate() {\n        return this._backing.getSampleRate();\n    }\n    /**\n     * Returns the decoder configuration for decoding the track's packets using an AudioDecoder. Returns null if the\n     * track's codec is unknown.\n     */\n    getDecoderConfig() {\n        return this._backing.getDecoderConfig();\n    }\n    async getCodecParameterString() {\n        const decoderConfig = await this._backing.getDecoderConfig();\n        return decoderConfig?.codec ?? null;\n    }\n    async canDecode() {\n        try {\n            const decoderConfig = await this._backing.getDecoderConfig();\n            if (!decoderConfig) {\n                return false;\n            }\n            const codec = this._backing.getCodec();\n            assert(codec !== null);\n            if (customAudioDecoders.some(x => x.supports(codec, decoderConfig))) {\n                return true;\n            }\n            if (decoderConfig.codec.startsWith('pcm-')) {\n                return true; // Since we decode it ourselves\n            }\n            else {\n                if (typeof AudioDecoder === 'undefined') {\n                    return false;\n                }\n                const support = await AudioDecoder.isConfigSupported(decoderConfig);\n                return support.supported === true;\n            }\n        }\n        catch (error) {\n            console.error('Error during decodability check:', error);\n            return false;\n        }\n    }\n    async determinePacketType(packet) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (this.codec === null) {\n            return null;\n        }\n        return 'key'; // No audio codec with delta packets\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5907, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/reader.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert, binarySearchLessOrEqual, removeItem } from './misc.js';\nexport class Reader {\n    constructor(source, maxStorableBytes = Infinity) {\n        this.source = source;\n        this.maxStorableBytes = maxStorableBytes;\n        this.loadedSegments = [];\n        this.loadingSegments = [];\n        this.sourceSizePromise = null;\n        this.nextAge = 0;\n        this.totalStoredBytes = 0;\n    }\n    async loadRange(start, end) {\n        end = Math.min(end, await this.source.getSize());\n        if (start >= end) {\n            return;\n        }\n        const matchingLoadingSegment = this.loadingSegments.find(x => x.start <= start && x.end >= end);\n        if (matchingLoadingSegment) {\n            // Simply wait for the existing promise to finish to avoid loading the same range twice\n            await matchingLoadingSegment.promise;\n            return;\n        }\n        const index = binarySearchLessOrEqual(this.loadedSegments, start, x => x.start);\n        if (index !== -1) {\n            for (let i = index; i < this.loadedSegments.length; i++) {\n                const segment = this.loadedSegments[i];\n                if (segment.start > start) {\n                    break;\n                }\n                const segmentEncasesRequestedRange = segment.end >= end;\n                if (segmentEncasesRequestedRange) {\n                    // Nothing to load\n                    return;\n                }\n            }\n        }\n        this.source.onread?.(start, end);\n        const bytesPromise = this.source._read(start, end);\n        const loadingSegment = { start, end, promise: bytesPromise };\n        this.loadingSegments.push(loadingSegment);\n        const bytes = await bytesPromise;\n        removeItem(this.loadingSegments, loadingSegment);\n        this.insertIntoLoadedSegments(start, bytes);\n    }\n    rangeIsLoaded(start, end) {\n        if (end <= start) {\n            return true;\n        }\n        const index = binarySearchLessOrEqual(this.loadedSegments, start, x => x.start);\n        if (index === -1) {\n            return false;\n        }\n        for (let i = index; i < this.loadedSegments.length; i++) {\n            const segment = this.loadedSegments[i];\n            if (segment.start > start) {\n                break;\n            }\n            const segmentEncasesRequestedRange = segment.end >= end;\n            if (segmentEncasesRequestedRange) {\n                return true;\n            }\n        }\n        return false;\n    }\n    insertIntoLoadedSegments(start, bytes) {\n        const segment = {\n            start,\n            end: start + bytes.byteLength,\n            bytes,\n            view: new DataView(bytes.buffer),\n            age: this.nextAge++,\n        };\n        let index = binarySearchLessOrEqual(this.loadedSegments, start, x => x.start);\n        if (index === -1 || this.loadedSegments[index].start < segment.start) {\n            index++;\n        }\n        // Insert the segment at the right place so that the array remains sorted by start offset\n        this.loadedSegments.splice(index, 0, segment);\n        this.totalStoredBytes += bytes.byteLength;\n        // Remove all other segments from the array that are completely covered by the newly-inserted segment\n        for (let i = index + 1; i < this.loadedSegments.length; i++) {\n            const otherSegment = this.loadedSegments[i];\n            if (otherSegment.start >= segment.end) {\n                break;\n            }\n            if (segment.start <= otherSegment.start && otherSegment.end <= segment.end) {\n                this.loadedSegments.splice(i, 1);\n                i--;\n            }\n        }\n        // If we overshoot the max amount of permitted bytes, let's start evicting the oldest segments\n        while (this.totalStoredBytes > this.maxStorableBytes && this.loadedSegments.length > 1) {\n            let oldestSegment = null;\n            let oldestSegmentIndex = -1;\n            for (let i = 0; i < this.loadedSegments.length; i++) {\n                const candidate = this.loadedSegments[i];\n                if (!oldestSegment || candidate.age < oldestSegment.age) {\n                    oldestSegment = candidate;\n                    oldestSegmentIndex = i;\n                }\n            }\n            assert(oldestSegment);\n            this.totalStoredBytes -= oldestSegment.bytes.byteLength;\n            this.loadedSegments.splice(oldestSegmentIndex, 1);\n        }\n    }\n    getViewAndOffset(start, end) {\n        const startIndex = binarySearchLessOrEqual(this.loadedSegments, start, x => x.start);\n        let segment = null;\n        if (startIndex !== -1) {\n            for (let i = startIndex; i < this.loadedSegments.length; i++) {\n                const candidate = this.loadedSegments[i];\n                if (candidate.start > start) {\n                    break;\n                }\n                if (end <= candidate.end) {\n                    segment = candidate;\n                    break;\n                }\n            }\n        }\n        if (!segment) {\n            throw new Error(`No segment loaded for range [${start}, ${end}).`);\n        }\n        segment.age = this.nextAge++;\n        return {\n            view: segment.view,\n            offset: segment.bytes.byteOffset + start - segment.start,\n        };\n    }\n    forgetRange(start, end) {\n        if (end <= start) {\n            return;\n        }\n        const startIndex = binarySearchLessOrEqual(this.loadedSegments, start, x => x.start);\n        if (startIndex === -1) {\n            return;\n        }\n        const segment = this.loadedSegments[startIndex];\n        if (segment.start !== start || segment.end !== end) {\n            return;\n        }\n        this.loadedSegments.splice(startIndex, 1);\n        this.totalStoredBytes -= segment.bytes.byteLength;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6071, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-misc.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const buildIsobmffMimeType = (info) => {\n    const base = info.hasVideo\n        ? 'video/'\n        : info.hasAudio\n            ? 'audio/'\n            : 'application/';\n    let string = base + (info.isQuickTime ? 'quicktime' : 'mp4');\n    if (info.codecStrings.length > 0) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings)];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AACM,MAAM,uBAAuB,CAAC;IACjC,MAAM,OAAO,KAAK,QAAQ,GACpB,WACA,KAAK,QAAQ,GACT,WACA;IACV,IAAI,SAAS,OAAO,CAAC,KAAK,WAAW,GAAG,cAAc,KAAK;IAC3D,IAAI,KAAK,YAAY,CAAC,MAAM,GAAG,GAAG;QAC9B,MAAM,uBAAuB;eAAI,IAAI,IAAI,KAAK,YAAY;SAAE;QAC5D,UAAU,CAAC,UAAU,EAAE,qBAAqB,IAAI,CAAC,MAAM,CAAC,CAAC;IAC7D;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6095, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-reader.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const MIN_BOX_HEADER_SIZE = 8;\nexport const MAX_BOX_HEADER_SIZE = 16;\nexport class IsobmffReader {\n    constructor(reader) {\n        this.reader = reader;\n        this.pos = 0;\n    }\n    readBytes(length) {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + length);\n        this.pos += length;\n        return new Uint8Array(view.buffer, offset, length);\n    }\n    readU8() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 1);\n        this.pos++;\n        return view.getUint8(offset);\n    }\n    readU16() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 2);\n        this.pos += 2;\n        return view.getUint16(offset, false);\n    }\n    readI16() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 2);\n        this.pos += 2;\n        return view.getInt16(offset, false);\n    }\n    readU24() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 3);\n        this.pos += 3;\n        const high = view.getUint16(offset, false);\n        const low = view.getUint8(offset + 2);\n        return high * 0x100 + low;\n    }\n    readU32() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 4);\n        this.pos += 4;\n        return view.getUint32(offset, false);\n    }\n    readI32() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 4);\n        this.pos += 4;\n        return view.getInt32(offset, false);\n    }\n    readU64() {\n        const high = this.readU32();\n        const low = this.readU32();\n        return high * 0x100000000 + low;\n    }\n    readI64() {\n        const high = this.readI32();\n        const low = this.readU32();\n        return high * 0x100000000 + low;\n    }\n    readF64() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 8);\n        this.pos += 8;\n        return view.getFloat64(offset, false);\n    }\n    readFixed_16_16() {\n        return this.readI32() / 0x10000;\n    }\n    readFixed_2_30() {\n        return this.readI32() / 0x40000000;\n    }\n    readAscii(length) {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + length);\n        this.pos += length;\n        let str = '';\n        for (let i = 0; i < length; i++) {\n            str += String.fromCharCode(view.getUint8(offset + i));\n        }\n        return str;\n    }\n    readIsomVariableInteger() {\n        let result = 0;\n        for (let i = 0; i < 4; i++) {\n            result <<= 7;\n            const nextByte = this.readU8();\n            result |= nextByte & 0x7f;\n            if ((nextByte & 0x80) === 0) {\n                break;\n            }\n        }\n        return result;\n    }\n    readBoxHeader() {\n        let totalSize = this.readU32();\n        const name = this.readAscii(4);\n        let headerSize = 8;\n        const hasLargeSize = totalSize === 1;\n        if (hasLargeSize) {\n            totalSize = this.readU64();\n            headerSize = 16;\n        }\n        const contentSize = totalSize - headerSize;\n        if (contentSize < 0) {\n            return null; // Hardly a box is it\n        }\n        return { name, totalSize, headerSize, contentSize };\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6217, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-demuxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { extractAudioCodecString, extractVideoCodecString, parseAacAudioSpecificConfig, parsePcmCodec, PCM_AUDIO_CODECS, } from '../codec.js';\nimport { extractVp9CodecInfoFromPacket, extractAv1CodecInfoFromPacket, } from '../codec-data.js';\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack, InputVideoTrack, } from '../input-track.js';\nimport { assert, COLOR_PRIMARIES_MAP_INVERSE, MATRIX_COEFFICIENTS_MAP_INVERSE, TRANSFER_CHARACTERISTICS_MAP_INVERSE, binarySearchLessOrEqual, binarySearchExact, last, AsyncMutex, findLastIndex, UNDETERMINED_LANGUAGE, roundToPrecision, isIso639Dash2LanguageCode, roundToMultiple, normalizeRotation, Bitstream, insertSorted, } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { Reader } from '../reader.js';\nimport { buildIsobmffMimeType } from './isobmff-misc.js';\nimport { IsobmffReader, MAX_BOX_HEADER_SIZE, MIN_BOX_HEADER_SIZE } from './isobmff-reader.js';\nexport class IsobmffDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.currentTrack = null;\n        this.tracks = [];\n        this.metadataPromise = null;\n        this.movieTimescale = -1;\n        this.movieDurationInTimescale = -1;\n        this.isQuickTime = false;\n        this.isFragmented = false;\n        this.fragmentTrackDefaults = [];\n        this.fragments = [];\n        this.currentFragment = null;\n        this.fragmentLookupMutex = new AsyncMutex();\n        this.metadataReader = new IsobmffReader(input._mainReader);\n        this.chunkReader = new IsobmffReader(new Reader(input.source, 64 * 2 ** 20)); // Max 64 MiB of stored chunks\n    }\n    async computeDuration() {\n        const tracks = await this.getTracks();\n        const trackDurations = await Promise.all(tracks.map(x => x.computeDuration()));\n        return Math.max(0, ...trackDurations);\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks.map(track => track.inputTrack);\n    }\n    async getMimeType() {\n        await this.readMetadata();\n        const codecStrings = await Promise.all(this.tracks.map(x => x.inputTrack.getCodecParameterString()));\n        return buildIsobmffMimeType({\n            isQuickTime: this.isQuickTime,\n            hasVideo: this.tracks.some(x => x.info?.type === 'video'),\n            hasAudio: this.tracks.some(x => x.info?.type === 'audio'),\n            codecStrings: codecStrings.filter(Boolean),\n        });\n    }\n    readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            const sourceSize = await this.metadataReader.reader.source.getSize();\n            while (this.metadataReader.pos < sourceSize) {\n                await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + MAX_BOX_HEADER_SIZE);\n                const startPos = this.metadataReader.pos;\n                const boxInfo = this.metadataReader.readBoxHeader();\n                if (!boxInfo) {\n                    break;\n                }\n                if (boxInfo.name === 'ftyp') {\n                    const majorBrand = this.metadataReader.readAscii(4);\n                    this.isQuickTime = majorBrand === 'qt  ';\n                }\n                else if (boxInfo.name === 'moov') {\n                    // Found moov, load it\n                    await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + boxInfo.contentSize);\n                    this.readContiguousBoxes(boxInfo.contentSize);\n                    for (const track of this.tracks) {\n                        // Modify the edit list offset based on the previous segment durations. They are in different\n                        // timescales, so we first convert to seconds and then into the track timescale.\n                        const previousSegmentDurationsInSeconds = track.editListPreviousSegmentDurations / this.movieTimescale;\n                        track.editListOffset -= Math.round(previousSegmentDurationsInSeconds * track.timescale);\n                    }\n                    break;\n                }\n                this.metadataReader.pos = startPos + boxInfo.totalSize;\n            }\n            if (this.isFragmented) {\n                // The last 4 bytes may contain the size of the mfra box at the end of the file\n                await this.metadataReader.reader.loadRange(sourceSize - 4, sourceSize);\n                this.metadataReader.pos = sourceSize - 4;\n                const lastWord = this.metadataReader.readU32();\n                const potentialMfraPos = sourceSize - lastWord;\n                if (potentialMfraPos >= 0 && potentialMfraPos <= sourceSize - MAX_BOX_HEADER_SIZE) {\n                    // Load the header and a bit more, likely covering the entire box\n                    await this.metadataReader.reader.loadRange(potentialMfraPos, potentialMfraPos + 2 ** 16);\n                    this.metadataReader.pos = potentialMfraPos;\n                    const boxInfo = this.metadataReader.readBoxHeader();\n                    if (boxInfo && boxInfo.name === 'mfra') {\n                        // We found the mfra box, allowing for much better random access. Let's parse it.\n                        await this.metadataReader.reader.loadRange(potentialMfraPos, potentialMfraPos + boxInfo.totalSize);\n                        this.readContiguousBoxes(boxInfo.contentSize);\n                    }\n                }\n            }\n        })();\n    }\n    getSampleTableForTrack(internalTrack) {\n        if (internalTrack.sampleTable) {\n            return internalTrack.sampleTable;\n        }\n        const sampleTable = {\n            sampleTimingEntries: [],\n            sampleCompositionTimeOffsets: [],\n            sampleSizes: [],\n            keySampleIndices: null,\n            chunkOffsets: [],\n            sampleToChunk: [],\n            presentationTimestamps: null,\n            presentationTimestampIndexMap: null,\n        };\n        internalTrack.sampleTable = sampleTable;\n        this.metadataReader.pos = internalTrack.sampleTableByteOffset;\n        this.currentTrack = internalTrack;\n        this.traverseBox();\n        this.currentTrack = null;\n        const isPcmCodec = internalTrack.info?.type === 'audio'\n            && internalTrack.info.codec\n            && PCM_AUDIO_CODECS.includes(internalTrack.info.codec);\n        if (isPcmCodec && sampleTable.sampleCompositionTimeOffsets.length === 0) {\n            // If the audio has PCM samples, the way the samples are defined in the sample table is somewhat\n            // suboptimal: Each individual audio sample is its own sample, meaning we can have 48000 samples per second.\n            // Because we treat each sample as its own atomic unit that can be decoded, this would lead to a huge\n            // amount of very short samples for PCM audio. So instead, we make a transformation: If the audio is in PCM,\n            // we say that each chunk (that normally holds many samples) now is one big sample. We can this because\n            // the samples in the chunk are contiguous and the format is PCM, so the entire chunk as one thing still\n            // encodes valid audio information.\n            assert(internalTrack.info?.type === 'audio');\n            const pcmInfo = parsePcmCodec(internalTrack.info.codec);\n            const newSampleTimingEntries = [];\n            const newSampleSizes = [];\n            for (let i = 0; i < sampleTable.sampleToChunk.length; i++) {\n                const chunkEntry = sampleTable.sampleToChunk[i];\n                const nextEntry = sampleTable.sampleToChunk[i + 1];\n                const chunkCount = (nextEntry ? nextEntry.startChunkIndex : sampleTable.chunkOffsets.length)\n                    - chunkEntry.startChunkIndex;\n                for (let j = 0; j < chunkCount; j++) {\n                    const startSampleIndex = chunkEntry.startSampleIndex + j * chunkEntry.samplesPerChunk;\n                    const endSampleIndex = startSampleIndex + chunkEntry.samplesPerChunk; // Exclusive, outside of chunk\n                    const startTimingEntryIndex = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, startSampleIndex, x => x.startIndex);\n                    const startTimingEntry = sampleTable.sampleTimingEntries[startTimingEntryIndex];\n                    const endTimingEntryIndex = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, endSampleIndex, x => x.startIndex);\n                    const endTimingEntry = sampleTable.sampleTimingEntries[endTimingEntryIndex];\n                    const firstSampleTimestamp = startTimingEntry.startDecodeTimestamp\n                        + (startSampleIndex - startTimingEntry.startIndex) * startTimingEntry.delta;\n                    const lastSampleTimestamp = endTimingEntry.startDecodeTimestamp\n                        + (endSampleIndex - endTimingEntry.startIndex) * endTimingEntry.delta;\n                    const delta = lastSampleTimestamp - firstSampleTimestamp;\n                    const lastSampleTimingEntry = last(newSampleTimingEntries);\n                    if (lastSampleTimingEntry && lastSampleTimingEntry.delta === delta) {\n                        lastSampleTimingEntry.count++;\n                    }\n                    else {\n                        // One sample for the entire chunk\n                        newSampleTimingEntries.push({\n                            startIndex: chunkEntry.startChunkIndex + j,\n                            startDecodeTimestamp: firstSampleTimestamp,\n                            count: 1,\n                            delta,\n                        });\n                    }\n                    // Instead of determining the chunk's size by looping over the samples sizes in the sample table, we\n                    // can directly compute it as we know how many PCM frames are in this chunk, and the size of each\n                    // PCM frame. This also improves compatibility with some files which fail to write proper sample\n                    // size values into their sample tables in the PCM case.\n                    const chunkSize = chunkEntry.samplesPerChunk\n                        * pcmInfo.sampleSize\n                        * internalTrack.info.numberOfChannels;\n                    newSampleSizes.push(chunkSize);\n                }\n                chunkEntry.startSampleIndex = chunkEntry.startChunkIndex;\n                chunkEntry.samplesPerChunk = 1;\n            }\n            sampleTable.sampleTimingEntries = newSampleTimingEntries;\n            sampleTable.sampleSizes = newSampleSizes;\n        }\n        if (sampleTable.sampleCompositionTimeOffsets.length > 0) {\n            // If composition time offsets are defined, we must build a list of all presentation timestamps and then\n            // sort them\n            sampleTable.presentationTimestamps = [];\n            for (const entry of sampleTable.sampleTimingEntries) {\n                for (let i = 0; i < entry.count; i++) {\n                    sampleTable.presentationTimestamps.push({\n                        presentationTimestamp: entry.startDecodeTimestamp + i * entry.delta,\n                        sampleIndex: entry.startIndex + i,\n                    });\n                }\n            }\n            for (const entry of sampleTable.sampleCompositionTimeOffsets) {\n                for (let i = 0; i < entry.count; i++) {\n                    const sampleIndex = entry.startIndex + i;\n                    const sample = sampleTable.presentationTimestamps[sampleIndex];\n                    if (!sample) {\n                        continue;\n                    }\n                    sample.presentationTimestamp += entry.offset;\n                }\n            }\n            sampleTable.presentationTimestamps.sort((a, b) => a.presentationTimestamp - b.presentationTimestamp);\n            sampleTable.presentationTimestampIndexMap = Array(sampleTable.presentationTimestamps.length).fill(-1);\n            for (let i = 0; i < sampleTable.presentationTimestamps.length; i++) {\n                sampleTable.presentationTimestampIndexMap[sampleTable.presentationTimestamps[i].sampleIndex] = i;\n            }\n        }\n        else {\n            // If they're not defined, we can simply use the decode timestamps as presentation timestamps\n        }\n        return sampleTable;\n    }\n    async readFragment() {\n        const startPos = this.metadataReader.pos;\n        await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + MAX_BOX_HEADER_SIZE);\n        const moofBoxInfo = this.metadataReader.readBoxHeader();\n        assert(moofBoxInfo?.name === 'moof');\n        const contentStart = this.metadataReader.pos;\n        await this.metadataReader.reader.loadRange(contentStart, contentStart + moofBoxInfo.contentSize);\n        this.metadataReader.pos = startPos;\n        this.traverseBox();\n        const index = binarySearchExact(this.fragments, startPos, x => x.moofOffset);\n        assert(index !== -1);\n        const fragment = this.fragments[index];\n        assert(fragment.moofOffset === startPos);\n        // We have read everything in the moof box, there's no need to keep the data around anymore\n        // (keep the header tho)\n        this.metadataReader.reader.forgetRange(contentStart, contentStart + moofBoxInfo.contentSize);\n        // It may be that some tracks don't define the base decode time, i.e. when the fragment begins. This means the\n        // only other option is to sum up the duration of all previous fragments.\n        for (const [trackId, trackData] of fragment.trackData) {\n            if (trackData.startTimestampIsFinal) {\n                continue;\n            }\n            const internalTrack = this.tracks.find(x => x.id === trackId);\n            this.metadataReader.pos = 0;\n            let currentFragment = null;\n            let lastFragment = null;\n            const index = binarySearchLessOrEqual(internalTrack.fragments, startPos - 1, x => x.moofOffset);\n            if (index !== -1) {\n                // Instead of starting at the start of the file, let's start at the previous fragment instead (which\n                // already has final timestamps).\n                currentFragment = internalTrack.fragments[index];\n                lastFragment = currentFragment;\n                this.metadataReader.pos = currentFragment.moofOffset + currentFragment.moofSize;\n            }\n            let nextFragmentIsFirstFragment = this.metadataReader.pos === 0;\n            while (this.metadataReader.pos <= startPos - MIN_BOX_HEADER_SIZE) {\n                if (currentFragment?.nextFragment) {\n                    currentFragment = currentFragment.nextFragment;\n                    this.metadataReader.pos = currentFragment.moofOffset + currentFragment.moofSize;\n                }\n                else {\n                    await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + MAX_BOX_HEADER_SIZE);\n                    const startPos = this.metadataReader.pos;\n                    const boxInfo = this.metadataReader.readBoxHeader();\n                    if (!boxInfo) {\n                        break;\n                    }\n                    if (boxInfo.name === 'moof') {\n                        const index = binarySearchExact(this.fragments, startPos, x => x.moofOffset);\n                        let fragment;\n                        if (index === -1) {\n                            this.metadataReader.pos = startPos;\n                            fragment = await this.readFragment(); // Recursive call\n                        }\n                        else {\n                            // We already know this fragment\n                            fragment = this.fragments[index];\n                        }\n                        // Even if we already know the fragment, we might not yet know its predecessor; always do this\n                        if (currentFragment)\n                            currentFragment.nextFragment = fragment;\n                        currentFragment = fragment;\n                        if (nextFragmentIsFirstFragment) {\n                            fragment.isKnownToBeFirstFragment = true;\n                            nextFragmentIsFirstFragment = false;\n                        }\n                    }\n                    this.metadataReader.pos = startPos + boxInfo.totalSize;\n                }\n                if (currentFragment && currentFragment.trackData.has(trackId)) {\n                    lastFragment = currentFragment;\n                }\n            }\n            if (lastFragment) {\n                const otherTrackData = lastFragment.trackData.get(trackId);\n                assert(otherTrackData.startTimestampIsFinal);\n                offsetFragmentTrackDataByTimestamp(trackData, otherTrackData.endTimestamp);\n            }\n            trackData.startTimestampIsFinal = true;\n        }\n        return fragment;\n    }\n    readContiguousBoxes(totalSize) {\n        const startIndex = this.metadataReader.pos;\n        while (this.metadataReader.pos - startIndex <= totalSize - MIN_BOX_HEADER_SIZE) {\n            const foundBox = this.traverseBox();\n            if (!foundBox) {\n                break;\n            }\n        }\n    }\n    traverseBox() {\n        const startPos = this.metadataReader.pos;\n        const boxInfo = this.metadataReader.readBoxHeader();\n        if (!boxInfo) {\n            return false;\n        }\n        const boxEndPos = startPos + boxInfo.totalSize;\n        switch (boxInfo.name) {\n            case 'mdia':\n            case 'minf':\n            case 'dinf':\n            case 'mfra':\n            case 'edts':\n                {\n                    this.readContiguousBoxes(boxInfo.contentSize);\n                }\n                ;\n                break;\n            case 'mvhd':\n                {\n                    const version = this.metadataReader.readU8();\n                    this.metadataReader.pos += 3; // Flags\n                    if (version === 1) {\n                        this.metadataReader.pos += 8 + 8;\n                        this.movieTimescale = this.metadataReader.readU32();\n                        this.movieDurationInTimescale = this.metadataReader.readU64();\n                    }\n                    else {\n                        this.metadataReader.pos += 4 + 4;\n                        this.movieTimescale = this.metadataReader.readU32();\n                        this.movieDurationInTimescale = this.metadataReader.readU32();\n                    }\n                }\n                ;\n                break;\n            case 'trak':\n                {\n                    const track = {\n                        id: -1,\n                        demuxer: this,\n                        inputTrack: null,\n                        info: null,\n                        timescale: -1,\n                        durationInMovieTimescale: -1,\n                        durationInMediaTimescale: -1,\n                        rotation: 0,\n                        languageCode: UNDETERMINED_LANGUAGE,\n                        sampleTableByteOffset: -1,\n                        sampleTable: null,\n                        fragmentLookupTable: null,\n                        currentFragmentState: null,\n                        fragments: [],\n                        fragmentsWithKeyFrame: [],\n                        editListPreviousSegmentDurations: 0,\n                        editListOffset: 0,\n                    };\n                    this.currentTrack = track;\n                    this.readContiguousBoxes(boxInfo.contentSize);\n                    if (track.id !== -1 && track.timescale !== -1 && track.info !== null) {\n                        if (track.info.type === 'video' && track.info.width !== -1) {\n                            const videoTrack = track;\n                            track.inputTrack = new InputVideoTrack(new IsobmffVideoTrackBacking(videoTrack));\n                            this.tracks.push(track);\n                        }\n                        else if (track.info.type === 'audio' && track.info.numberOfChannels !== -1) {\n                            const audioTrack = track;\n                            track.inputTrack = new InputAudioTrack(new IsobmffAudioTrackBacking(audioTrack));\n                            this.tracks.push(track);\n                        }\n                    }\n                    this.currentTrack = null;\n                }\n                ;\n                break;\n            case 'tkhd':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    const version = this.metadataReader.readU8();\n                    const flags = this.metadataReader.readU24();\n                    const trackEnabled = (flags & 0x1) !== 0;\n                    if (!trackEnabled) {\n                        break;\n                    }\n                    // Skip over creation & modification time to reach the track ID\n                    if (version === 0) {\n                        this.metadataReader.pos += 8;\n                        track.id = this.metadataReader.readU32();\n                        this.metadataReader.pos += 4;\n                        track.durationInMovieTimescale = this.metadataReader.readU32();\n                    }\n                    else if (version === 1) {\n                        this.metadataReader.pos += 16;\n                        track.id = this.metadataReader.readU32();\n                        this.metadataReader.pos += 4;\n                        track.durationInMovieTimescale = this.metadataReader.readU64();\n                    }\n                    else {\n                        throw new Error(`Incorrect track header version ${version}.`);\n                    }\n                    this.metadataReader.pos += 2 * 4 + 2 + 2 + 2 + 2;\n                    const matrix = [\n                        this.metadataReader.readFixed_16_16(),\n                        this.metadataReader.readFixed_16_16(),\n                        this.metadataReader.readFixed_2_30(),\n                        this.metadataReader.readFixed_16_16(),\n                        this.metadataReader.readFixed_16_16(),\n                        this.metadataReader.readFixed_2_30(),\n                        this.metadataReader.readFixed_16_16(),\n                        this.metadataReader.readFixed_16_16(),\n                        this.metadataReader.readFixed_2_30(),\n                    ];\n                    const rotation = normalizeRotation(roundToMultiple(extractRotationFromMatrix(matrix), 90));\n                    assert(rotation === 0 || rotation === 90 || rotation === 180 || rotation === 270);\n                    track.rotation = rotation;\n                }\n                ;\n                break;\n            case 'elst':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    const version = this.metadataReader.readU8();\n                    this.metadataReader.pos += 3; // Flags\n                    let relevantEntryFound = false;\n                    let previousSegmentDurations = 0;\n                    const entryCount = this.metadataReader.readU32();\n                    for (let i = 0; i < entryCount; i++) {\n                        const segmentDuration = version === 1\n                            ? this.metadataReader.readU64()\n                            : this.metadataReader.readU32();\n                        const mediaTime = version === 1\n                            ? this.metadataReader.readI64()\n                            : this.metadataReader.readI32();\n                        const mediaRate = this.metadataReader.readFixed_16_16();\n                        if (segmentDuration === 0) {\n                            // Don't care\n                            continue;\n                        }\n                        if (relevantEntryFound) {\n                            console.warn('Unsupported edit list: multiple edits are not currently supported. Only using first edit.');\n                            break;\n                        }\n                        if (mediaTime === -1) {\n                            previousSegmentDurations += segmentDuration;\n                            continue;\n                        }\n                        if (mediaRate !== 1) {\n                            console.warn('Unsupported edit list entry: media rate must be 1.');\n                            break;\n                        }\n                        track.editListPreviousSegmentDurations = previousSegmentDurations;\n                        track.editListOffset = mediaTime;\n                        relevantEntryFound = true;\n                    }\n                }\n                ;\n                break;\n            case 'mdhd':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    const version = this.metadataReader.readU8();\n                    this.metadataReader.pos += 3; // Flags\n                    if (version === 0) {\n                        this.metadataReader.pos += 8;\n                        track.timescale = this.metadataReader.readU32();\n                        track.durationInMediaTimescale = this.metadataReader.readU32();\n                    }\n                    else if (version === 1) {\n                        this.metadataReader.pos += 16;\n                        track.timescale = this.metadataReader.readU32();\n                        track.durationInMediaTimescale = this.metadataReader.readU64();\n                    }\n                    let language = this.metadataReader.readU16();\n                    if (language > 0) {\n                        track.languageCode = '';\n                        for (let i = 0; i < 3; i++) {\n                            track.languageCode = String.fromCharCode(0x60 + (language & 0b11111)) + track.languageCode;\n                            language >>= 5;\n                        }\n                        if (!isIso639Dash2LanguageCode(track.languageCode)) {\n                            // Sometimes the bytes are garbage\n                            track.languageCode = UNDETERMINED_LANGUAGE;\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'hdlr':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    this.metadataReader.pos += 8; // Version + flags + pre-defined\n                    const handlerType = this.metadataReader.readAscii(4);\n                    if (handlerType === 'vide') {\n                        track.info = {\n                            type: 'video',\n                            width: -1,\n                            height: -1,\n                            codec: null,\n                            codecDescription: null,\n                            colorSpace: null,\n                            avcCodecInfo: null,\n                            hevcCodecInfo: null,\n                            vp9CodecInfo: null,\n                            av1CodecInfo: null,\n                        };\n                    }\n                    else if (handlerType === 'soun') {\n                        track.info = {\n                            type: 'audio',\n                            numberOfChannels: -1,\n                            sampleRate: -1,\n                            codec: null,\n                            codecDescription: null,\n                            aacCodecInfo: null,\n                        };\n                    }\n                }\n                ;\n                break;\n            case 'stbl':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    track.sampleTableByteOffset = startPos;\n                    this.readContiguousBoxes(boxInfo.contentSize);\n                }\n                ;\n                break;\n            case 'stsd':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    if (track.info === null || track.sampleTable) {\n                        break;\n                    }\n                    const stsdVersion = this.metadataReader.readU8();\n                    this.metadataReader.pos += 3; // Flags\n                    const entries = this.metadataReader.readU32();\n                    for (let i = 0; i < entries; i++) {\n                        const startPos = this.metadataReader.pos;\n                        const sampleBoxInfo = this.metadataReader.readBoxHeader();\n                        if (!sampleBoxInfo) {\n                            break;\n                        }\n                        const lowercaseBoxName = sampleBoxInfo.name.toLowerCase();\n                        if (track.info.type === 'video') {\n                            if (lowercaseBoxName === 'avc1') {\n                                track.info.codec = 'avc';\n                            }\n                            else if (lowercaseBoxName === 'hvc1' || lowercaseBoxName === 'hev1') {\n                                track.info.codec = 'hevc';\n                            }\n                            else if (lowercaseBoxName === 'vp08') {\n                                track.info.codec = 'vp8';\n                            }\n                            else if (lowercaseBoxName === 'vp09') {\n                                track.info.codec = 'vp9';\n                            }\n                            else if (lowercaseBoxName === 'av01') {\n                                track.info.codec = 'av1';\n                            }\n                            else {\n                                console.warn(`Unsupported video codec (sample entry type '${sampleBoxInfo.name}').`);\n                            }\n                            this.metadataReader.pos += 6 * 1 + 2 + 2 + 2 + 3 * 4;\n                            track.info.width = this.metadataReader.readU16();\n                            track.info.height = this.metadataReader.readU16();\n                            this.metadataReader.pos += 4 + 4 + 4 + 2 + 32 + 2 + 2;\n                            this.readContiguousBoxes((startPos + sampleBoxInfo.totalSize) - this.metadataReader.pos);\n                        }\n                        else {\n                            if (lowercaseBoxName === 'mp4a') {\n                                // We don't know the codec yet (might be AAC, might be MP3), need to read the esds box\n                            }\n                            else if (lowercaseBoxName === 'opus') {\n                                track.info.codec = 'opus';\n                            }\n                            else if (lowercaseBoxName === 'flac') {\n                                track.info.codec = 'flac';\n                            }\n                            else if (lowercaseBoxName === 'twos'\n                                || lowercaseBoxName === 'sowt'\n                                || lowercaseBoxName === 'raw '\n                                || lowercaseBoxName === 'in24'\n                                || lowercaseBoxName === 'in32'\n                                || lowercaseBoxName === 'fl32'\n                                || lowercaseBoxName === 'fl64'\n                                || lowercaseBoxName === 'lpcm'\n                                || lowercaseBoxName === 'ipcm' // ISO/IEC 23003-5\n                                || lowercaseBoxName === 'fpcm' // \"\n                            ) {\n                                // It's PCM\n                                // developer.apple.com/documentation/quicktime-file-format/sound_sample_descriptions/\n                            }\n                            else if (lowercaseBoxName === 'ulaw') {\n                                track.info.codec = 'ulaw';\n                            }\n                            else if (lowercaseBoxName === 'alaw') {\n                                track.info.codec = 'alaw';\n                            }\n                            else {\n                                console.warn(`Unsupported audio codec (sample entry type '${sampleBoxInfo.name}').`);\n                            }\n                            this.metadataReader.pos += 6 * 1 + 2;\n                            const version = this.metadataReader.readU16();\n                            this.metadataReader.pos += 3 * 2;\n                            let channelCount = this.metadataReader.readU16();\n                            let sampleSize = this.metadataReader.readU16();\n                            this.metadataReader.pos += 2 * 2;\n                            // Can't use fixed16_16 as that's signed\n                            let sampleRate = this.metadataReader.readU32() / 0x10000;\n                            if (stsdVersion === 0 && version > 0) {\n                                // Additional QuickTime fields\n                                if (version === 1) {\n                                    this.metadataReader.pos += 4;\n                                    sampleSize = 8 * this.metadataReader.readU32();\n                                    this.metadataReader.pos += 2 * 4;\n                                }\n                                else if (version === 2) {\n                                    this.metadataReader.pos += 4;\n                                    sampleRate = this.metadataReader.readF64();\n                                    channelCount = this.metadataReader.readU32();\n                                    this.metadataReader.pos += 4; // Always 0x7f000000\n                                    sampleSize = this.metadataReader.readU32();\n                                    const flags = this.metadataReader.readU32();\n                                    this.metadataReader.pos += 2 * 4;\n                                    if (lowercaseBoxName === 'lpcm') {\n                                        const bytesPerSample = (sampleSize + 7) >> 3;\n                                        const isFloat = Boolean(flags & 1);\n                                        const isBigEndian = Boolean(flags & 2);\n                                        const sFlags = flags & 4 ? -1 : 0; // I guess it means \"signed flags\" or something?\n                                        if (sampleSize > 0 && sampleSize <= 64) {\n                                            if (isFloat) {\n                                                if (sampleSize === 32) {\n                                                    track.info.codec = isBigEndian ? 'pcm-f32be' : 'pcm-f32';\n                                                }\n                                            }\n                                            else {\n                                                if (sFlags & (1 << (bytesPerSample - 1))) {\n                                                    if (bytesPerSample === 1) {\n                                                        track.info.codec = 'pcm-s8';\n                                                    }\n                                                    else if (bytesPerSample === 2) {\n                                                        track.info.codec = isBigEndian ? 'pcm-s16be' : 'pcm-s16';\n                                                    }\n                                                    else if (bytesPerSample === 3) {\n                                                        track.info.codec = isBigEndian ? 'pcm-s24be' : 'pcm-s24';\n                                                    }\n                                                    else if (bytesPerSample === 4) {\n                                                        track.info.codec = isBigEndian ? 'pcm-s32be' : 'pcm-s32';\n                                                    }\n                                                }\n                                                else {\n                                                    if (bytesPerSample === 1) {\n                                                        track.info.codec = 'pcm-u8';\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        if (track.info.codec === null) {\n                                            console.warn('Unsupported PCM format.');\n                                        }\n                                    }\n                                }\n                            }\n                            track.info.numberOfChannels = channelCount;\n                            track.info.sampleRate = sampleRate;\n                            // PCM codec assignments\n                            if (lowercaseBoxName === 'twos') {\n                                if (sampleSize === 8) {\n                                    track.info.codec = 'pcm-s8';\n                                }\n                                else if (sampleSize === 16) {\n                                    track.info.codec = 'pcm-s16be';\n                                }\n                                else {\n                                    console.warn(`Unsupported sample size ${sampleSize} for codec 'twos'.`);\n                                    track.info.codec = null;\n                                }\n                            }\n                            else if (lowercaseBoxName === 'sowt') {\n                                if (sampleSize === 8) {\n                                    track.info.codec = 'pcm-s8';\n                                }\n                                else if (sampleSize === 16) {\n                                    track.info.codec = 'pcm-s16';\n                                }\n                                else {\n                                    console.warn(`Unsupported sample size ${sampleSize} for codec 'sowt'.`);\n                                    track.info.codec = null;\n                                }\n                            }\n                            else if (lowercaseBoxName === 'raw ') {\n                                track.info.codec = 'pcm-u8';\n                            }\n                            else if (lowercaseBoxName === 'in24') {\n                                track.info.codec = 'pcm-s24be';\n                            }\n                            else if (lowercaseBoxName === 'in32') {\n                                track.info.codec = 'pcm-s32be';\n                            }\n                            else if (lowercaseBoxName === 'fl32') {\n                                track.info.codec = 'pcm-f32be';\n                            }\n                            else if (lowercaseBoxName === 'fl64') {\n                                track.info.codec = 'pcm-f64be';\n                            }\n                            else if (lowercaseBoxName === 'ipcm') {\n                                track.info.codec = 'pcm-s16be'; // Placeholder, will be adjusted by the pcmC box\n                            }\n                            else if (lowercaseBoxName === 'fpcm') {\n                                track.info.codec = 'pcm-f32be'; // Placeholder, will be adjusted by the pcmC box\n                            }\n                            this.readContiguousBoxes((startPos + sampleBoxInfo.totalSize) - this.metadataReader.pos);\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'avcC':\n                {\n                    const track = this.currentTrack;\n                    assert(track && track.info);\n                    track.info.codecDescription = this.metadataReader.readBytes(boxInfo.contentSize);\n                }\n                ;\n                break;\n            case 'hvcC':\n                {\n                    const track = this.currentTrack;\n                    assert(track && track.info);\n                    track.info.codecDescription = this.metadataReader.readBytes(boxInfo.contentSize);\n                }\n                ;\n                break;\n            case 'vpcC':\n                {\n                    const track = this.currentTrack;\n                    assert(track && track.info?.type === 'video');\n                    this.metadataReader.pos += 4; // Version + flags\n                    const profile = this.metadataReader.readU8();\n                    const level = this.metadataReader.readU8();\n                    const thirdByte = this.metadataReader.readU8();\n                    const bitDepth = thirdByte >> 4;\n                    const chromaSubsampling = (thirdByte >> 1) & 0b111;\n                    const videoFullRangeFlag = thirdByte & 1;\n                    const colourPrimaries = this.metadataReader.readU8();\n                    const transferCharacteristics = this.metadataReader.readU8();\n                    const matrixCoefficients = this.metadataReader.readU8();\n                    track.info.vp9CodecInfo = {\n                        profile,\n                        level,\n                        bitDepth,\n                        chromaSubsampling,\n                        videoFullRangeFlag,\n                        colourPrimaries,\n                        transferCharacteristics,\n                        matrixCoefficients,\n                    };\n                }\n                ;\n                break;\n            case 'av1C':\n                {\n                    const track = this.currentTrack;\n                    assert(track && track.info?.type === 'video');\n                    this.metadataReader.pos += 1; // Marker + version\n                    const secondByte = this.metadataReader.readU8();\n                    const profile = secondByte >> 5;\n                    const level = secondByte & 0b11111;\n                    const thirdByte = this.metadataReader.readU8();\n                    const tier = thirdByte >> 7;\n                    const highBitDepth = (thirdByte >> 6) & 1;\n                    const twelveBit = (thirdByte >> 5) & 1;\n                    const monochrome = (thirdByte >> 4) & 1;\n                    const chromaSubsamplingX = (thirdByte >> 3) & 1;\n                    const chromaSubsamplingY = (thirdByte >> 2) & 1;\n                    const chromaSamplePosition = thirdByte & 0b11;\n                    // Logic from https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n                    const bitDepth = profile === 2 && highBitDepth ? (twelveBit ? 12 : 10) : (highBitDepth ? 10 : 8);\n                    track.info.av1CodecInfo = {\n                        profile,\n                        level,\n                        tier,\n                        bitDepth,\n                        monochrome,\n                        chromaSubsamplingX,\n                        chromaSubsamplingY,\n                        chromaSamplePosition,\n                    };\n                }\n                ;\n                break;\n            case 'colr':\n                {\n                    const track = this.currentTrack;\n                    assert(track && track.info?.type === 'video');\n                    const colourType = this.metadataReader.readAscii(4);\n                    if (colourType !== 'nclx') {\n                        break;\n                    }\n                    const colourPrimaries = this.metadataReader.readU16();\n                    const transferCharacteristics = this.metadataReader.readU16();\n                    const matrixCoefficients = this.metadataReader.readU16();\n                    const fullRangeFlag = Boolean(this.metadataReader.readU8() & 0x80);\n                    track.info.colorSpace = {\n                        primaries: COLOR_PRIMARIES_MAP_INVERSE[colourPrimaries],\n                        transfer: TRANSFER_CHARACTERISTICS_MAP_INVERSE[transferCharacteristics],\n                        matrix: MATRIX_COEFFICIENTS_MAP_INVERSE[matrixCoefficients],\n                        fullRange: fullRangeFlag,\n                    };\n                }\n                ;\n                break;\n            case 'wave':\n                {\n                    this.readContiguousBoxes(boxInfo.contentSize);\n                }\n                ;\n                break;\n            case 'esds':\n                {\n                    const track = this.currentTrack;\n                    assert(track && track.info?.type === 'audio');\n                    this.metadataReader.pos += 4; // Version + flags\n                    const tag = this.metadataReader.readU8();\n                    assert(tag === 0x03); // ES Descriptor\n                    this.metadataReader.readIsomVariableInteger(); // Length\n                    this.metadataReader.pos += 2; // ES ID\n                    const mixed = this.metadataReader.readU8();\n                    const streamDependenceFlag = (mixed & 0x80) !== 0;\n                    const urlFlag = (mixed & 0x40) !== 0;\n                    const ocrStreamFlag = (mixed & 0x20) !== 0;\n                    if (streamDependenceFlag) {\n                        this.metadataReader.pos += 2;\n                    }\n                    if (urlFlag) {\n                        const urlLength = this.metadataReader.readU8();\n                        this.metadataReader.pos += urlLength;\n                    }\n                    if (ocrStreamFlag) {\n                        this.metadataReader.pos += 2;\n                    }\n                    const decoderConfigTag = this.metadataReader.readU8();\n                    assert(decoderConfigTag === 0x04); // DecoderConfigDescriptor\n                    const decoderConfigDescriptorLength = this.metadataReader.readIsomVariableInteger(); // Length\n                    const payloadStart = this.metadataReader.pos;\n                    const objectTypeIndication = this.metadataReader.readU8();\n                    if (objectTypeIndication === 0x40 || objectTypeIndication === 0x67) {\n                        track.info.codec = 'aac';\n                        track.info.aacCodecInfo = { isMpeg2: objectTypeIndication === 0x67 };\n                    }\n                    else if (objectTypeIndication === 0x69 || objectTypeIndication === 0x6b) {\n                        track.info.codec = 'mp3';\n                    }\n                    else if (objectTypeIndication === 0xdd) {\n                        track.info.codec = 'vorbis'; // \"nonstandard, gpac uses it\" - FFmpeg\n                    }\n                    else {\n                        console.warn(`Unsupported audio codec (objectTypeIndication ${objectTypeIndication}) - discarding track.`);\n                    }\n                    this.metadataReader.pos += 1 + 3 + 4 + 4;\n                    if (decoderConfigDescriptorLength > this.metadataReader.pos - payloadStart) {\n                        // There's a DecoderSpecificInfo at the end, let's read it\n                        const decoderSpecificInfoTag = this.metadataReader.readU8();\n                        assert(decoderSpecificInfoTag === 0x05); // DecoderSpecificInfo\n                        const decoderSpecificInfoLength = this.metadataReader.readIsomVariableInteger();\n                        track.info.codecDescription = this.metadataReader.readBytes(decoderSpecificInfoLength);\n                        if (track.info.codec === 'aac') {\n                            // Let's try to deduce more accurate values directly from the AudioSpecificConfig:\n                            const audioSpecificConfig = parseAacAudioSpecificConfig(track.info.codecDescription);\n                            if (audioSpecificConfig.numberOfChannels !== null) {\n                                track.info.numberOfChannels = audioSpecificConfig.numberOfChannels;\n                            }\n                            if (audioSpecificConfig.sampleRate !== null) {\n                                track.info.sampleRate = audioSpecificConfig.sampleRate;\n                            }\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'enda':\n                {\n                    const track = this.currentTrack;\n                    assert(track && track.info?.type === 'audio');\n                    const littleEndian = this.metadataReader.readU16() & 0xff; // 0xff is from FFmpeg\n                    if (littleEndian) {\n                        if (track.info.codec === 'pcm-s16be') {\n                            track.info.codec = 'pcm-s16';\n                        }\n                        else if (track.info.codec === 'pcm-s24be') {\n                            track.info.codec = 'pcm-s24';\n                        }\n                        else if (track.info.codec === 'pcm-s32be') {\n                            track.info.codec = 'pcm-s32';\n                        }\n                        else if (track.info.codec === 'pcm-f32be') {\n                            track.info.codec = 'pcm-f32';\n                        }\n                        else if (track.info.codec === 'pcm-f64be') {\n                            track.info.codec = 'pcm-f64';\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'pcmC':\n                {\n                    const track = this.currentTrack;\n                    assert(track && track.info?.type === 'audio');\n                    this.metadataReader.pos += 1 + 3; // Version + flags\n                    // ISO/IEC 23003-5\n                    const formatFlags = this.metadataReader.readU8();\n                    const isLittleEndian = Boolean(formatFlags & 0x01);\n                    const pcmSampleSize = this.metadataReader.readU8();\n                    if (track.info.codec === 'pcm-s16be') {\n                        // ipcm\n                        if (isLittleEndian) {\n                            if (pcmSampleSize === 16) {\n                                track.info.codec = 'pcm-s16';\n                            }\n                            else if (pcmSampleSize === 24) {\n                                track.info.codec = 'pcm-s24';\n                            }\n                            else if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-s32';\n                            }\n                            else {\n                                console.warn(`Invalid ipcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                        else {\n                            if (pcmSampleSize === 16) {\n                                track.info.codec = 'pcm-s16be';\n                            }\n                            else if (pcmSampleSize === 24) {\n                                track.info.codec = 'pcm-s24be';\n                            }\n                            else if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-s32be';\n                            }\n                            else {\n                                console.warn(`Invalid ipcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                    }\n                    else if (track.info.codec === 'pcm-f32be') {\n                        // fpcm\n                        if (isLittleEndian) {\n                            if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-f32';\n                            }\n                            else if (pcmSampleSize === 64) {\n                                track.info.codec = 'pcm-f64';\n                            }\n                            else {\n                                console.warn(`Invalid fpcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                        else {\n                            if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-f32be';\n                            }\n                            else if (pcmSampleSize === 64) {\n                                track.info.codec = 'pcm-f64be';\n                            }\n                            else {\n                                console.warn(`Invalid fpcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                    }\n                    break;\n                }\n                ;\n            case 'dOps':\n                { // Used for Opus audio\n                    const track = this.currentTrack;\n                    assert(track && track.info?.type === 'audio');\n                    this.metadataReader.pos += 1; // Version\n                    // https://www.opus-codec.org/docs/opus_in_isobmff.html\n                    const outputChannelCount = this.metadataReader.readU8();\n                    const preSkip = this.metadataReader.readU16();\n                    const inputSampleRate = this.metadataReader.readU32();\n                    const outputGain = this.metadataReader.readI16();\n                    const channelMappingFamily = this.metadataReader.readU8();\n                    let channelMappingTable;\n                    if (channelMappingFamily !== 0) {\n                        channelMappingTable = this.metadataReader.readBytes(2 + outputChannelCount);\n                    }\n                    else {\n                        channelMappingTable = new Uint8Array(0);\n                    }\n                    // https://datatracker.ietf.org/doc/html/draft-ietf-codec-oggopus-06\n                    const description = new Uint8Array(8 + 1 + 1 + 2 + 4 + 2 + 1 + channelMappingTable.byteLength);\n                    const view = new DataView(description.buffer);\n                    view.setUint32(0, 0x4f707573, false); // 'Opus'\n                    view.setUint32(4, 0x48656164, false); // 'Head'\n                    view.setUint8(8, 1); // Version\n                    view.setUint8(9, outputChannelCount);\n                    view.setUint16(10, preSkip, true);\n                    view.setUint32(12, inputSampleRate, true);\n                    view.setInt16(16, outputGain, true);\n                    view.setUint8(18, channelMappingFamily);\n                    description.set(channelMappingTable, 19);\n                    track.info.codecDescription = description;\n                    track.info.numberOfChannels = outputChannelCount;\n                    track.info.sampleRate = inputSampleRate;\n                }\n                ;\n                break;\n            case 'dfLa':\n                { // Used for FLAC audio\n                    const track = this.currentTrack;\n                    assert(track && track.info?.type === 'audio');\n                    this.metadataReader.pos += 4; // Version + flags\n                    // https://datatracker.ietf.org/doc/rfc9639/\n                    const BLOCK_TYPE_MASK = 0x7f;\n                    const LAST_METADATA_BLOCK_FLAG_MASK = 0x80;\n                    const startPos = this.metadataReader.pos;\n                    while (this.metadataReader.pos < boxEndPos) {\n                        const flagAndType = this.metadataReader.readU8();\n                        const metadataBlockLength = this.metadataReader.readU24();\n                        const type = flagAndType & BLOCK_TYPE_MASK;\n                        // It's a STREAMINFO block; let's extract the actual sample rate and channel count\n                        if (type === 0) {\n                            this.metadataReader.pos += 10;\n                            // Extract sample rate\n                            const word = this.metadataReader.readU32();\n                            const sampleRate = word >>> 12;\n                            const numberOfChannels = ((word >> 9) & 0b111) + 1;\n                            track.info.sampleRate = sampleRate;\n                            track.info.numberOfChannels = numberOfChannels;\n                            this.metadataReader.pos += 20;\n                        }\n                        else {\n                            // Simply skip ahead to the next block\n                            this.metadataReader.pos += metadataBlockLength;\n                        }\n                        if (flagAndType & LAST_METADATA_BLOCK_FLAG_MASK) {\n                            break;\n                        }\n                    }\n                    const endPos = this.metadataReader.pos;\n                    this.metadataReader.pos = startPos;\n                    const bytes = this.metadataReader.readBytes(endPos - startPos);\n                    const description = new Uint8Array(4 + bytes.byteLength);\n                    const view = new DataView(description.buffer);\n                    view.setUint32(0, 0x664c6143, false); // 'fLaC'\n                    description.set(bytes, 4);\n                    // Set the codec description to be 'fLaC' + all metadata blocks\n                    track.info.codecDescription = description;\n                }\n                ;\n                break;\n            case 'stts':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    this.metadataReader.pos += 4; // Version + flags\n                    const entryCount = this.metadataReader.readU32();\n                    let currentIndex = 0;\n                    let currentTimestamp = 0;\n                    for (let i = 0; i < entryCount; i++) {\n                        const sampleCount = this.metadataReader.readU32();\n                        const sampleDelta = this.metadataReader.readU32();\n                        track.sampleTable.sampleTimingEntries.push({\n                            startIndex: currentIndex,\n                            startDecodeTimestamp: currentTimestamp,\n                            count: sampleCount,\n                            delta: sampleDelta,\n                        });\n                        currentIndex += sampleCount;\n                        currentTimestamp += sampleCount * sampleDelta;\n                    }\n                }\n                ;\n                break;\n            case 'ctts':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    this.metadataReader.pos += 1 + 3; // Version + flags\n                    const entryCount = this.metadataReader.readU32();\n                    let sampleIndex = 0;\n                    for (let i = 0; i < entryCount; i++) {\n                        const sampleCount = this.metadataReader.readU32();\n                        const sampleOffset = this.metadataReader.readI32();\n                        track.sampleTable.sampleCompositionTimeOffsets.push({\n                            startIndex: sampleIndex,\n                            count: sampleCount,\n                            offset: sampleOffset,\n                        });\n                        sampleIndex += sampleCount;\n                    }\n                }\n                ;\n                break;\n            case 'stsz':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    this.metadataReader.pos += 4; // Version + flags\n                    const sampleSize = this.metadataReader.readU32();\n                    const sampleCount = this.metadataReader.readU32();\n                    if (sampleSize === 0) {\n                        for (let i = 0; i < sampleCount; i++) {\n                            const sampleSize = this.metadataReader.readU32();\n                            track.sampleTable.sampleSizes.push(sampleSize);\n                        }\n                    }\n                    else {\n                        track.sampleTable.sampleSizes.push(sampleSize);\n                    }\n                }\n                ;\n                break;\n            case 'stz2':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    this.metadataReader.pos += 4; // Version + flags\n                    this.metadataReader.pos += 3; // Reserved\n                    const fieldSize = this.metadataReader.readU8(); // in bits\n                    const sampleCount = this.metadataReader.readU32();\n                    const bytes = this.metadataReader.readBytes(Math.ceil(sampleCount * fieldSize / 8));\n                    const bitstream = new Bitstream(bytes);\n                    for (let i = 0; i < sampleCount; i++) {\n                        const sampleSize = bitstream.readBits(fieldSize);\n                        track.sampleTable.sampleSizes.push(sampleSize);\n                    }\n                }\n                ;\n                break;\n            case 'stss':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    this.metadataReader.pos += 4; // Version + flags\n                    track.sampleTable.keySampleIndices = [];\n                    const entryCount = this.metadataReader.readU32();\n                    for (let i = 0; i < entryCount; i++) {\n                        const sampleIndex = this.metadataReader.readU32() - 1; // Convert to 0-indexed\n                        track.sampleTable.keySampleIndices.push(sampleIndex);\n                    }\n                    if (track.sampleTable.keySampleIndices[0] !== 0) {\n                        // Some files don't mark the first sample a key sample, which is basically almost always incorrect.\n                        // Here, we correct for that mistake:\n                        track.sampleTable.keySampleIndices.unshift(0);\n                    }\n                }\n                ;\n                break;\n            case 'stsc':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    this.metadataReader.pos += 4;\n                    const entryCount = this.metadataReader.readU32();\n                    for (let i = 0; i < entryCount; i++) {\n                        const startChunkIndex = this.metadataReader.readU32() - 1; // Convert to 0-indexed\n                        const samplesPerChunk = this.metadataReader.readU32();\n                        const sampleDescriptionIndex = this.metadataReader.readU32();\n                        track.sampleTable.sampleToChunk.push({\n                            startSampleIndex: -1,\n                            startChunkIndex,\n                            samplesPerChunk,\n                            sampleDescriptionIndex,\n                        });\n                    }\n                    let startSampleIndex = 0;\n                    for (let i = 0; i < track.sampleTable.sampleToChunk.length; i++) {\n                        track.sampleTable.sampleToChunk[i].startSampleIndex = startSampleIndex;\n                        if (i < track.sampleTable.sampleToChunk.length - 1) {\n                            const nextChunk = track.sampleTable.sampleToChunk[i + 1];\n                            const chunkCount = nextChunk.startChunkIndex\n                                - track.sampleTable.sampleToChunk[i].startChunkIndex;\n                            startSampleIndex += chunkCount * track.sampleTable.sampleToChunk[i].samplesPerChunk;\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'stco':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    this.metadataReader.pos += 4; // Version + flags\n                    const entryCount = this.metadataReader.readU32();\n                    for (let i = 0; i < entryCount; i++) {\n                        const chunkOffset = this.metadataReader.readU32();\n                        track.sampleTable.chunkOffsets.push(chunkOffset);\n                    }\n                }\n                ;\n                break;\n            case 'co64':\n                {\n                    const track = this.currentTrack;\n                    assert(track);\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    this.metadataReader.pos += 4; // Version + flags\n                    const entryCount = this.metadataReader.readU32();\n                    for (let i = 0; i < entryCount; i++) {\n                        const chunkOffset = this.metadataReader.readU64();\n                        track.sampleTable.chunkOffsets.push(chunkOffset);\n                    }\n                }\n                ;\n                break;\n            case 'mvex':\n                {\n                    this.isFragmented = true;\n                    this.readContiguousBoxes(boxInfo.contentSize);\n                }\n                ;\n                break;\n            case 'mehd':\n                {\n                    const version = this.metadataReader.readU8();\n                    this.metadataReader.pos += 3; // Flags\n                    const fragmentDuration = version === 1 ? this.metadataReader.readU64() : this.metadataReader.readU32();\n                    this.movieDurationInTimescale = fragmentDuration;\n                }\n                ;\n                break;\n            case 'trex':\n                {\n                    this.metadataReader.pos += 4; // Version + flags\n                    const trackId = this.metadataReader.readU32();\n                    const defaultSampleDescriptionIndex = this.metadataReader.readU32();\n                    const defaultSampleDuration = this.metadataReader.readU32();\n                    const defaultSampleSize = this.metadataReader.readU32();\n                    const defaultSampleFlags = this.metadataReader.readU32();\n                    // We store these separately rather than in the tracks since the tracks may not exist yet\n                    this.fragmentTrackDefaults.push({\n                        trackId,\n                        defaultSampleDescriptionIndex,\n                        defaultSampleDuration,\n                        defaultSampleSize,\n                        defaultSampleFlags,\n                    });\n                }\n                ;\n                break;\n            case 'tfra':\n                {\n                    const version = this.metadataReader.readU8();\n                    this.metadataReader.pos += 3; // Flags\n                    const trackId = this.metadataReader.readU32();\n                    const track = this.tracks.find(x => x.id === trackId);\n                    if (!track) {\n                        break;\n                    }\n                    track.fragmentLookupTable = [];\n                    const word = this.metadataReader.readU32();\n                    const lengthSizeOfTrafNum = (word & 0b110000) >> 4;\n                    const lengthSizeOfTrunNum = (word & 0b001100) >> 2;\n                    const lengthSizeOfSampleNum = word & 0b000011;\n                    const x = this.metadataReader;\n                    const functions = [x.readU8.bind(x), x.readU16.bind(x), x.readU24.bind(x), x.readU32.bind(x)];\n                    const readTrafNum = functions[lengthSizeOfTrafNum];\n                    const readTrunNum = functions[lengthSizeOfTrunNum];\n                    const readSampleNum = functions[lengthSizeOfSampleNum];\n                    const numberOfEntries = this.metadataReader.readU32();\n                    for (let i = 0; i < numberOfEntries; i++) {\n                        const time = version === 1 ? this.metadataReader.readU64() : this.metadataReader.readU32();\n                        const moofOffset = version === 1 ? this.metadataReader.readU64() : this.metadataReader.readU32();\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        const trafNumber = readTrafNum();\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        const trunNumber = readTrunNum();\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        const sampleNumber = readSampleNum();\n                        track.fragmentLookupTable.push({\n                            timestamp: time,\n                            moofOffset,\n                        });\n                    }\n                }\n                ;\n                break;\n            case 'moof':\n                {\n                    this.currentFragment = {\n                        moofOffset: startPos,\n                        moofSize: boxInfo.totalSize,\n                        implicitBaseDataOffset: startPos,\n                        trackData: new Map(),\n                        dataStart: Infinity,\n                        dataEnd: 0,\n                        nextFragment: null,\n                        isKnownToBeFirstFragment: false,\n                    };\n                    this.readContiguousBoxes(boxInfo.contentSize);\n                    insertSorted(this.fragments, this.currentFragment, x => x.moofOffset);\n                    // Compute the byte range of the sample data in this fragment, so we can load the whole fragment at once\n                    for (const [, trackData] of this.currentFragment.trackData) {\n                        const firstSample = trackData.samples[0];\n                        const lastSample = last(trackData.samples);\n                        this.currentFragment.dataStart = Math.min(this.currentFragment.dataStart, firstSample.byteOffset);\n                        this.currentFragment.dataEnd = Math.max(this.currentFragment.dataEnd, lastSample.byteOffset + lastSample.byteSize);\n                    }\n                    this.currentFragment = null;\n                }\n                ;\n                break;\n            case 'traf':\n                {\n                    assert(this.currentFragment);\n                    this.readContiguousBoxes(boxInfo.contentSize);\n                    // It is possible that there is no current track, for example when we don't care about the track\n                    // referenced in the track fragment header.\n                    if (this.currentTrack) {\n                        const trackData = this.currentFragment.trackData.get(this.currentTrack.id);\n                        if (trackData) {\n                            // We know there is sample data for this track in this fragment, so let's add it to the\n                            // track's fragments:\n                            insertSorted(this.currentTrack.fragments, this.currentFragment, x => x.moofOffset);\n                            const hasKeyFrame = trackData.firstKeyFrameTimestamp !== null;\n                            if (hasKeyFrame) {\n                                insertSorted(this.currentTrack.fragmentsWithKeyFrame, this.currentFragment, x => x.moofOffset);\n                            }\n                            const { currentFragmentState } = this.currentTrack;\n                            assert(currentFragmentState);\n                            if (currentFragmentState.startTimestamp !== null) {\n                                offsetFragmentTrackDataByTimestamp(trackData, currentFragmentState.startTimestamp);\n                                trackData.startTimestampIsFinal = true;\n                            }\n                        }\n                        this.currentTrack.currentFragmentState = null;\n                        this.currentTrack = null;\n                    }\n                }\n                ;\n                break;\n            case 'tfhd':\n                {\n                    assert(this.currentFragment);\n                    this.metadataReader.pos += 1; // Version\n                    const flags = this.metadataReader.readU24();\n                    const baseDataOffsetPresent = Boolean(flags & 0x000001);\n                    const sampleDescriptionIndexPresent = Boolean(flags & 0x000002);\n                    const defaultSampleDurationPresent = Boolean(flags & 0x000008);\n                    const defaultSampleSizePresent = Boolean(flags & 0x000010);\n                    const defaultSampleFlagsPresent = Boolean(flags & 0x000020);\n                    const durationIsEmpty = Boolean(flags & 0x010000);\n                    const defaultBaseIsMoof = Boolean(flags & 0x020000);\n                    const trackId = this.metadataReader.readU32();\n                    const track = this.tracks.find(x => x.id === trackId);\n                    if (!track) {\n                        // We don't care about this track\n                        break;\n                    }\n                    const defaults = this.fragmentTrackDefaults.find(x => x.trackId === trackId);\n                    this.currentTrack = track;\n                    track.currentFragmentState = {\n                        baseDataOffset: this.currentFragment.implicitBaseDataOffset,\n                        sampleDescriptionIndex: defaults?.defaultSampleDescriptionIndex ?? null,\n                        defaultSampleDuration: defaults?.defaultSampleDuration ?? null,\n                        defaultSampleSize: defaults?.defaultSampleSize ?? null,\n                        defaultSampleFlags: defaults?.defaultSampleFlags ?? null,\n                        startTimestamp: null,\n                    };\n                    if (baseDataOffsetPresent) {\n                        track.currentFragmentState.baseDataOffset = this.metadataReader.readU64();\n                    }\n                    else if (defaultBaseIsMoof) {\n                        track.currentFragmentState.baseDataOffset = this.currentFragment.moofOffset;\n                    }\n                    if (sampleDescriptionIndexPresent) {\n                        track.currentFragmentState.sampleDescriptionIndex = this.metadataReader.readU32();\n                    }\n                    if (defaultSampleDurationPresent) {\n                        track.currentFragmentState.defaultSampleDuration = this.metadataReader.readU32();\n                    }\n                    if (defaultSampleSizePresent) {\n                        track.currentFragmentState.defaultSampleSize = this.metadataReader.readU32();\n                    }\n                    if (defaultSampleFlagsPresent) {\n                        track.currentFragmentState.defaultSampleFlags = this.metadataReader.readU32();\n                    }\n                    if (durationIsEmpty) {\n                        track.currentFragmentState.defaultSampleDuration = 0;\n                    }\n                }\n                ;\n                break;\n            case 'tfdt':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.currentFragmentState);\n                    // break;\n                    const version = this.metadataReader.readU8();\n                    this.metadataReader.pos += 3; // Flags\n                    const baseMediaDecodeTime = version === 0\n                        ? this.metadataReader.readU32()\n                        : this.metadataReader.readU64();\n                    track.currentFragmentState.startTimestamp = baseMediaDecodeTime;\n                }\n                ;\n                break;\n            case 'trun':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(this.currentFragment);\n                    assert(track.currentFragmentState);\n                    if (this.currentFragment.trackData.has(track.id)) {\n                        console.warn('Can\\'t have two trun boxes for the same track in one fragment. Ignoring...');\n                        break;\n                    }\n                    const version = this.metadataReader.readU8();\n                    const flags = this.metadataReader.readU24();\n                    const dataOffsetPresent = Boolean(flags & 0x000001);\n                    const firstSampleFlagsPresent = Boolean(flags & 0x000004);\n                    const sampleDurationPresent = Boolean(flags & 0x000100);\n                    const sampleSizePresent = Boolean(flags & 0x000200);\n                    const sampleFlagsPresent = Boolean(flags & 0x000400);\n                    const sampleCompositionTimeOffsetsPresent = Boolean(flags & 0x000800);\n                    const sampleCount = this.metadataReader.readU32();\n                    let dataOffset = track.currentFragmentState.baseDataOffset;\n                    if (dataOffsetPresent) {\n                        dataOffset += this.metadataReader.readI32();\n                    }\n                    let firstSampleFlags = null;\n                    if (firstSampleFlagsPresent) {\n                        firstSampleFlags = this.metadataReader.readU32();\n                    }\n                    let currentOffset = dataOffset;\n                    if (sampleCount === 0) {\n                        // Don't associate the fragment with the track if it has no samples, this simplifies other code\n                        this.currentFragment.implicitBaseDataOffset = currentOffset;\n                        break;\n                    }\n                    let currentTimestamp = 0;\n                    const trackData = {\n                        startTimestamp: 0,\n                        endTimestamp: 0,\n                        firstKeyFrameTimestamp: null,\n                        samples: [],\n                        presentationTimestamps: [],\n                        startTimestampIsFinal: false,\n                    };\n                    this.currentFragment.trackData.set(track.id, trackData);\n                    for (let i = 0; i < sampleCount; i++) {\n                        let sampleDuration;\n                        if (sampleDurationPresent) {\n                            sampleDuration = this.metadataReader.readU32();\n                        }\n                        else {\n                            assert(track.currentFragmentState.defaultSampleDuration !== null);\n                            sampleDuration = track.currentFragmentState.defaultSampleDuration;\n                        }\n                        let sampleSize;\n                        if (sampleSizePresent) {\n                            sampleSize = this.metadataReader.readU32();\n                        }\n                        else {\n                            assert(track.currentFragmentState.defaultSampleSize !== null);\n                            sampleSize = track.currentFragmentState.defaultSampleSize;\n                        }\n                        let sampleFlags;\n                        if (sampleFlagsPresent) {\n                            sampleFlags = this.metadataReader.readU32();\n                        }\n                        else {\n                            assert(track.currentFragmentState.defaultSampleFlags !== null);\n                            sampleFlags = track.currentFragmentState.defaultSampleFlags;\n                        }\n                        if (i === 0 && firstSampleFlags !== null) {\n                            sampleFlags = firstSampleFlags;\n                        }\n                        let sampleCompositionTimeOffset = 0;\n                        if (sampleCompositionTimeOffsetsPresent) {\n                            if (version === 0) {\n                                sampleCompositionTimeOffset = this.metadataReader.readU32();\n                            }\n                            else {\n                                sampleCompositionTimeOffset = this.metadataReader.readI32();\n                            }\n                        }\n                        const isKeyFrame = !(sampleFlags & 0x00010000);\n                        trackData.samples.push({\n                            presentationTimestamp: currentTimestamp + sampleCompositionTimeOffset,\n                            duration: sampleDuration,\n                            byteOffset: currentOffset,\n                            byteSize: sampleSize,\n                            isKeyFrame,\n                        });\n                        currentOffset += sampleSize;\n                        currentTimestamp += sampleDuration;\n                    }\n                    trackData.presentationTimestamps = trackData.samples\n                        .map((x, i) => ({ presentationTimestamp: x.presentationTimestamp, sampleIndex: i }))\n                        .sort((a, b) => a.presentationTimestamp - b.presentationTimestamp);\n                    for (let i = 0; i < trackData.presentationTimestamps.length; i++) {\n                        const currentEntry = trackData.presentationTimestamps[i];\n                        const currentSample = trackData.samples[currentEntry.sampleIndex];\n                        if (trackData.firstKeyFrameTimestamp === null && currentSample.isKeyFrame) {\n                            trackData.firstKeyFrameTimestamp = currentSample.presentationTimestamp;\n                        }\n                        if (i < trackData.presentationTimestamps.length - 1) {\n                            // Update sample durations based on presentation order\n                            const nextEntry = trackData.presentationTimestamps[i + 1];\n                            currentSample.duration = nextEntry.presentationTimestamp - currentEntry.presentationTimestamp;\n                        }\n                    }\n                    const firstSample = trackData.samples[trackData.presentationTimestamps[0].sampleIndex];\n                    const lastSample = trackData.samples[last(trackData.presentationTimestamps).sampleIndex];\n                    trackData.startTimestamp = firstSample.presentationTimestamp;\n                    trackData.endTimestamp = lastSample.presentationTimestamp + lastSample.duration;\n                    this.currentFragment.implicitBaseDataOffset = currentOffset;\n                }\n                ;\n                break;\n        }\n        this.metadataReader.pos = boxEndPos;\n        return true;\n    }\n}\nclass IsobmffTrackBacking {\n    constructor(internalTrack) {\n        this.internalTrack = internalTrack;\n        this.packetToSampleIndex = new WeakMap();\n        this.packetToFragmentLocation = new WeakMap();\n    }\n    getId() {\n        return this.internalTrack.id;\n    }\n    getCodec() {\n        throw new Error('Not implemented on base class.');\n    }\n    getLanguageCode() {\n        return this.internalTrack.languageCode;\n    }\n    getTimeResolution() {\n        return this.internalTrack.timescale;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    async getFirstTimestamp() {\n        const firstPacket = await this.getFirstPacket({ metadataOnly: true });\n        return firstPacket?.timestamp ?? 0;\n    }\n    async getFirstPacket(options) {\n        const regularPacket = await this.fetchPacketForSampleIndex(0, options);\n        if (regularPacket || !this.internalTrack.demuxer.isFragmented) {\n            // If there's a non-fragmented packet, always prefer that\n            return regularPacket;\n        }\n        return this.performFragmentedLookup(() => {\n            const startFragment = this.internalTrack.demuxer.fragments[0] ?? null;\n            if (startFragment?.isKnownToBeFirstFragment) {\n                // Walk from the very first fragment in the file until we find one with our track in it\n                let currentFragment = startFragment;\n                while (currentFragment) {\n                    const trackData = currentFragment.trackData.get(this.internalTrack.id);\n                    if (trackData) {\n                        return {\n                            fragmentIndex: binarySearchExact(this.internalTrack.fragments, currentFragment.moofOffset, x => x.moofOffset),\n                            sampleIndex: 0,\n                            correctSampleFound: true,\n                        };\n                    }\n                    currentFragment = currentFragment.nextFragment;\n                }\n            }\n            return {\n                fragmentIndex: -1,\n                sampleIndex: -1,\n                correctSampleFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the lookup entries\n        Infinity, options);\n    }\n    mapTimestampIntoTimescale(timestamp) {\n        // Do a little rounding to catch cases where the result is very close to an integer. If it is, it's likely\n        // that the number was originally an integer divided by the timescale. For stability, it's best\n        // to return the integer in this case.\n        return roundToPrecision(timestamp * this.internalTrack.timescale, 14) + this.internalTrack.editListOffset;\n    }\n    async getPacket(timestamp, options) {\n        const timestampInTimescale = this.mapTimestampIntoTimescale(timestamp);\n        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n        const sampleIndex = getSampleIndexForTimestamp(sampleTable, timestampInTimescale);\n        const regularPacket = await this.fetchPacketForSampleIndex(sampleIndex, options);\n        if (!sampleTableIsEmpty(sampleTable) || !this.internalTrack.demuxer.isFragmented) {\n            // Prefer the non-fragmented packet\n            return regularPacket;\n        }\n        return this.performFragmentedLookup(() => this.findSampleInFragmentsForTimestamp(timestampInTimescale), timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextPacket(packet, options) {\n        const regularSampleIndex = this.packetToSampleIndex.get(packet);\n        if (regularSampleIndex !== undefined) {\n            // Prefer the non-fragmented packet\n            return this.fetchPacketForSampleIndex(regularSampleIndex + 1, options);\n        }\n        const locationInFragment = this.packetToFragmentLocation.get(packet);\n        if (locationInFragment === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        const trackData = locationInFragment.fragment.trackData.get(this.internalTrack.id);\n        const fragmentIndex = binarySearchExact(this.internalTrack.fragments, locationInFragment.fragment.moofOffset, x => x.moofOffset);\n        assert(fragmentIndex !== -1);\n        return this.performFragmentedLookup(() => {\n            if (locationInFragment.sampleIndex + 1 < trackData.samples.length) {\n                // We can simply take the next sample in the fragment\n                return {\n                    fragmentIndex,\n                    sampleIndex: locationInFragment.sampleIndex + 1,\n                    correctSampleFound: true,\n                };\n            }\n            else {\n                // Walk the list of fragments until we find the next fragment for this track\n                let currentFragment = locationInFragment.fragment;\n                while (currentFragment.nextFragment) {\n                    currentFragment = currentFragment.nextFragment;\n                    const trackData = currentFragment.trackData.get(this.internalTrack.id);\n                    if (trackData) {\n                        const fragmentIndex = binarySearchExact(this.internalTrack.fragments, currentFragment.moofOffset, x => x.moofOffset);\n                        assert(fragmentIndex !== -1);\n                        return {\n                            fragmentIndex,\n                            sampleIndex: 0,\n                            correctSampleFound: true,\n                        };\n                    }\n                }\n                return {\n                    fragmentIndex,\n                    sampleIndex: -1,\n                    correctSampleFound: false,\n                };\n            }\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the lookup entries\n        Infinity, options);\n    }\n    async getKeyPacket(timestamp, options) {\n        const timestampInTimescale = this.mapTimestampIntoTimescale(timestamp);\n        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n        const sampleIndex = getSampleIndexForTimestamp(sampleTable, timestampInTimescale);\n        const keyFrameSampleIndex = sampleIndex === -1\n            ? -1\n            : getRelevantKeyframeIndexForSample(sampleTable, sampleIndex);\n        const regularPacket = await this.fetchPacketForSampleIndex(keyFrameSampleIndex, options);\n        if (!sampleTableIsEmpty(sampleTable) || !this.internalTrack.demuxer.isFragmented) {\n            // Prefer the non-fragmented packet\n            return regularPacket;\n        }\n        return this.performFragmentedLookup(() => this.findKeySampleInFragmentsForTimestamp(timestampInTimescale), timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextKeyPacket(packet, options) {\n        const regularSampleIndex = this.packetToSampleIndex.get(packet);\n        if (regularSampleIndex !== undefined) {\n            // Prefer the non-fragmented packet\n            const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n            const nextKeyFrameSampleIndex = getNextKeyframeIndexForSample(sampleTable, regularSampleIndex);\n            return this.fetchPacketForSampleIndex(nextKeyFrameSampleIndex, options);\n        }\n        const locationInFragment = this.packetToFragmentLocation.get(packet);\n        if (locationInFragment === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        const trackData = locationInFragment.fragment.trackData.get(this.internalTrack.id);\n        const fragmentIndex = binarySearchExact(this.internalTrack.fragments, locationInFragment.fragment.moofOffset, x => x.moofOffset);\n        assert(fragmentIndex !== -1);\n        return this.performFragmentedLookup(() => {\n            const nextKeyFrameIndex = trackData.samples.findIndex((x, i) => x.isKeyFrame && i > locationInFragment.sampleIndex);\n            if (nextKeyFrameIndex !== -1) {\n                // We can simply take the next key frame in the fragment\n                return {\n                    fragmentIndex,\n                    sampleIndex: nextKeyFrameIndex,\n                    correctSampleFound: true,\n                };\n            }\n            else {\n                // Walk the list of fragments until we find the next fragment for this track with a key frame\n                let currentFragment = locationInFragment.fragment;\n                while (currentFragment.nextFragment) {\n                    currentFragment = currentFragment.nextFragment;\n                    const trackData = currentFragment.trackData.get(this.internalTrack.id);\n                    if (trackData && trackData.firstKeyFrameTimestamp !== null) {\n                        const fragmentIndex = binarySearchExact(this.internalTrack.fragments, currentFragment.moofOffset, x => x.moofOffset);\n                        assert(fragmentIndex !== -1);\n                        const keyFrameIndex = trackData.samples.findIndex(x => x.isKeyFrame);\n                        assert(keyFrameIndex !== -1); // There must be one\n                        return {\n                            fragmentIndex,\n                            sampleIndex: keyFrameIndex,\n                            correctSampleFound: true,\n                        };\n                    }\n                }\n                return {\n                    fragmentIndex,\n                    sampleIndex: -1,\n                    correctSampleFound: false,\n                };\n            }\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the lookup entries\n        Infinity, options);\n    }\n    async fetchPacketForSampleIndex(sampleIndex, options) {\n        if (sampleIndex === -1) {\n            return null;\n        }\n        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n        const sampleInfo = getSampleInfo(sampleTable, sampleIndex);\n        if (!sampleInfo) {\n            return null;\n        }\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            // Load the entire chunk\n            await this.internalTrack.demuxer.chunkReader.reader.loadRange(sampleInfo.chunkOffset, sampleInfo.chunkOffset + sampleInfo.chunkSize);\n            this.internalTrack.demuxer.chunkReader.pos = sampleInfo.sampleOffset;\n            data = this.internalTrack.demuxer.chunkReader.readBytes(sampleInfo.sampleSize);\n        }\n        const timestamp = (sampleInfo.presentationTimestamp - this.internalTrack.editListOffset)\n            / this.internalTrack.timescale;\n        const duration = sampleInfo.duration / this.internalTrack.timescale;\n        const packet = new EncodedPacket(data, sampleInfo.isKeyFrame ? 'key' : 'delta', timestamp, duration, sampleIndex, sampleInfo.sampleSize);\n        this.packetToSampleIndex.set(packet, sampleIndex);\n        return packet;\n    }\n    async fetchPacketInFragment(fragment, sampleIndex, options) {\n        if (sampleIndex === -1) {\n            return null;\n        }\n        const trackData = fragment.trackData.get(this.internalTrack.id);\n        const fragmentSample = trackData.samples[sampleIndex];\n        assert(fragmentSample);\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            // Load the entire fragment\n            await this.internalTrack.demuxer.chunkReader.reader.loadRange(fragment.dataStart, fragment.dataEnd);\n            this.internalTrack.demuxer.chunkReader.pos = fragmentSample.byteOffset;\n            data = this.internalTrack.demuxer.chunkReader.readBytes(fragmentSample.byteSize);\n        }\n        const timestamp = (fragmentSample.presentationTimestamp - this.internalTrack.editListOffset)\n            / this.internalTrack.timescale;\n        const duration = fragmentSample.duration / this.internalTrack.timescale;\n        const packet = new EncodedPacket(data, fragmentSample.isKeyFrame ? 'key' : 'delta', timestamp, duration, fragment.moofOffset + sampleIndex, fragmentSample.byteSize);\n        this.packetToFragmentLocation.set(packet, { fragment, sampleIndex });\n        return packet;\n    }\n    findSampleInFragmentsForTimestamp(timestampInTimescale) {\n        const fragmentIndex = binarySearchLessOrEqual(\n        // This array is technically not sorted by start timestamp, but for any reasonable file, it basically is.\n        this.internalTrack.fragments, timestampInTimescale, x => x.trackData.get(this.internalTrack.id).startTimestamp);\n        let sampleIndex = -1;\n        let correctSampleFound = false;\n        if (fragmentIndex !== -1) {\n            const fragment = this.internalTrack.fragments[fragmentIndex];\n            const trackData = fragment.trackData.get(this.internalTrack.id);\n            const index = binarySearchLessOrEqual(trackData.presentationTimestamps, timestampInTimescale, x => x.presentationTimestamp);\n            assert(index !== -1);\n            sampleIndex = trackData.presentationTimestamps[index].sampleIndex;\n            correctSampleFound = timestampInTimescale < trackData.endTimestamp;\n        }\n        return { fragmentIndex, sampleIndex, correctSampleFound };\n    }\n    findKeySampleInFragmentsForTimestamp(timestampInTimescale) {\n        const indexInKeyFrameFragments = binarySearchLessOrEqual(\n        // This array is technically not sorted by start timestamp, but for any reasonable file, it basically is.\n        this.internalTrack.fragmentsWithKeyFrame, timestampInTimescale, x => x.trackData.get(this.internalTrack.id).startTimestamp);\n        let fragmentIndex = -1;\n        let sampleIndex = -1;\n        let correctSampleFound = false;\n        if (indexInKeyFrameFragments !== -1) {\n            const fragment = this.internalTrack.fragmentsWithKeyFrame[indexInKeyFrameFragments];\n            // Now, let's find the actual index of the fragment in the list of ALL fragments, not just key frame ones\n            fragmentIndex = binarySearchExact(this.internalTrack.fragments, fragment.moofOffset, x => x.moofOffset);\n            assert(fragmentIndex !== -1);\n            const trackData = fragment.trackData.get(this.internalTrack.id);\n            const index = findLastIndex(trackData.presentationTimestamps, (x) => {\n                const sample = trackData.samples[x.sampleIndex];\n                return sample.isKeyFrame && x.presentationTimestamp <= timestampInTimescale;\n            });\n            assert(index !== -1); // It's a key frame fragment, so there must be a key frame\n            const entry = trackData.presentationTimestamps[index];\n            sampleIndex = entry.sampleIndex;\n            correctSampleFound = timestampInTimescale < trackData.endTimestamp;\n        }\n        return { fragmentIndex, sampleIndex, correctSampleFound };\n    }\n    /** Looks for a packet in the fragments while trying to load as few fragments as possible to retrieve it. */\n    async performFragmentedLookup(\n    // This function returns the best-matching sample that is currently loaded. Based on this information, we know\n    // which fragments we need to load to find the actual match.\n    getBestMatch, \n    // The timestamp with which we can search the lookup table\n    searchTimestamp, \n    // The timestamp for which we know the correct sample will not come after it\n    latestTimestamp, options) {\n        const demuxer = this.internalTrack.demuxer;\n        const release = await demuxer.fragmentLookupMutex.acquire(); // The algorithm requires exclusivity\n        try {\n            const { fragmentIndex, sampleIndex, correctSampleFound } = getBestMatch();\n            if (correctSampleFound) {\n                // The correct sample already exists, easy path.\n                const fragment = this.internalTrack.fragments[fragmentIndex];\n                return this.fetchPacketInFragment(fragment, sampleIndex, options);\n            }\n            const metadataReader = demuxer.metadataReader;\n            const sourceSize = await metadataReader.reader.source.getSize();\n            let prevFragment = null;\n            let bestFragmentIndex = fragmentIndex;\n            let bestSampleIndex = sampleIndex;\n            // Search for a lookup entry; this way, we won't need to start searching from the start of the file\n            // but can jump right into the correct fragment (or at least nearby).\n            const lookupEntryIndex = this.internalTrack.fragmentLookupTable\n                ? binarySearchLessOrEqual(this.internalTrack.fragmentLookupTable, searchTimestamp, x => x.timestamp)\n                : -1;\n            const lookupEntry = lookupEntryIndex !== -1\n                ? this.internalTrack.fragmentLookupTable[lookupEntryIndex]\n                : null;\n            let nextFragmentIsFirstFragment = false;\n            if (fragmentIndex === -1) {\n                metadataReader.pos = lookupEntry?.moofOffset ?? 0;\n                nextFragmentIsFirstFragment = metadataReader.pos === 0;\n            }\n            else {\n                const fragment = this.internalTrack.fragments[fragmentIndex];\n                if (!lookupEntry || fragment.moofOffset >= lookupEntry.moofOffset) {\n                    metadataReader.pos = fragment.moofOffset + fragment.moofSize;\n                    prevFragment = fragment;\n                }\n                else {\n                    // Use the lookup entry\n                    metadataReader.pos = lookupEntry.moofOffset;\n                }\n            }\n            while (metadataReader.pos < sourceSize) {\n                if (prevFragment) {\n                    const trackData = prevFragment.trackData.get(this.internalTrack.id);\n                    if (trackData && trackData.startTimestamp > latestTimestamp) {\n                        // We're already past the upper bound, no need to keep searching\n                        break;\n                    }\n                    if (prevFragment.nextFragment) {\n                        // Skip ahead quickly without needing to read the file again\n                        metadataReader.pos = prevFragment.nextFragment.moofOffset + prevFragment.nextFragment.moofSize;\n                        prevFragment = prevFragment.nextFragment;\n                        continue;\n                    }\n                }\n                // Load the header\n                await metadataReader.reader.loadRange(metadataReader.pos, metadataReader.pos + MAX_BOX_HEADER_SIZE);\n                const startPos = metadataReader.pos;\n                const boxInfo = metadataReader.readBoxHeader();\n                if (!boxInfo) {\n                    break;\n                }\n                if (boxInfo.name === 'moof') {\n                    const index = binarySearchExact(demuxer.fragments, startPos, x => x.moofOffset);\n                    let fragment;\n                    if (index === -1) {\n                        // This is the first time we've seen this fragment\n                        metadataReader.pos = startPos;\n                        fragment = await demuxer.readFragment();\n                    }\n                    else {\n                        // We already know this fragment\n                        fragment = demuxer.fragments[index];\n                    }\n                    // Even if we already know the fragment, we might not yet know its predecessor, so always do this\n                    if (prevFragment)\n                        prevFragment.nextFragment = fragment;\n                    prevFragment = fragment;\n                    if (nextFragmentIsFirstFragment) {\n                        fragment.isKnownToBeFirstFragment = true;\n                        nextFragmentIsFirstFragment = false;\n                    }\n                    const { fragmentIndex, sampleIndex, correctSampleFound } = getBestMatch();\n                    if (correctSampleFound) {\n                        const fragment = this.internalTrack.fragments[fragmentIndex];\n                        return this.fetchPacketInFragment(fragment, sampleIndex, options);\n                    }\n                    if (fragmentIndex !== -1) {\n                        bestFragmentIndex = fragmentIndex;\n                        bestSampleIndex = sampleIndex;\n                    }\n                }\n                metadataReader.pos = startPos + boxInfo.totalSize;\n            }\n            let result = null;\n            const bestFragment = bestFragmentIndex !== -1 ? this.internalTrack.fragments[bestFragmentIndex] : null;\n            if (bestFragment) {\n                // If we finished looping but didn't find a perfect match, still return the best match we found\n                result = await this.fetchPacketInFragment(bestFragment, bestSampleIndex, options);\n            }\n            // Catch faulty lookup table entries\n            if (!result && lookupEntry && (!bestFragment || bestFragment.moofOffset < lookupEntry.moofOffset)) {\n                // The lookup table entry lied to us! We found a lookup entry but no fragment there that satisfied\n                // the match. In this case, let's search again but using the lookup entry before that.\n                const previousLookupEntry = this.internalTrack.fragmentLookupTable[lookupEntryIndex - 1];\n                const newSearchTimestamp = previousLookupEntry?.timestamp ?? -Infinity;\n                return this.performFragmentedLookup(getBestMatch, newSearchTimestamp, latestTimestamp, options);\n            }\n            return result;\n        }\n        finally {\n            release();\n        }\n    }\n}\nclass IsobmffVideoTrackBacking extends IsobmffTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfigPromise = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getCodedWidth() {\n        return this.internalTrack.info.width;\n    }\n    getCodedHeight() {\n        return this.internalTrack.info.height;\n    }\n    getRotation() {\n        return this.internalTrack.rotation;\n    }\n    async getColorSpace() {\n        return {\n            primaries: this.internalTrack.info.colorSpace?.primaries,\n            transfer: this.internalTrack.info.colorSpace?.transfer,\n            matrix: this.internalTrack.info.colorSpace?.matrix,\n            fullRange: this.internalTrack.info.colorSpace?.fullRange,\n        };\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfigPromise ??= (async () => {\n            if (this.internalTrack.info.codec === 'vp9' && !this.internalTrack.info.vp9CodecInfo) {\n                const firstPacket = await this.getFirstPacket({});\n                this.internalTrack.info.vp9CodecInfo = firstPacket && extractVp9CodecInfoFromPacket(firstPacket.data);\n            }\n            else if (this.internalTrack.info.codec === 'av1' && !this.internalTrack.info.av1CodecInfo) {\n                const firstPacket = await this.getFirstPacket({});\n                this.internalTrack.info.av1CodecInfo = firstPacket && extractAv1CodecInfoFromPacket(firstPacket.data);\n            }\n            return {\n                codec: extractVideoCodecString(this.internalTrack.info),\n                codedWidth: this.internalTrack.info.width,\n                codedHeight: this.internalTrack.info.height,\n                description: this.internalTrack.info.codecDescription ?? undefined,\n                colorSpace: this.internalTrack.info.colorSpace ?? undefined,\n            };\n        })();\n    }\n}\nclass IsobmffAudioTrackBacking extends IsobmffTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfig = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getNumberOfChannels() {\n        return this.internalTrack.info.numberOfChannels;\n    }\n    getSampleRate() {\n        return this.internalTrack.info.sampleRate;\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfig ??= {\n            codec: extractAudioCodecString(this.internalTrack.info),\n            numberOfChannels: this.internalTrack.info.numberOfChannels,\n            sampleRate: this.internalTrack.info.sampleRate,\n            description: this.internalTrack.info.codecDescription ?? undefined,\n        };\n    }\n}\nconst getSampleIndexForTimestamp = (sampleTable, timescaleUnits) => {\n    if (sampleTable.presentationTimestamps) {\n        const index = binarySearchLessOrEqual(sampleTable.presentationTimestamps, timescaleUnits, x => x.presentationTimestamp);\n        if (index === -1) {\n            return -1;\n        }\n        return sampleTable.presentationTimestamps[index].sampleIndex;\n    }\n    else {\n        const index = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, timescaleUnits, x => x.startDecodeTimestamp);\n        if (index === -1) {\n            return -1;\n        }\n        const entry = sampleTable.sampleTimingEntries[index];\n        return entry.startIndex\n            + Math.min(Math.floor((timescaleUnits - entry.startDecodeTimestamp) / entry.delta), entry.count - 1);\n    }\n};\nconst getSampleInfo = (sampleTable, sampleIndex) => {\n    const timingEntryIndex = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, sampleIndex, x => x.startIndex);\n    const timingEntry = sampleTable.sampleTimingEntries[timingEntryIndex];\n    if (!timingEntry || timingEntry.startIndex + timingEntry.count <= sampleIndex) {\n        return null;\n    }\n    const decodeTimestamp = timingEntry.startDecodeTimestamp\n        + (sampleIndex - timingEntry.startIndex) * timingEntry.delta;\n    let presentationTimestamp = decodeTimestamp;\n    const offsetEntryIndex = binarySearchLessOrEqual(sampleTable.sampleCompositionTimeOffsets, sampleIndex, x => x.startIndex);\n    const offsetEntry = sampleTable.sampleCompositionTimeOffsets[offsetEntryIndex];\n    if (offsetEntry && sampleIndex - offsetEntry.startIndex < offsetEntry.count) {\n        presentationTimestamp += offsetEntry.offset;\n    }\n    const sampleSize = sampleTable.sampleSizes[Math.min(sampleIndex, sampleTable.sampleSizes.length - 1)];\n    const chunkEntryIndex = binarySearchLessOrEqual(sampleTable.sampleToChunk, sampleIndex, x => x.startSampleIndex);\n    const chunkEntry = sampleTable.sampleToChunk[chunkEntryIndex];\n    assert(chunkEntry);\n    const chunkIndex = chunkEntry.startChunkIndex\n        + Math.floor((sampleIndex - chunkEntry.startSampleIndex) / chunkEntry.samplesPerChunk);\n    const chunkOffset = sampleTable.chunkOffsets[chunkIndex];\n    const startSampleIndexOfChunk = chunkEntry.startSampleIndex\n        + (chunkIndex - chunkEntry.startChunkIndex) * chunkEntry.samplesPerChunk;\n    let chunkSize = 0;\n    let sampleOffset = chunkOffset;\n    if (sampleTable.sampleSizes.length === 1) {\n        sampleOffset += sampleSize * (sampleIndex - startSampleIndexOfChunk);\n        chunkSize += sampleSize * chunkEntry.samplesPerChunk;\n    }\n    else {\n        for (let i = startSampleIndexOfChunk; i < startSampleIndexOfChunk + chunkEntry.samplesPerChunk; i++) {\n            const sampleSize = sampleTable.sampleSizes[i];\n            if (i < sampleIndex) {\n                sampleOffset += sampleSize;\n            }\n            chunkSize += sampleSize;\n        }\n    }\n    let duration = timingEntry.delta;\n    if (sampleTable.presentationTimestamps) {\n        // In order to accurately compute the duration, we need to take the duration to the next sample in presentation\n        // order, not in decode order\n        const presentationIndex = sampleTable.presentationTimestampIndexMap[sampleIndex];\n        assert(presentationIndex !== undefined);\n        if (presentationIndex < sampleTable.presentationTimestamps.length - 1) {\n            const nextEntry = sampleTable.presentationTimestamps[presentationIndex + 1];\n            const nextPresentationTimestamp = nextEntry.presentationTimestamp;\n            duration = nextPresentationTimestamp - presentationTimestamp;\n        }\n    }\n    return {\n        presentationTimestamp,\n        duration,\n        sampleOffset,\n        sampleSize,\n        chunkOffset,\n        chunkSize,\n        isKeyFrame: sampleTable.keySampleIndices\n            ? binarySearchExact(sampleTable.keySampleIndices, sampleIndex, x => x) !== -1\n            : true,\n    };\n};\nconst getRelevantKeyframeIndexForSample = (sampleTable, sampleIndex) => {\n    if (!sampleTable.keySampleIndices) {\n        return sampleIndex;\n    }\n    const index = binarySearchLessOrEqual(sampleTable.keySampleIndices, sampleIndex, x => x);\n    return sampleTable.keySampleIndices[index] ?? -1;\n};\nconst getNextKeyframeIndexForSample = (sampleTable, sampleIndex) => {\n    if (!sampleTable.keySampleIndices) {\n        return sampleIndex + 1;\n    }\n    const index = binarySearchLessOrEqual(sampleTable.keySampleIndices, sampleIndex, x => x);\n    return sampleTable.keySampleIndices[index + 1] ?? -1;\n};\nconst offsetFragmentTrackDataByTimestamp = (trackData, timestamp) => {\n    trackData.startTimestamp += timestamp;\n    trackData.endTimestamp += timestamp;\n    for (const sample of trackData.samples) {\n        sample.presentationTimestamp += timestamp;\n    }\n    for (const entry of trackData.presentationTimestamps) {\n        entry.presentationTimestamp += timestamp;\n    }\n};\n/** Extracts the rotation component from a transformation matrix, in degrees. */\nconst extractRotationFromMatrix = (matrix) => {\n    const [m11, , , m21] = matrix;\n    const scaleX = Math.hypot(m11, m21);\n    const cosTheta = m11 / scaleX;\n    const sinTheta = m21 / scaleX;\n    // Invert the rotation because matrices are post-multiplied in ISOBMFF\n    return -Math.atan2(sinTheta, cosTheta) * (180 / Math.PI);\n};\nconst sampleTableIsEmpty = (sampleTable) => {\n    return sampleTable.sampleSizes.length === 0;\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8273, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/matroska/ebml.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLFloat32 {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLFloat64 {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLSignedInt {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Defines some of the EBML IDs used by Matroska files. */\nexport var EBMLId;\n(function (EBMLId) {\n    EBMLId[EBMLId[\"EBML\"] = 440786851] = \"EBML\";\n    EBMLId[EBMLId[\"EBMLVersion\"] = 17030] = \"EBMLVersion\";\n    EBMLId[EBMLId[\"EBMLReadVersion\"] = 17143] = \"EBMLReadVersion\";\n    EBMLId[EBMLId[\"EBMLMaxIDLength\"] = 17138] = \"EBMLMaxIDLength\";\n    EBMLId[EBMLId[\"EBMLMaxSizeLength\"] = 17139] = \"EBMLMaxSizeLength\";\n    EBMLId[EBMLId[\"DocType\"] = 17026] = \"DocType\";\n    EBMLId[EBMLId[\"DocTypeVersion\"] = 17031] = \"DocTypeVersion\";\n    EBMLId[EBMLId[\"DocTypeReadVersion\"] = 17029] = \"DocTypeReadVersion\";\n    EBMLId[EBMLId[\"SeekHead\"] = 290298740] = \"SeekHead\";\n    EBMLId[EBMLId[\"Seek\"] = 19899] = \"Seek\";\n    EBMLId[EBMLId[\"SeekID\"] = 21419] = \"SeekID\";\n    EBMLId[EBMLId[\"SeekPosition\"] = 21420] = \"SeekPosition\";\n    EBMLId[EBMLId[\"Duration\"] = 17545] = \"Duration\";\n    EBMLId[EBMLId[\"Info\"] = 357149030] = \"Info\";\n    EBMLId[EBMLId[\"TimestampScale\"] = 2807729] = \"TimestampScale\";\n    EBMLId[EBMLId[\"MuxingApp\"] = 19840] = \"MuxingApp\";\n    EBMLId[EBMLId[\"WritingApp\"] = 22337] = \"WritingApp\";\n    EBMLId[EBMLId[\"Tracks\"] = 374648427] = \"Tracks\";\n    EBMLId[EBMLId[\"TrackEntry\"] = 174] = \"TrackEntry\";\n    EBMLId[EBMLId[\"TrackNumber\"] = 215] = \"TrackNumber\";\n    EBMLId[EBMLId[\"TrackUID\"] = 29637] = \"TrackUID\";\n    EBMLId[EBMLId[\"TrackType\"] = 131] = \"TrackType\";\n    EBMLId[EBMLId[\"FlagEnabled\"] = 185] = \"FlagEnabled\";\n    EBMLId[EBMLId[\"FlagDefault\"] = 136] = \"FlagDefault\";\n    EBMLId[EBMLId[\"FlagForced\"] = 21930] = \"FlagForced\";\n    EBMLId[EBMLId[\"FlagLacing\"] = 156] = \"FlagLacing\";\n    EBMLId[EBMLId[\"Language\"] = 2274716] = \"Language\";\n    EBMLId[EBMLId[\"CodecID\"] = 134] = \"CodecID\";\n    EBMLId[EBMLId[\"CodecPrivate\"] = 25506] = \"CodecPrivate\";\n    EBMLId[EBMLId[\"CodecDelay\"] = 22186] = \"CodecDelay\";\n    EBMLId[EBMLId[\"SeekPreRoll\"] = 22203] = \"SeekPreRoll\";\n    EBMLId[EBMLId[\"DefaultDuration\"] = 2352003] = \"DefaultDuration\";\n    EBMLId[EBMLId[\"Video\"] = 224] = \"Video\";\n    EBMLId[EBMLId[\"PixelWidth\"] = 176] = \"PixelWidth\";\n    EBMLId[EBMLId[\"PixelHeight\"] = 186] = \"PixelHeight\";\n    EBMLId[EBMLId[\"Audio\"] = 225] = \"Audio\";\n    EBMLId[EBMLId[\"SamplingFrequency\"] = 181] = \"SamplingFrequency\";\n    EBMLId[EBMLId[\"Channels\"] = 159] = \"Channels\";\n    EBMLId[EBMLId[\"BitDepth\"] = 25188] = \"BitDepth\";\n    EBMLId[EBMLId[\"Segment\"] = 408125543] = \"Segment\";\n    EBMLId[EBMLId[\"SimpleBlock\"] = 163] = \"SimpleBlock\";\n    EBMLId[EBMLId[\"BlockGroup\"] = 160] = \"BlockGroup\";\n    EBMLId[EBMLId[\"Block\"] = 161] = \"Block\";\n    EBMLId[EBMLId[\"BlockAdditions\"] = 30113] = \"BlockAdditions\";\n    EBMLId[EBMLId[\"BlockMore\"] = 166] = \"BlockMore\";\n    EBMLId[EBMLId[\"BlockAdditional\"] = 165] = \"BlockAdditional\";\n    EBMLId[EBMLId[\"BlockAddID\"] = 238] = \"BlockAddID\";\n    EBMLId[EBMLId[\"BlockDuration\"] = 155] = \"BlockDuration\";\n    EBMLId[EBMLId[\"ReferenceBlock\"] = 251] = \"ReferenceBlock\";\n    EBMLId[EBMLId[\"Cluster\"] = 524531317] = \"Cluster\";\n    EBMLId[EBMLId[\"Timestamp\"] = 231] = \"Timestamp\";\n    EBMLId[EBMLId[\"Cues\"] = 475249515] = \"Cues\";\n    EBMLId[EBMLId[\"CuePoint\"] = 187] = \"CuePoint\";\n    EBMLId[EBMLId[\"CueTime\"] = 179] = \"CueTime\";\n    EBMLId[EBMLId[\"CueTrackPositions\"] = 183] = \"CueTrackPositions\";\n    EBMLId[EBMLId[\"CueTrack\"] = 247] = \"CueTrack\";\n    EBMLId[EBMLId[\"CueClusterPosition\"] = 241] = \"CueClusterPosition\";\n    EBMLId[EBMLId[\"Colour\"] = 21936] = \"Colour\";\n    EBMLId[EBMLId[\"MatrixCoefficients\"] = 21937] = \"MatrixCoefficients\";\n    EBMLId[EBMLId[\"TransferCharacteristics\"] = 21946] = \"TransferCharacteristics\";\n    EBMLId[EBMLId[\"Primaries\"] = 21947] = \"Primaries\";\n    EBMLId[EBMLId[\"Range\"] = 21945] = \"Range\";\n    EBMLId[EBMLId[\"Projection\"] = 30320] = \"Projection\";\n    EBMLId[EBMLId[\"ProjectionType\"] = 30321] = \"ProjectionType\";\n    EBMLId[EBMLId[\"ProjectionPoseRoll\"] = 30325] = \"ProjectionPoseRoll\";\n    EBMLId[EBMLId[\"Attachments\"] = 423732329] = \"Attachments\";\n    EBMLId[EBMLId[\"Chapters\"] = 272869232] = \"Chapters\";\n    EBMLId[EBMLId[\"Tags\"] = 307544935] = \"Tags\";\n})(EBMLId || (EBMLId = {}));\nexport const LEVEL_0_EBML_IDS = [\n    EBMLId.EBML,\n    EBMLId.Segment,\n];\n// All the stuff that can appear in a segment, basically\nexport const LEVEL_1_EBML_IDS = [\n    EBMLId.SeekHead,\n    EBMLId.Info,\n    EBMLId.Cluster,\n    EBMLId.Tracks,\n    EBMLId.Cues,\n    EBMLId.Attachments,\n    EBMLId.Chapters,\n    EBMLId.Tags,\n];\nexport const LEVEL_0_AND_1_EBML_IDS = [\n    ...LEVEL_0_EBML_IDS,\n    ...LEVEL_1_EBML_IDS,\n];\nexport const measureUnsignedInt = (value) => {\n    if (value < (1 << 8)) {\n        return 1;\n    }\n    else if (value < (1 << 16)) {\n        return 2;\n    }\n    else if (value < (1 << 24)) {\n        return 3;\n    }\n    else if (value < 2 ** 32) {\n        return 4;\n    }\n    else if (value < 2 ** 40) {\n        return 5;\n    }\n    else {\n        return 6;\n    }\n};\nexport const measureSignedInt = (value) => {\n    if (value >= -(1 << 6) && value < (1 << 6)) {\n        return 1;\n    }\n    else if (value >= -(1 << 13) && value < (1 << 13)) {\n        return 2;\n    }\n    else if (value >= -(1 << 20) && value < (1 << 20)) {\n        return 3;\n    }\n    else if (value >= -(1 << 27) && value < (1 << 27)) {\n        return 4;\n    }\n    else if (value >= -(2 ** 34) && value < 2 ** 34) {\n        return 5;\n    }\n    else {\n        return 6;\n    }\n};\nexport const measureVarInt = (value) => {\n    if (value < (1 << 7) - 1) {\n        /** Top bit is set, leaving 7 bits to hold the integer, but we can't store\n         * 127 because \"all bits set to one\" is a reserved value. Same thing for the\n         * other cases below:\n         */\n        return 1;\n    }\n    else if (value < (1 << 14) - 1) {\n        return 2;\n    }\n    else if (value < (1 << 21) - 1) {\n        return 3;\n    }\n    else if (value < (1 << 28) - 1) {\n        return 4;\n    }\n    else if (value < 2 ** 35 - 1) {\n        return 5;\n    }\n    else if (value < 2 ** 42 - 1) {\n        return 6;\n    }\n    else {\n        throw new Error('EBML varint size not supported ' + value);\n    }\n};\nexport class EBMLWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n        /**\n         * Stores the position from the start of the file to where EBML elements have been written. This is used to\n         * rewrite/edit elements that were already added before, and to measure sizes of things.\n         */\n        this.offsets = new WeakMap();\n        /** Same as offsets, but stores position where the element's data starts (after ID and size fields). */\n        this.dataOffsets = new WeakMap();\n    }\n    writeByte(value) {\n        this.helperView.setUint8(0, value);\n        this.writer.write(this.helper.subarray(0, 1));\n    }\n    writeFloat32(value) {\n        this.helperView.setFloat32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeFloat64(value) {\n        this.helperView.setFloat64(0, value, false);\n        this.writer.write(this.helper);\n    }\n    writeUnsignedInt(value, width = measureUnsignedInt(value)) {\n        let pos = 0;\n        // Each case falls through:\n        switch (width) {\n            case 6:\n                // Need to use division to access >32 bits of floating point var\n                this.helperView.setUint8(pos++, (value / 2 ** 40) | 0);\n            // eslint-disable-next-line no-fallthrough\n            case 5:\n                this.helperView.setUint8(pos++, (value / 2 ** 32) | 0);\n            // eslint-disable-next-line no-fallthrough\n            case 4:\n                this.helperView.setUint8(pos++, value >> 24);\n            // eslint-disable-next-line no-fallthrough\n            case 3:\n                this.helperView.setUint8(pos++, value >> 16);\n            // eslint-disable-next-line no-fallthrough\n            case 2:\n                this.helperView.setUint8(pos++, value >> 8);\n            // eslint-disable-next-line no-fallthrough\n            case 1:\n                this.helperView.setUint8(pos++, value);\n                break;\n            default:\n                throw new Error('Bad unsigned int size ' + width);\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeSignedInt(value, width = measureSignedInt(value)) {\n        if (value < 0) {\n            // Two's complement stuff\n            value += 2 ** (width * 8);\n        }\n        this.writeUnsignedInt(value, width);\n    }\n    writeVarInt(value, width = measureVarInt(value)) {\n        let pos = 0;\n        switch (width) {\n            case 1:\n                this.helperView.setUint8(pos++, (1 << 7) | value);\n                break;\n            case 2:\n                this.helperView.setUint8(pos++, (1 << 6) | (value >> 8));\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 3:\n                this.helperView.setUint8(pos++, (1 << 5) | (value >> 16));\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 4:\n                this.helperView.setUint8(pos++, (1 << 4) | (value >> 24));\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 5:\n                /**\n                 * JavaScript converts its doubles to 32-bit integers for bitwise\n                 * operations, so we need to do a division by 2^32 instead of a\n                 * right-shift of 32 to retain those top 3 bits\n                 */\n                this.helperView.setUint8(pos++, (1 << 3) | ((value / 2 ** 32) & 0x7));\n                this.helperView.setUint8(pos++, value >> 24);\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 6:\n                this.helperView.setUint8(pos++, (1 << 2) | ((value / 2 ** 40) & 0x3));\n                this.helperView.setUint8(pos++, (value / 2 ** 32) | 0);\n                this.helperView.setUint8(pos++, value >> 24);\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            default:\n                throw new Error('Bad EBML varint size ' + width);\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeAsciiString(str) {\n        this.writer.write(new Uint8Array(str.split('').map(x => x.charCodeAt(0))));\n    }\n    writeEBML(data) {\n        if (data === null)\n            return;\n        if (data instanceof Uint8Array) {\n            this.writer.write(data);\n        }\n        else if (Array.isArray(data)) {\n            for (const elem of data) {\n                this.writeEBML(elem);\n            }\n        }\n        else {\n            this.offsets.set(data, this.writer.getPos());\n            this.writeUnsignedInt(data.id); // ID field\n            if (Array.isArray(data.data)) {\n                const sizePos = this.writer.getPos();\n                const sizeSize = data.size === -1 ? 1 : (data.size ?? 4);\n                if (data.size === -1) {\n                    // Write the reserved all-one-bits marker for unknown/unbounded size.\n                    this.writeByte(0xff);\n                }\n                else {\n                    this.writer.seek(this.writer.getPos() + sizeSize);\n                }\n                const startPos = this.writer.getPos();\n                this.dataOffsets.set(data, startPos);\n                this.writeEBML(data.data);\n                if (data.size !== -1) {\n                    const size = this.writer.getPos() - startPos;\n                    const endPos = this.writer.getPos();\n                    this.writer.seek(sizePos);\n                    this.writeVarInt(size, sizeSize);\n                    this.writer.seek(endPos);\n                }\n            }\n            else if (typeof data.data === 'number') {\n                const size = data.size ?? measureUnsignedInt(data.data);\n                this.writeVarInt(size);\n                this.writeUnsignedInt(data.data, size);\n            }\n            else if (typeof data.data === 'string') {\n                this.writeVarInt(data.data.length);\n                this.writeAsciiString(data.data);\n            }\n            else if (data.data instanceof Uint8Array) {\n                this.writeVarInt(data.data.byteLength, data.size);\n                this.writer.write(data.data);\n            }\n            else if (data.data instanceof EBMLFloat32) {\n                this.writeVarInt(4);\n                this.writeFloat32(data.data.value);\n            }\n            else if (data.data instanceof EBMLFloat64) {\n                this.writeVarInt(8);\n                this.writeFloat64(data.data.value);\n            }\n            else if (data.data instanceof EBMLSignedInt) {\n                const size = data.size ?? measureSignedInt(data.data.value);\n                this.writeVarInt(size);\n                this.writeSignedInt(data.data.value, size);\n            }\n        }\n    }\n}\nconst MAX_VAR_INT_SIZE = 8;\nexport const MIN_HEADER_SIZE = 2; // 1-byte ID and 1-byte size\nexport const MAX_HEADER_SIZE = 2 * MAX_VAR_INT_SIZE; // 8-byte ID and 8-byte size\nexport class EBMLReader {\n    constructor(reader) {\n        this.reader = reader;\n        this.pos = 0;\n    }\n    readBytes(length) {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + length);\n        this.pos += length;\n        return new Uint8Array(view.buffer, offset, length);\n    }\n    readU8() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 1);\n        this.pos++;\n        return view.getUint8(offset);\n    }\n    readS16() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 2);\n        this.pos += 2;\n        return view.getInt16(offset, false);\n    }\n    readVarIntSize() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 1);\n        const firstByte = view.getUint8(offset);\n        if (firstByte === 0) {\n            return null; // Invalid VINT\n        }\n        let width = 1;\n        let mask = 0x80;\n        while ((firstByte & mask) === 0) {\n            width++;\n            mask >>= 1;\n        }\n        return width;\n    }\n    readVarInt() {\n        // Read the first byte to determine the width of the variable-length integer\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 1);\n        const firstByte = view.getUint8(offset);\n        if (firstByte === 0) {\n            return null; // Invalid VINT\n        }\n        // Find the position of VINT_MARKER, which determines the width\n        let width = 1;\n        let mask = 1 << 7;\n        while ((firstByte & mask) === 0) {\n            width++;\n            mask >>= 1;\n        }\n        const { view: fullView, offset: fullOffset } = this.reader.getViewAndOffset(this.pos, this.pos + width);\n        // First byte's value needs the marker bit cleared\n        let value = firstByte & (mask - 1);\n        // Read remaining bytes\n        for (let i = 1; i < width; i++) {\n            value *= 1 << 8;\n            value += fullView.getUint8(fullOffset + i);\n        }\n        this.pos += width;\n        return value;\n    }\n    readUnsignedInt(width) {\n        if (width < 1 || width > 8) {\n            throw new Error('Bad unsigned int size ' + width);\n        }\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + width);\n        let value = 0;\n        // Read bytes from most significant to least significant\n        for (let i = 0; i < width; i++) {\n            value *= 1 << 8;\n            value += view.getUint8(offset + i);\n        }\n        this.pos += width;\n        return value;\n    }\n    readSignedInt(width) {\n        let value = this.readUnsignedInt(width);\n        // If the highest bit is set, convert from two's complement\n        if (value & (1 << (width * 8 - 1))) {\n            value -= 2 ** (width * 8);\n        }\n        return value;\n    }\n    readFloat(width) {\n        if (width === 0) {\n            return 0;\n        }\n        if (width !== 4 && width !== 8) {\n            throw new Error('Bad float size ' + width);\n        }\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + width);\n        const value = width === 4 ? view.getFloat32(offset, false) : view.getFloat64(offset, false);\n        this.pos += width;\n        return value;\n    }\n    readAsciiString(length) {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + length);\n        this.pos += length;\n        // Actual string length might be shorter due to null terminators\n        let strLength = 0;\n        while (strLength < length && view.getUint8(offset + strLength) !== 0) {\n            strLength += 1;\n        }\n        return String.fromCharCode(...new Uint8Array(view.buffer, offset, strLength));\n    }\n    readElementId() {\n        const size = this.readVarIntSize();\n        if (size === null) {\n            return null;\n        }\n        const id = this.readUnsignedInt(size);\n        return id;\n    }\n    readElementSize() {\n        let size = this.readU8();\n        if (size === 0xff) {\n            size = null;\n        }\n        else {\n            this.pos--;\n            size = this.readVarInt();\n            // In some (livestreamed) files, this is the value of the size field. While this technically is just a very\n            // large number, it is intended to behave like the reserved size 0xFF, meaning the size is undefined. We\n            // catch the number here. Note that it cannot be perfectly represented as a double, but the comparison works\n            // nonetheless.\n            // eslint-disable-next-line no-loss-of-precision\n            if (size === 0x00ffffffffffffff) {\n                size = null;\n            }\n        }\n        return size;\n    }\n    readElementHeader() {\n        const id = this.readElementId();\n        if (id === null) {\n            return null;\n        }\n        const size = this.readElementSize();\n        return { id, size };\n    }\n    /** Returns the byte offset in the file of the next element with a matching ID. */\n    async searchForNextElementId(ids, until) {\n        const loadChunkSize = 2 ** 20; // 1 MiB\n        const idsSet = new Set(ids);\n        while (this.pos <= until - MIN_HEADER_SIZE) {\n            if (!this.reader.rangeIsLoaded(this.pos, Math.min(this.pos + MAX_HEADER_SIZE, until))) {\n                await this.reader.loadRange(this.pos, Math.min(this.pos + loadChunkSize, until));\n            }\n            const elementStartPos = this.pos;\n            const elementHeader = this.readElementHeader();\n            if (!elementHeader) {\n                break;\n            }\n            if (idsSet.has(elementHeader.id)) {\n                return elementStartPos;\n            }\n            assertDefinedSize(elementHeader.size);\n            this.pos += elementHeader.size;\n        }\n        return null;\n    }\n    /** Searches for the next occurrence of an element ID using a naive byte-wise search. */\n    async resync(ids, until) {\n        const loadChunkSize = 2 ** 20; // 1 MiB\n        const idsSet = new Set(ids);\n        while (this.pos <= until - MIN_HEADER_SIZE) {\n            if (!this.reader.rangeIsLoaded(this.pos, Math.min(this.pos + MAX_HEADER_SIZE, until))) {\n                await this.reader.loadRange(this.pos, Math.min(this.pos + loadChunkSize, until));\n            }\n            const elementStartPos = this.pos;\n            const elementId = this.readElementId();\n            if (elementId !== null && idsSet.has(elementId)) {\n                return elementStartPos;\n            }\n            this.pos = elementStartPos + 1;\n        }\n        return null;\n    }\n}\nexport const CODEC_STRING_MAP = {\n    'avc': 'V_MPEG4/ISO/AVC',\n    'hevc': 'V_MPEGH/ISO/HEVC',\n    'vp8': 'V_VP8',\n    'vp9': 'V_VP9',\n    'av1': 'V_AV1',\n    'aac': 'A_AAC',\n    'mp3': 'A_MPEG/L3',\n    'opus': 'A_OPUS',\n    'vorbis': 'A_VORBIS',\n    'flac': 'A_FLAC',\n    'pcm-u8': 'A_PCM/INT/LIT',\n    'pcm-s16': 'A_PCM/INT/LIT',\n    'pcm-s16be': 'A_PCM/INT/BIG',\n    'pcm-s24': 'A_PCM/INT/LIT',\n    'pcm-s24be': 'A_PCM/INT/BIG',\n    'pcm-s32': 'A_PCM/INT/LIT',\n    'pcm-s32be': 'A_PCM/INT/BIG',\n    'pcm-f32': 'A_PCM/FLOAT/IEEE',\n    'pcm-f64': 'A_PCM/FLOAT/IEEE',\n    'webvtt': 'S_TEXT/WEBVTT',\n};\nexport const readVarInt = (data, offset) => {\n    if (offset >= data.length) {\n        throw new Error('Offset out of bounds.');\n    }\n    // Read the first byte to determine the width of the variable-length integer\n    const firstByte = data[offset];\n    // Find the position of VINT_MARKER, which determines the width\n    let width = 1;\n    let mask = 1 << 7;\n    while ((firstByte & mask) === 0 && width < 8) {\n        width++;\n        mask >>= 1;\n    }\n    if (offset + width > data.length) {\n        throw new Error('VarInt extends beyond data bounds.');\n    }\n    // First byte's value needs the marker bit cleared\n    let value = firstByte & (mask - 1);\n    // Read remaining bytes\n    for (let i = 1; i < width; i++) {\n        value *= 1 << 8;\n        value += data[offset + i];\n    }\n    return { value, width };\n};\nexport function assertDefinedSize(size) {\n    if (size === null) {\n        throw new Error('Undefined element size is used in a place where it is not supported.');\n    }\n}\n;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8852, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/matroska/matroska-misc.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const buildMatroskaMimeType = (info) => {\n    const base = info.hasVideo\n        ? 'video/'\n        : info.hasAudio\n            ? 'audio/'\n            : 'application/';\n    let string = base + (info.isWebM ? 'webm' : 'x-matroska');\n    if (info.codecStrings.length > 0) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings.filter(Boolean))];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AACM,MAAM,wBAAwB,CAAC;IAClC,MAAM,OAAO,KAAK,QAAQ,GACpB,WACA,KAAK,QAAQ,GACT,WACA;IACV,IAAI,SAAS,OAAO,CAAC,KAAK,MAAM,GAAG,SAAS,YAAY;IACxD,IAAI,KAAK,YAAY,CAAC,MAAM,GAAG,GAAG;QAC9B,MAAM,uBAAuB;eAAI,IAAI,IAAI,KAAK,YAAY,CAAC,MAAM,CAAC;SAAU;QAC5E,UAAU,CAAC,UAAU,EAAE,qBAAqB,IAAI,CAAC,MAAM,CAAC,CAAC;IAC7D;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8876, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/matroska/matroska-demuxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { extractAv1CodecInfoFromPacket, extractAvcDecoderConfigurationRecord, extractHevcDecoderConfigurationRecord, extractVp9CodecInfoFromPacket, } from '../codec-data.js';\nimport { extractAudioCodecString, extractVideoCodecString, } from '../codec.js';\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack, InputVideoTrack, } from '../input-track.js';\nimport { assert, AsyncMutex, binarySearchExact, binarySearchLessOrEqual, COLOR_PRIMARIES_MAP_INVERSE, findLastIndex, insertSorted, isIso639Dash2LanguageCode, last, MATRIX_COEFFICIENTS_MAP_INVERSE, normalizeRotation, roundToPrecision, TRANSFER_CHARACTERISTICS_MAP_INVERSE, UNDETERMINED_LANGUAGE, } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { Reader } from '../reader.js';\nimport { assertDefinedSize, CODEC_STRING_MAP, EBMLId, EBMLReader, LEVEL_0_AND_1_EBML_IDS, LEVEL_1_EBML_IDS, MAX_HEADER_SIZE, MIN_HEADER_SIZE, readVarInt, } from './ebml.js';\nimport { buildMatroskaMimeType } from './matroska-misc.js';\nvar BlockLacing;\n(function (BlockLacing) {\n    BlockLacing[BlockLacing[\"None\"] = 0] = \"None\";\n    BlockLacing[BlockLacing[\"Xiph\"] = 1] = \"Xiph\";\n    BlockLacing[BlockLacing[\"FixedSize\"] = 2] = \"FixedSize\";\n    BlockLacing[BlockLacing[\"Ebml\"] = 3] = \"Ebml\";\n})(BlockLacing || (BlockLacing = {}));\nconst METADATA_ELEMENTS = [\n    { id: EBMLId.SeekHead, flag: 'seekHeadSeen' },\n    { id: EBMLId.Info, flag: 'infoSeen' },\n    { id: EBMLId.Tracks, flag: 'tracksSeen' },\n    { id: EBMLId.Cues, flag: 'cuesSeen' },\n];\nconst MAX_RESYNC_LENGTH = 10 * 2 ** 20; // 10 MiB\nexport class MatroskaDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.readMetadataPromise = null;\n        this.segments = [];\n        this.currentSegment = null;\n        this.currentTrack = null;\n        this.currentCluster = null;\n        this.currentBlock = null;\n        this.currentCueTime = null;\n        this.isWebM = false;\n        this.metadataReader = new EBMLReader(input._mainReader);\n        // Max 64 MiB of stored clusters\n        this.clusterReader = new EBMLReader(new Reader(input.source, 64 * 2 ** 20));\n    }\n    async computeDuration() {\n        const tracks = await this.getTracks();\n        const trackDurations = await Promise.all(tracks.map(x => x.computeDuration()));\n        return Math.max(0, ...trackDurations);\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.segments.flatMap(segment => segment.tracks.map(track => track.inputTrack));\n    }\n    async getMimeType() {\n        await this.readMetadata();\n        const tracks = await this.getTracks();\n        const codecStrings = await Promise.all(tracks.map(x => x.getCodecParameterString()));\n        return buildMatroskaMimeType({\n            isWebM: this.isWebM,\n            hasVideo: this.segments.some(segment => segment.tracks.some(x => x.info?.type === 'video')),\n            hasAudio: this.segments.some(segment => segment.tracks.some(x => x.info?.type === 'audio')),\n            codecStrings: codecStrings.filter(Boolean),\n        });\n    }\n    readMetadata() {\n        return this.readMetadataPromise ??= (async () => {\n            this.metadataReader.pos = 0;\n            const fileSize = await this.input.source.getSize();\n            // Loop over all top-level elements in the file\n            while (this.metadataReader.pos <= fileSize - MIN_HEADER_SIZE) {\n                await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + MAX_HEADER_SIZE);\n                const header = this.metadataReader.readElementHeader();\n                if (!header) {\n                    break; // Zero padding at the end of the file triggers this, for example\n                }\n                const id = header.id;\n                let size = header.size;\n                const startPos = this.metadataReader.pos;\n                if (id === EBMLId.EBML) {\n                    assertDefinedSize(size);\n                    await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + size);\n                    this.readContiguousElements(this.metadataReader, size);\n                }\n                else if (id === EBMLId.Segment) { // Segment found!\n                    await this.readSegment(size);\n                    if (size === null) {\n                        // Segment sizes can be undefined (common in livestreamed files), so assume this is the last\n                        // and only segment\n                        break;\n                    }\n                }\n                else if (id === EBMLId.Cluster) {\n                    // Clusters are not a top-level element in Matroska, but some files contain a Segment whose size\n                    // doesn't contain any of the clusters that follow it. In the case, we apply the following logic: if\n                    // we find a top-level cluster, attribute it to the previous segment.\n                    if (size === null) {\n                        // Just in case this is one of those weird sizeless clusters, let's do our best and still try to\n                        // determine its size.\n                        const nextElementPos = await this.clusterReader.searchForNextElementId(LEVEL_0_AND_1_EBML_IDS, fileSize);\n                        size = (nextElementPos ?? fileSize) - startPos;\n                    }\n                    const lastSegment = last(this.segments);\n                    if (lastSegment) {\n                        // Extend the previous segment's size\n                        lastSegment.elementEndPos = startPos + size;\n                    }\n                }\n                assertDefinedSize(size);\n                this.metadataReader.pos = startPos + size;\n            }\n        })();\n    }\n    async readSegment(dataSize) {\n        const segmentDataStart = this.metadataReader.pos;\n        this.currentSegment = {\n            seekHeadSeen: false,\n            infoSeen: false,\n            tracksSeen: false,\n            cuesSeen: false,\n            timestampScale: -1,\n            timestampFactor: -1,\n            duration: -1,\n            seekEntries: [],\n            tracks: [],\n            cuePoints: [],\n            dataStartPos: segmentDataStart,\n            elementEndPos: dataSize === null\n                ? await this.input.source.getSize() // Assume it goes until the end of the file\n                : segmentDataStart + dataSize,\n            clusterSeekStartPos: segmentDataStart,\n            clusters: [],\n            clusterLookupMutex: new AsyncMutex(),\n        };\n        this.segments.push(this.currentSegment);\n        // Let's load a good amount of data, enough for all segment metadata to likely fit into (minus cues)\n        await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + 2 ** 14);\n        let clusterEncountered = false;\n        while (this.metadataReader.pos <= this.currentSegment.elementEndPos - MIN_HEADER_SIZE) {\n            await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + MAX_HEADER_SIZE);\n            const elementStartPos = this.metadataReader.pos;\n            const header = this.metadataReader.readElementHeader();\n            if (!header || !LEVEL_1_EBML_IDS.includes(header.id)) {\n                // Potential junk. Let's try to resync\n                this.metadataReader.pos = elementStartPos;\n                const nextPos = await this.metadataReader.resync(LEVEL_1_EBML_IDS, Math.min(this.currentSegment.elementEndPos, this.metadataReader.pos + MAX_RESYNC_LENGTH));\n                if (nextPos) {\n                    this.metadataReader.pos = nextPos;\n                    continue;\n                }\n                else {\n                    break; // Resync failed\n                }\n            }\n            const { id, size } = header;\n            const dataStartPos = this.metadataReader.pos;\n            const metadataElementIndex = METADATA_ELEMENTS.findIndex(x => x.id === id);\n            if (metadataElementIndex !== -1) {\n                const field = METADATA_ELEMENTS[metadataElementIndex].flag;\n                this.currentSegment[field] = true;\n                assertDefinedSize(size);\n                await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + size);\n                this.readContiguousElements(this.metadataReader, size);\n            }\n            else if (id === EBMLId.Cluster) {\n                if (!clusterEncountered) {\n                    clusterEncountered = true;\n                    this.currentSegment.clusterSeekStartPos = elementStartPos;\n                }\n            }\n            if (size !== null) {\n                this.metadataReader.pos = dataStartPos + size;\n            }\n            if (this.currentSegment.infoSeen && this.currentSegment.tracksSeen && this.currentSegment.cuesSeen) {\n                // No need to search anymore, we have everything\n                break;\n            }\n            if (this.currentSegment.seekHeadSeen) {\n                let hasInfo = this.currentSegment.infoSeen;\n                let hasTracks = this.currentSegment.tracksSeen;\n                let hasCues = this.currentSegment.cuesSeen;\n                for (const entry of this.currentSegment.seekEntries) {\n                    if (entry.id === EBMLId.Info) {\n                        hasInfo = true;\n                    }\n                    else if (entry.id === EBMLId.Tracks) {\n                        hasTracks = true;\n                    }\n                    else if (entry.id === EBMLId.Cues) {\n                        hasCues = true;\n                    }\n                }\n                if (hasInfo && hasTracks && hasCues) {\n                    // No need to search sequentially anymore, we can use the seek head\n                    break;\n                }\n            }\n            if (size === null) {\n                break;\n            }\n        }\n        if (!clusterEncountered) {\n            const seekEntry = this.currentSegment.seekEntries.find(entry => entry.id === EBMLId.Cluster);\n            if (seekEntry) {\n                // The seek head points us to the first cluster, nice\n                this.currentSegment.clusterSeekStartPos = segmentDataStart + seekEntry.segmentPosition;\n            }\n            else {\n                this.currentSegment.clusterSeekStartPos = this.metadataReader.pos;\n            }\n        }\n        // Use the seek head to read missing metadata elements\n        for (const target of METADATA_ELEMENTS) {\n            if (this.currentSegment[target.flag])\n                continue;\n            const seekEntry = this.currentSegment.seekEntries.find(entry => entry.id === target.id);\n            if (!seekEntry)\n                continue;\n            this.metadataReader.pos = segmentDataStart + seekEntry.segmentPosition;\n            await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + 2 ** 12);\n            const header = this.metadataReader.readElementHeader();\n            if (!header)\n                continue;\n            const { id, size } = header;\n            if (id !== target.id)\n                continue;\n            assertDefinedSize(size);\n            this.currentSegment[target.flag] = true;\n            await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + size);\n            this.readContiguousElements(this.metadataReader, size);\n        }\n        if (this.currentSegment.timestampScale === -1) {\n            // TimestampScale element is missing. Technically an invalid file, but let's default to the typical value,\n            // which is 1e6.\n            this.currentSegment.timestampScale = 1e6;\n            this.currentSegment.timestampFactor = 1e9 / 1e6;\n        }\n        // Put default tracks first\n        this.currentSegment.tracks.sort((a, b) => Number(b.isDefault) - Number(a.isDefault));\n        // Sort cue points by cluster position (required for the next algorithm)\n        this.currentSegment.cuePoints.sort((a, b) => a.clusterPosition - b.clusterPosition);\n        // Now, let's distribute the cue points to each track. Ideally, each track has their own cue point, but some\n        // Matroska files may only specify cue points for a single track. In this case, we still wanna use those cue\n        // points for all tracks.\n        const allTrackIds = this.currentSegment.tracks.map(x => x.id);\n        const remainingTrackIds = new Set();\n        let lastClusterPosition = null;\n        let lastCuePoint = null;\n        for (const cuePoint of this.currentSegment.cuePoints) {\n            if (cuePoint.clusterPosition !== lastClusterPosition) {\n                for (const id of remainingTrackIds) {\n                    // These tracks didn't receive a cue point for the last cluster, so let's give them one\n                    assert(lastCuePoint);\n                    const track = this.currentSegment.tracks.find(x => x.id === id);\n                    track.cuePoints.push(lastCuePoint);\n                }\n                for (const id of allTrackIds) {\n                    remainingTrackIds.add(id);\n                }\n            }\n            lastCuePoint = cuePoint;\n            if (!remainingTrackIds.has(cuePoint.trackId)) {\n                continue;\n            }\n            const track = this.currentSegment.tracks.find(x => x.id === cuePoint.trackId);\n            track.cuePoints.push(cuePoint);\n            remainingTrackIds.delete(cuePoint.trackId);\n            lastClusterPosition = cuePoint.clusterPosition;\n        }\n        for (const id of remainingTrackIds) {\n            assert(lastCuePoint);\n            const track = this.currentSegment.tracks.find(x => x.id === id);\n            track.cuePoints.push(lastCuePoint);\n        }\n        for (const track of this.currentSegment.tracks) {\n            // Sort cue points by time\n            track.cuePoints.sort((a, b) => a.time - b.time);\n        }\n        this.currentSegment = null;\n    }\n    async readCluster(segment) {\n        await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + MAX_HEADER_SIZE);\n        const elementStartPos = this.metadataReader.pos;\n        const elementHeader = this.metadataReader.readElementHeader();\n        assert(elementHeader);\n        const id = elementHeader.id;\n        let size = elementHeader.size;\n        const dataStartPos = this.metadataReader.pos;\n        if (size === null) {\n            // The cluster's size is undefined (can happen in livestreamed files). We'd still like to know the size of\n            // it, so we have no other choice but to iterate over the EBML structure until we find an element at level\n            // 0 or 1, indicating the end of the cluster (all elements inside the cluster are at level 2).\n            this.clusterReader.pos = dataStartPos;\n            const nextElementPos = await this.clusterReader.searchForNextElementId(LEVEL_0_AND_1_EBML_IDS, segment.elementEndPos);\n            size = (nextElementPos ?? segment.elementEndPos) - dataStartPos;\n        }\n        assert(id === EBMLId.Cluster);\n        // Load the entire cluster\n        this.clusterReader.pos = dataStartPos;\n        await this.clusterReader.reader.loadRange(this.clusterReader.pos, this.clusterReader.pos + size);\n        const cluster = {\n            elementStartPos,\n            elementEndPos: dataStartPos + size,\n            dataStartPos,\n            timestamp: -1,\n            trackData: new Map(),\n            nextCluster: null,\n            isKnownToBeFirstCluster: false,\n        };\n        this.currentCluster = cluster;\n        this.readContiguousElements(this.clusterReader, size);\n        for (const [trackId, trackData] of cluster.trackData) {\n            const track = segment.tracks.find(x => x.id === trackId) ?? null;\n            // This must hold, as track datas only get created if a block for that track is encountered\n            assert(trackData.blocks.length > 0);\n            let blockReferencesExist = false;\n            let hasLacedBlocks = false;\n            for (let i = 0; i < trackData.blocks.length; i++) {\n                const block = trackData.blocks[i];\n                block.timestamp += cluster.timestamp;\n                blockReferencesExist ||= block.referencedTimestamps.length > 0;\n                hasLacedBlocks ||= block.lacing !== BlockLacing.None;\n            }\n            if (blockReferencesExist) {\n                trackData.blocks = sortBlocksByReferences(trackData.blocks);\n            }\n            trackData.presentationTimestamps = trackData.blocks\n                .map((block, i) => ({ timestamp: block.timestamp, blockIndex: i }))\n                .sort((a, b) => a.timestamp - b.timestamp);\n            for (let i = 0; i < trackData.presentationTimestamps.length; i++) {\n                const currentEntry = trackData.presentationTimestamps[i];\n                const currentBlock = trackData.blocks[currentEntry.blockIndex];\n                if (trackData.firstKeyFrameTimestamp === null && currentBlock.isKeyFrame) {\n                    trackData.firstKeyFrameTimestamp = currentBlock.timestamp;\n                }\n                if (i < trackData.presentationTimestamps.length - 1) {\n                    // Update block durations based on presentation order\n                    const nextEntry = trackData.presentationTimestamps[i + 1];\n                    currentBlock.duration = nextEntry.timestamp - currentBlock.timestamp;\n                }\n                else if (currentBlock.duration === 0) {\n                    if (track?.defaultDuration != null) {\n                        if (currentBlock.lacing === BlockLacing.None) {\n                            currentBlock.duration = track.defaultDuration;\n                        }\n                        else {\n                            // Handled by the lace resolution code\n                        }\n                    }\n                }\n            }\n            if (hasLacedBlocks) {\n                // Perform lace resolution. Here, we expand each laced block into multiple blocks where each contains\n                // one frame of the lace. We do this after determining block timestamps so we can properly distribute\n                // the block's duration across the laced frames.\n                this.expandLacedBlocks(trackData.blocks, track);\n                // Recompute since blocks have changed\n                trackData.presentationTimestamps = trackData.blocks\n                    .map((block, i) => ({ timestamp: block.timestamp, blockIndex: i }))\n                    .sort((a, b) => a.timestamp - b.timestamp);\n            }\n            const firstBlock = trackData.blocks[trackData.presentationTimestamps[0].blockIndex];\n            const lastBlock = trackData.blocks[last(trackData.presentationTimestamps).blockIndex];\n            trackData.startTimestamp = firstBlock.timestamp;\n            trackData.endTimestamp = lastBlock.timestamp + lastBlock.duration;\n            if (track) {\n                insertSorted(track.clusters, cluster, x => x.elementStartPos);\n                const hasKeyFrame = trackData.firstKeyFrameTimestamp !== null;\n                if (hasKeyFrame) {\n                    insertSorted(track.clustersWithKeyFrame, cluster, x => x.elementStartPos);\n                }\n            }\n        }\n        insertSorted(segment.clusters, cluster, x => x.elementStartPos);\n        this.currentCluster = null;\n        return cluster;\n    }\n    getTrackDataInCluster(cluster, trackNumber) {\n        let trackData = cluster.trackData.get(trackNumber);\n        if (!trackData) {\n            trackData = {\n                startTimestamp: 0,\n                endTimestamp: 0,\n                firstKeyFrameTimestamp: null,\n                blocks: [],\n                presentationTimestamps: [],\n            };\n            cluster.trackData.set(trackNumber, trackData);\n        }\n        return trackData;\n    }\n    expandLacedBlocks(blocks, track) {\n        // https://www.matroska.org/technical/notes.html#block-lacing\n        for (let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {\n            const originalBlock = blocks[blockIndex];\n            if (originalBlock.lacing === BlockLacing.None) {\n                continue;\n            }\n            const data = originalBlock.data;\n            let pos = 0;\n            const frameSizes = [];\n            const frameCount = data[pos] + 1;\n            pos++;\n            switch (originalBlock.lacing) {\n                case BlockLacing.Xiph:\n                    {\n                        let totalUsedSize = 0;\n                        // Xiph lacing, just like in Ogg\n                        for (let i = 0; i < frameCount - 1; i++) {\n                            let frameSize = 0;\n                            while (pos < data.length) {\n                                const value = data[pos];\n                                frameSize += value;\n                                pos++;\n                                if (value < 255) {\n                                    frameSizes.push(frameSize);\n                                    totalUsedSize += frameSize;\n                                    break;\n                                }\n                            }\n                        }\n                        // Compute the last frame's size from whatever's left\n                        frameSizes.push(data.length - (pos + totalUsedSize));\n                    }\n                    ;\n                    break;\n                case BlockLacing.FixedSize:\n                    {\n                        // Fixed size lacing: all frames have same size\n                        const totalDataSize = data.length - 1; // Minus the frame count byte\n                        const frameSize = Math.floor(totalDataSize / frameCount);\n                        for (let i = 0; i < frameCount; i++) {\n                            frameSizes.push(frameSize);\n                        }\n                    }\n                    ;\n                    break;\n                case BlockLacing.Ebml:\n                    {\n                        // EBML lacing: first size absolute, subsequent ones are coded as signed differences from the last\n                        const firstResult = readVarInt(data, pos);\n                        let currentSize = firstResult.value;\n                        frameSizes.push(currentSize);\n                        pos += firstResult.width;\n                        let totalUsedSize = currentSize;\n                        for (let i = 1; i < frameCount - 1; i++) {\n                            const diffResult = readVarInt(data, pos);\n                            const unsignedDiff = diffResult.value;\n                            const bias = (1 << (diffResult.width * 7 - 1)) - 1; // Typo-corrected version of 2^((7*n)-1)^-1\n                            const diff = unsignedDiff - bias;\n                            currentSize += diff;\n                            frameSizes.push(currentSize);\n                            pos += diffResult.width;\n                            totalUsedSize += currentSize;\n                        }\n                        // Compute the last frame's size from whatever's left\n                        frameSizes.push(data.length - (pos + totalUsedSize));\n                    }\n                    ;\n                    break;\n                default: assert(false);\n            }\n            assert(frameSizes.length === frameCount);\n            blocks.splice(blockIndex, 1); // Remove the original block\n            let dataOffset = pos;\n            // Now, let's insert each frame as its own block\n            for (let i = 0; i < frameCount; i++) {\n                const frameSize = frameSizes[i];\n                const frameData = data.subarray(dataOffset, dataOffset + frameSize);\n                const blockDuration = originalBlock.duration || (frameCount * (track?.defaultDuration ?? 0));\n                // Distribute timestamps evenly across the block duration\n                const frameTimestamp = originalBlock.timestamp + (blockDuration * i / frameCount);\n                const frameDuration = blockDuration / frameCount;\n                blocks.splice(blockIndex + i, 0, {\n                    timestamp: frameTimestamp,\n                    duration: frameDuration,\n                    isKeyFrame: originalBlock.isKeyFrame,\n                    referencedTimestamps: originalBlock.referencedTimestamps,\n                    data: frameData,\n                    lacing: BlockLacing.None,\n                });\n                dataOffset += frameSize;\n            }\n            blockIndex += frameCount; // Skip the blocks we just added\n            blockIndex--;\n        }\n    }\n    readContiguousElements(reader, totalSize) {\n        const startIndex = reader.pos;\n        while (reader.pos - startIndex <= totalSize - MIN_HEADER_SIZE) {\n            const foundElement = this.traverseElement(reader);\n            if (!foundElement) {\n                break;\n            }\n        }\n    }\n    traverseElement(reader) {\n        const header = reader.readElementHeader();\n        if (!header) {\n            return false;\n        }\n        const { id, size } = header;\n        const dataStartPos = reader.pos;\n        assertDefinedSize(size);\n        switch (id) {\n            case EBMLId.DocType:\n                {\n                    this.isWebM = reader.readAsciiString(size) === 'webm';\n                }\n                ;\n                break;\n            case EBMLId.Seek:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    const seekEntry = { id: -1, segmentPosition: -1 };\n                    this.currentSegment.seekEntries.push(seekEntry);\n                    this.readContiguousElements(reader, size);\n                    if (seekEntry.id === -1 || seekEntry.segmentPosition === -1) {\n                        this.currentSegment.seekEntries.pop();\n                    }\n                }\n                ;\n                break;\n            case EBMLId.SeekID:\n                {\n                    const lastSeekEntry = this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length - 1];\n                    if (!lastSeekEntry)\n                        break;\n                    lastSeekEntry.id = reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.SeekPosition:\n                {\n                    const lastSeekEntry = this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length - 1];\n                    if (!lastSeekEntry)\n                        break;\n                    lastSeekEntry.segmentPosition = reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.TimestampScale:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.currentSegment.timestampScale = reader.readUnsignedInt(size);\n                    this.currentSegment.timestampFactor = 1e9 / this.currentSegment.timestampScale;\n                }\n                ;\n                break;\n            case EBMLId.Duration:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.currentSegment.duration = reader.readFloat(size);\n                }\n                ;\n                break;\n            case EBMLId.TrackEntry:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.currentTrack = {\n                        id: -1,\n                        segment: this.currentSegment,\n                        demuxer: this,\n                        clusters: [],\n                        clustersWithKeyFrame: [],\n                        cuePoints: [],\n                        isDefault: false,\n                        inputTrack: null,\n                        codecId: null,\n                        codecPrivate: null,\n                        defaultDuration: null,\n                        languageCode: UNDETERMINED_LANGUAGE,\n                        info: null,\n                    };\n                    this.readContiguousElements(reader, size);\n                    if (this.currentTrack\n                        && this.currentTrack.id !== -1\n                        && this.currentTrack.codecId\n                        && this.currentTrack.info) {\n                        const slashIndex = this.currentTrack.codecId.indexOf('/');\n                        const codecIdWithoutSuffix = slashIndex === -1\n                            ? this.currentTrack.codecId\n                            : this.currentTrack.codecId.slice(0, slashIndex);\n                        if (this.currentTrack.info.type === 'video'\n                            && this.currentTrack.info.width !== -1\n                            && this.currentTrack.info.height !== -1) {\n                            if (this.currentTrack.codecId === CODEC_STRING_MAP.avc) {\n                                this.currentTrack.info.codec = 'avc';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (this.currentTrack.codecId === CODEC_STRING_MAP.hevc) {\n                                this.currentTrack.info.codec = 'hevc';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.vp8) {\n                                this.currentTrack.info.codec = 'vp8';\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.vp9) {\n                                this.currentTrack.info.codec = 'vp9';\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.av1) {\n                                this.currentTrack.info.codec = 'av1';\n                            }\n                            const videoTrack = this.currentTrack;\n                            const inputTrack = new InputVideoTrack(new MatroskaVideoTrackBacking(videoTrack));\n                            this.currentTrack.inputTrack = inputTrack;\n                            this.currentSegment.tracks.push(this.currentTrack);\n                        }\n                        else if (this.currentTrack.info.type === 'audio'\n                            && this.currentTrack.info.numberOfChannels !== -1\n                            && this.currentTrack.info.sampleRate !== -1) {\n                            if (codecIdWithoutSuffix === CODEC_STRING_MAP.aac) {\n                                this.currentTrack.info.codec = 'aac';\n                                this.currentTrack.info.aacCodecInfo = {\n                                    isMpeg2: this.currentTrack.codecId.includes('MPEG2'),\n                                };\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (this.currentTrack.codecId === CODEC_STRING_MAP.mp3) {\n                                this.currentTrack.info.codec = 'mp3';\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.opus) {\n                                this.currentTrack.info.codec = 'opus';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.vorbis) {\n                                this.currentTrack.info.codec = 'vorbis';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.flac) {\n                                this.currentTrack.info.codec = 'flac';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (this.currentTrack.codecId === 'A_PCM/INT/LIT') {\n                                if (this.currentTrack.info.bitDepth === 8) {\n                                    this.currentTrack.info.codec = 'pcm-u8';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 16) {\n                                    this.currentTrack.info.codec = 'pcm-s16';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 24) {\n                                    this.currentTrack.info.codec = 'pcm-s24';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 32) {\n                                    this.currentTrack.info.codec = 'pcm-s32';\n                                }\n                            }\n                            else if (this.currentTrack.codecId === 'A_PCM/INT/BIG') {\n                                if (this.currentTrack.info.bitDepth === 8) {\n                                    this.currentTrack.info.codec = 'pcm-u8';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 16) {\n                                    this.currentTrack.info.codec = 'pcm-s16be';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 24) {\n                                    this.currentTrack.info.codec = 'pcm-s24be';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 32) {\n                                    this.currentTrack.info.codec = 'pcm-s32be';\n                                }\n                            }\n                            else if (this.currentTrack.codecId === 'A_PCM/FLOAT/IEEE') {\n                                if (this.currentTrack.info.bitDepth === 32) {\n                                    this.currentTrack.info.codec = 'pcm-f32';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 64) {\n                                    this.currentTrack.info.codec = 'pcm-f64';\n                                }\n                            }\n                            const audioTrack = this.currentTrack;\n                            const inputTrack = new InputAudioTrack(new MatroskaAudioTrackBacking(audioTrack));\n                            this.currentTrack.inputTrack = inputTrack;\n                            this.currentSegment.tracks.push(this.currentTrack);\n                        }\n                    }\n                    this.currentTrack = null;\n                }\n                ;\n                break;\n            case EBMLId.TrackNumber:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.id = reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.TrackType:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    const type = reader.readUnsignedInt(size);\n                    if (type === 1) {\n                        this.currentTrack.info = {\n                            type: 'video',\n                            width: -1,\n                            height: -1,\n                            rotation: 0,\n                            codec: null,\n                            codecDescription: null,\n                            colorSpace: null,\n                        };\n                    }\n                    else if (type === 2) {\n                        this.currentTrack.info = {\n                            type: 'audio',\n                            numberOfChannels: -1,\n                            sampleRate: -1,\n                            bitDepth: -1,\n                            codec: null,\n                            codecDescription: null,\n                            aacCodecInfo: null,\n                        };\n                    }\n                }\n                ;\n                break;\n            case EBMLId.FlagEnabled:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    const enabled = reader.readUnsignedInt(size);\n                    if (!enabled) {\n                        this.currentSegment.tracks.pop();\n                        this.currentTrack = null;\n                    }\n                }\n                ;\n                break;\n            case EBMLId.FlagDefault:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.isDefault = !!reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.CodecID:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.codecId = reader.readAsciiString(size);\n                }\n                ;\n                break;\n            case EBMLId.CodecPrivate:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.codecPrivate = reader.readBytes(size);\n                }\n                ;\n                break;\n            case EBMLId.DefaultDuration:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.defaultDuration\n                        = this.currentTrack.segment.timestampFactor * reader.readUnsignedInt(size) / 1e9;\n                }\n                ;\n                break;\n            case EBMLId.Language:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.languageCode = reader.readAsciiString(size);\n                    if (!isIso639Dash2LanguageCode(this.currentTrack.languageCode)) {\n                        this.currentTrack.languageCode = UNDETERMINED_LANGUAGE;\n                    }\n                }\n                ;\n                break;\n            case EBMLId.Video:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.readContiguousElements(reader, size);\n                }\n                ;\n                break;\n            case EBMLId.PixelWidth:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.currentTrack.info.width = reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.PixelHeight:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.currentTrack.info.height = reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.Colour:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.currentTrack.info.colorSpace = {};\n                    this.readContiguousElements(reader, size);\n                }\n                ;\n                break;\n            case EBMLId.MatrixCoefficients:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    const matrixCoefficients = reader.readUnsignedInt(size);\n                    const mapped = MATRIX_COEFFICIENTS_MAP_INVERSE[matrixCoefficients] ?? null;\n                    this.currentTrack.info.colorSpace.matrix = mapped;\n                }\n                ;\n                break;\n            case EBMLId.Range:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    this.currentTrack.info.colorSpace.fullRange = reader.readUnsignedInt(size) === 2;\n                }\n                ;\n                break;\n            case EBMLId.TransferCharacteristics:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    const transferCharacteristics = reader.readUnsignedInt(size);\n                    const mapped = TRANSFER_CHARACTERISTICS_MAP_INVERSE[transferCharacteristics] ?? null;\n                    this.currentTrack.info.colorSpace.transfer = mapped;\n                }\n                ;\n                break;\n            case EBMLId.Primaries:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    const primaries = reader.readUnsignedInt(size);\n                    const mapped = COLOR_PRIMARIES_MAP_INVERSE[primaries] ?? null;\n                    this.currentTrack.info.colorSpace.primaries = mapped;\n                }\n                ;\n                break;\n            case EBMLId.Projection:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.readContiguousElements(reader, size);\n                }\n                ;\n                break;\n            case EBMLId.ProjectionPoseRoll:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    const rotation = reader.readFloat(size);\n                    const flippedRotation = -rotation; // Convert counter-clockwise to clockwise\n                    try {\n                        this.currentTrack.info.rotation = normalizeRotation(flippedRotation);\n                    }\n                    catch {\n                        // It wasn't a valid rotation\n                    }\n                }\n                ;\n                break;\n            case EBMLId.Audio:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.readContiguousElements(reader, size);\n                }\n                ;\n                break;\n            case EBMLId.SamplingFrequency:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.currentTrack.info.sampleRate = reader.readFloat(size);\n                }\n                ;\n                break;\n            case EBMLId.Channels:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.currentTrack.info.numberOfChannels = reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.BitDepth:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.currentTrack.info.bitDepth = reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.CuePoint:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.readContiguousElements(reader, size);\n                    this.currentCueTime = null;\n                }\n                ;\n                break;\n            case EBMLId.CueTime:\n                {\n                    this.currentCueTime = reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.CueTrackPositions:\n                {\n                    if (this.currentCueTime === null)\n                        break;\n                    assert(this.currentSegment);\n                    const cuePoint = { time: this.currentCueTime, trackId: -1, clusterPosition: -1 };\n                    this.currentSegment.cuePoints.push(cuePoint);\n                    this.readContiguousElements(reader, size);\n                    if (cuePoint.trackId === -1 || cuePoint.clusterPosition === -1) {\n                        this.currentSegment.cuePoints.pop();\n                    }\n                }\n                ;\n                break;\n            case EBMLId.CueTrack:\n                {\n                    const lastCuePoint = this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length - 1];\n                    if (!lastCuePoint)\n                        break;\n                    lastCuePoint.trackId = reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.CueClusterPosition:\n                {\n                    const lastCuePoint = this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length - 1];\n                    if (!lastCuePoint)\n                        break;\n                    assert(this.currentSegment);\n                    lastCuePoint.clusterPosition = this.currentSegment.dataStartPos + reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.Timestamp:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    this.currentCluster.timestamp = reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.SimpleBlock:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    const trackNumber = reader.readVarInt();\n                    if (trackNumber === null)\n                        break;\n                    const relativeTimestamp = reader.readS16();\n                    const flags = reader.readU8();\n                    const isKeyFrame = !!(flags & 0x80);\n                    const lacing = (flags >> 1) & 0x3; // If the block is laced, we'll expand it later\n                    const trackData = this.getTrackDataInCluster(this.currentCluster, trackNumber);\n                    trackData.blocks.push({\n                        timestamp: relativeTimestamp, // We'll add the cluster's timestamp to this later\n                        duration: 0, // Will set later\n                        isKeyFrame,\n                        referencedTimestamps: [],\n                        data: reader.readBytes(size - (reader.pos - dataStartPos)),\n                        lacing,\n                    });\n                }\n                ;\n                break;\n            case EBMLId.BlockGroup:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    this.readContiguousElements(reader, size);\n                    if (this.currentBlock) {\n                        for (let i = 0; i < this.currentBlock.referencedTimestamps.length; i++) {\n                            this.currentBlock.referencedTimestamps[i] += this.currentBlock.timestamp;\n                        }\n                        this.currentBlock = null;\n                    }\n                }\n                ;\n                break;\n            case EBMLId.Block:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    const trackNumber = reader.readVarInt();\n                    if (trackNumber === null)\n                        break;\n                    const relativeTimestamp = reader.readS16();\n                    const flags = reader.readU8();\n                    const lacing = (flags >> 1) & 0x3; // If the block is laced, we'll expand it later\n                    const trackData = this.getTrackDataInCluster(this.currentCluster, trackNumber);\n                    this.currentBlock = {\n                        timestamp: relativeTimestamp, // We'll add the cluster's timestamp to this later\n                        duration: 0, // Will set later\n                        isKeyFrame: true,\n                        referencedTimestamps: [],\n                        data: reader.readBytes(size - (reader.pos - dataStartPos)),\n                        lacing,\n                    };\n                    trackData.blocks.push(this.currentBlock);\n                }\n                ;\n                break;\n            case EBMLId.BlockDuration:\n                {\n                    if (!this.currentBlock)\n                        break;\n                    this.currentBlock.duration = reader.readUnsignedInt(size);\n                }\n                ;\n                break;\n            case EBMLId.ReferenceBlock:\n                {\n                    if (!this.currentBlock)\n                        break;\n                    this.currentBlock.isKeyFrame = false;\n                    const relativeTimestamp = reader.readSignedInt(size);\n                    // We'll offset this by the block's timestamp later\n                    this.currentBlock.referencedTimestamps.push(relativeTimestamp);\n                }\n                ;\n                break;\n        }\n        reader.pos = dataStartPos + size;\n        return true;\n    }\n}\nclass MatroskaTrackBacking {\n    constructor(internalTrack) {\n        this.internalTrack = internalTrack;\n        this.packetToClusterLocation = new WeakMap();\n    }\n    getId() {\n        return this.internalTrack.id;\n    }\n    getCodec() {\n        throw new Error('Not implemented on base class.');\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    getLanguageCode() {\n        return this.internalTrack.languageCode;\n    }\n    async getFirstTimestamp() {\n        const firstPacket = await this.getFirstPacket({ metadataOnly: true });\n        return firstPacket?.timestamp ?? 0;\n    }\n    getTimeResolution() {\n        return this.internalTrack.segment.timestampFactor;\n    }\n    async getFirstPacket(options) {\n        return this.performClusterLookup(() => {\n            const startCluster = this.internalTrack.segment.clusters[0] ?? null;\n            if (startCluster?.isKnownToBeFirstCluster) {\n                // Walk from the very first cluster in the file until we find one with our track in it\n                let currentCluster = startCluster;\n                while (currentCluster) {\n                    const trackData = currentCluster.trackData.get(this.internalTrack.id);\n                    if (trackData) {\n                        return {\n                            clusterIndex: binarySearchExact(this.internalTrack.clusters, currentCluster.elementStartPos, x => x.elementStartPos),\n                            blockIndex: 0,\n                            correctBlockFound: true,\n                        };\n                    }\n                    currentCluster = currentCluster.nextCluster;\n                }\n            }\n            return {\n                clusterIndex: -1,\n                blockIndex: -1,\n                correctBlockFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the cues\n        Infinity, options);\n    }\n    intoTimescale(timestamp) {\n        // Do a little rounding to catch cases where the result is very close to an integer. If it is, it's likely\n        // that the number was originally an integer divided by the timescale. For stability, it's best\n        // to return the integer in this case.\n        return roundToPrecision(timestamp * this.internalTrack.segment.timestampFactor, 14);\n    }\n    async getPacket(timestamp, options) {\n        const timestampInTimescale = this.intoTimescale(timestamp);\n        return this.performClusterLookup(() => this.findBlockInClustersForTimestamp(timestampInTimescale), timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextPacket(packet, options) {\n        const locationInCluster = this.packetToClusterLocation.get(packet);\n        if (locationInCluster === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        const trackData = locationInCluster.cluster.trackData.get(this.internalTrack.id);\n        const clusterIndex = binarySearchExact(this.internalTrack.clusters, locationInCluster.cluster.elementStartPos, x => x.elementStartPos);\n        assert(clusterIndex !== -1);\n        return this.performClusterLookup(() => {\n            if (locationInCluster.blockIndex + 1 < trackData.blocks.length) {\n                // We can simply take the next block in the cluster\n                return {\n                    clusterIndex,\n                    blockIndex: locationInCluster.blockIndex + 1,\n                    correctBlockFound: true,\n                };\n            }\n            else {\n                // Walk the list of clusters until we find the next cluster for this track\n                let currentCluster = locationInCluster.cluster;\n                while (currentCluster.nextCluster) {\n                    currentCluster = currentCluster.nextCluster;\n                    const trackData = currentCluster.trackData.get(this.internalTrack.id);\n                    if (trackData) {\n                        const clusterIndex = binarySearchExact(this.internalTrack.clusters, currentCluster.elementStartPos, x => x.elementStartPos);\n                        assert(clusterIndex !== -1);\n                        return {\n                            clusterIndex,\n                            blockIndex: 0,\n                            correctBlockFound: true,\n                        };\n                    }\n                }\n                return {\n                    clusterIndex,\n                    blockIndex: -1,\n                    correctBlockFound: false,\n                };\n            }\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the cues\n        Infinity, options);\n    }\n    async getKeyPacket(timestamp, options) {\n        const timestampInTimescale = this.intoTimescale(timestamp);\n        return this.performClusterLookup(() => this.findKeyBlockInClustersForTimestamp(timestampInTimescale), timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextKeyPacket(packet, options) {\n        const locationInCluster = this.packetToClusterLocation.get(packet);\n        if (locationInCluster === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        const trackData = locationInCluster.cluster.trackData.get(this.internalTrack.id);\n        const clusterIndex = binarySearchExact(this.internalTrack.clusters, locationInCluster.cluster.elementStartPos, x => x.elementStartPos);\n        assert(clusterIndex !== -1);\n        return this.performClusterLookup(() => {\n            const nextKeyFrameIndex = trackData.blocks.findIndex((x, i) => x.isKeyFrame && i > locationInCluster.blockIndex);\n            if (nextKeyFrameIndex !== -1) {\n                // We can simply take the next key frame in the cluster\n                return {\n                    clusterIndex,\n                    blockIndex: nextKeyFrameIndex,\n                    correctBlockFound: true,\n                };\n            }\n            else {\n                // Walk the list of clusters until we find the next cluster for this track with a key frame\n                let currentCluster = locationInCluster.cluster;\n                while (currentCluster.nextCluster) {\n                    currentCluster = currentCluster.nextCluster;\n                    const trackData = currentCluster.trackData.get(this.internalTrack.id);\n                    if (trackData && trackData.firstKeyFrameTimestamp !== null) {\n                        const clusterIndex = binarySearchExact(this.internalTrack.clusters, currentCluster.elementStartPos, x => x.elementStartPos);\n                        assert(clusterIndex !== -1);\n                        const keyFrameIndex = trackData.blocks.findIndex(x => x.isKeyFrame);\n                        assert(keyFrameIndex !== -1); // There must be one\n                        return {\n                            clusterIndex,\n                            blockIndex: keyFrameIndex,\n                            correctBlockFound: true,\n                        };\n                    }\n                }\n                return {\n                    clusterIndex,\n                    blockIndex: -1,\n                    correctBlockFound: false,\n                };\n            }\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the cues\n        Infinity, options);\n    }\n    async fetchPacketInCluster(cluster, blockIndex, options) {\n        if (blockIndex === -1) {\n            return null;\n        }\n        const trackData = cluster.trackData.get(this.internalTrack.id);\n        const block = trackData.blocks[blockIndex];\n        assert(block);\n        const data = options.metadataOnly ? PLACEHOLDER_DATA : block.data;\n        const timestamp = block.timestamp / this.internalTrack.segment.timestampFactor;\n        const duration = block.duration / this.internalTrack.segment.timestampFactor;\n        const packet = new EncodedPacket(data, block.isKeyFrame ? 'key' : 'delta', timestamp, duration, cluster.dataStartPos + blockIndex, block.data.byteLength);\n        this.packetToClusterLocation.set(packet, { cluster, blockIndex });\n        return packet;\n    }\n    findBlockInClustersForTimestamp(timestampInTimescale) {\n        const clusterIndex = binarySearchLessOrEqual(\n        // This array is technically not sorted by start timestamp, but for any reasonable file, it basically is.\n        this.internalTrack.clusters, timestampInTimescale, x => x.trackData.get(this.internalTrack.id).startTimestamp);\n        let blockIndex = -1;\n        let correctBlockFound = false;\n        if (clusterIndex !== -1) {\n            const cluster = this.internalTrack.clusters[clusterIndex];\n            const trackData = cluster.trackData.get(this.internalTrack.id);\n            const index = binarySearchLessOrEqual(trackData.presentationTimestamps, timestampInTimescale, x => x.timestamp);\n            assert(index !== -1);\n            blockIndex = trackData.presentationTimestamps[index].blockIndex;\n            correctBlockFound = timestampInTimescale < trackData.endTimestamp;\n        }\n        return { clusterIndex, blockIndex, correctBlockFound };\n    }\n    findKeyBlockInClustersForTimestamp(timestampInTimescale) {\n        const indexInKeyFrameClusters = binarySearchLessOrEqual(\n        // This array is technically not sorted by start timestamp, but for any reasonable file, it basically is.\n        this.internalTrack.clustersWithKeyFrame, timestampInTimescale, x => x.trackData.get(this.internalTrack.id).firstKeyFrameTimestamp);\n        let clusterIndex = -1;\n        let blockIndex = -1;\n        let correctBlockFound = false;\n        if (indexInKeyFrameClusters !== -1) {\n            const cluster = this.internalTrack.clustersWithKeyFrame[indexInKeyFrameClusters];\n            // Now, let's find the actual index of the cluster in the list of ALL clusters, not just key frame ones\n            clusterIndex = binarySearchExact(this.internalTrack.clusters, cluster.elementStartPos, x => x.elementStartPos);\n            assert(clusterIndex !== -1);\n            const trackData = cluster.trackData.get(this.internalTrack.id);\n            const index = findLastIndex(trackData.presentationTimestamps, (x) => {\n                const block = trackData.blocks[x.blockIndex];\n                return block.isKeyFrame && x.timestamp <= timestampInTimescale;\n            });\n            assert(index !== -1); // It's a key frame cluster, so there must be a key frame\n            const entry = trackData.presentationTimestamps[index];\n            blockIndex = entry.blockIndex;\n            correctBlockFound = timestampInTimescale < trackData.endTimestamp;\n        }\n        return { clusterIndex, blockIndex, correctBlockFound };\n    }\n    /** Looks for a packet in the clusters while trying to load as few clusters as possible to retrieve it. */\n    async performClusterLookup(\n    // This function returns the best-matching block that is currently loaded. Based on this information, we know\n    // which clusters we need to load to find the actual match.\n    getBestMatch, \n    // The timestamp with which we can search the lookup table\n    searchTimestamp, \n    // The timestamp for which we know the correct block will not come after it\n    latestTimestamp, options) {\n        const { demuxer, segment } = this.internalTrack;\n        const release = await segment.clusterLookupMutex.acquire(); // The algorithm requires exclusivity\n        try {\n            const { clusterIndex, blockIndex, correctBlockFound } = getBestMatch();\n            if (correctBlockFound) {\n                // The correct block already exists, easy path.\n                const cluster = this.internalTrack.clusters[clusterIndex];\n                return this.fetchPacketInCluster(cluster, blockIndex, options);\n            }\n            // We use the metadata reader to find the cluster, but the cluster reader to load the cluster\n            const metadataReader = demuxer.metadataReader;\n            const clusterReader = demuxer.clusterReader;\n            let prevCluster = null;\n            let bestClusterIndex = clusterIndex;\n            let bestBlockIndex = blockIndex;\n            // Search for a cue point; this way, we won't need to start searching from the start of the file\n            // but can jump right into the correct cluster (or at least nearby).\n            const cuePointIndex = binarySearchLessOrEqual(this.internalTrack.cuePoints, searchTimestamp, x => x.time);\n            const cuePoint = cuePointIndex !== -1 ? this.internalTrack.cuePoints[cuePointIndex] : null;\n            let nextClusterIsFirstCluster = false;\n            if (clusterIndex === -1) {\n                metadataReader.pos = cuePoint?.clusterPosition ?? segment.clusterSeekStartPos;\n                nextClusterIsFirstCluster = metadataReader.pos === segment.clusterSeekStartPos;\n            }\n            else {\n                const cluster = this.internalTrack.clusters[clusterIndex];\n                if (!cuePoint || cluster.elementStartPos >= cuePoint.clusterPosition) {\n                    metadataReader.pos = cluster.elementEndPos;\n                    prevCluster = cluster;\n                }\n                else {\n                    // Use the lookup entry\n                    metadataReader.pos = cuePoint.clusterPosition;\n                }\n            }\n            while (metadataReader.pos <= segment.elementEndPos - MIN_HEADER_SIZE) {\n                if (prevCluster) {\n                    const trackData = prevCluster.trackData.get(this.internalTrack.id);\n                    if (trackData && trackData.startTimestamp > latestTimestamp) {\n                        // We're already past the upper bound, no need to keep searching\n                        break;\n                    }\n                    if (prevCluster.nextCluster) {\n                        // Skip ahead quickly without needing to read the file again\n                        metadataReader.pos = prevCluster.nextCluster.elementEndPos;\n                        prevCluster = prevCluster.nextCluster;\n                        continue;\n                    }\n                }\n                // Load the header\n                await metadataReader.reader.loadRange(metadataReader.pos, metadataReader.pos + MAX_HEADER_SIZE);\n                const elementStartPos = metadataReader.pos;\n                const elementHeader = metadataReader.readElementHeader();\n                if (!elementHeader || !LEVEL_1_EBML_IDS.includes(elementHeader.id)) {\n                    // There's an element here that shouldn't be here (or Void). Might be garbage. In this case, let's\n                    // try and resync to the next valid element.\n                    metadataReader.pos = elementStartPos;\n                    const nextPos = await metadataReader.resync(LEVEL_1_EBML_IDS, Math.min(segment.elementEndPos, metadataReader.pos + MAX_RESYNC_LENGTH));\n                    if (nextPos) {\n                        metadataReader.pos = nextPos;\n                        continue;\n                    }\n                    else {\n                        break; // Resync failed\n                    }\n                }\n                const id = elementHeader.id;\n                let size = elementHeader.size;\n                const dataStartPos = metadataReader.pos;\n                if (id === EBMLId.Cluster) {\n                    const index = binarySearchExact(segment.clusters, elementStartPos, x => x.elementStartPos);\n                    let cluster;\n                    if (index === -1) {\n                        // This is the first time we've seen this cluster\n                        metadataReader.pos = elementStartPos;\n                        cluster = await demuxer.readCluster(segment);\n                    }\n                    else {\n                        // We already know this cluster\n                        cluster = segment.clusters[index];\n                    }\n                    // Even if we already know the cluster, we might not yet know its predecessor, so always do this\n                    if (prevCluster)\n                        prevCluster.nextCluster = cluster;\n                    prevCluster = cluster;\n                    if (nextClusterIsFirstCluster) {\n                        cluster.isKnownToBeFirstCluster = true;\n                        nextClusterIsFirstCluster = false;\n                    }\n                    const { clusterIndex, blockIndex, correctBlockFound } = getBestMatch();\n                    if (correctBlockFound) {\n                        const cluster = this.internalTrack.clusters[clusterIndex];\n                        return this.fetchPacketInCluster(cluster, blockIndex, options);\n                    }\n                    if (clusterIndex !== -1) {\n                        bestClusterIndex = clusterIndex;\n                        bestBlockIndex = blockIndex;\n                    }\n                }\n                if (size === null) {\n                    // Undefined element size (can happen in livestreamed files). In this case, we need to do some\n                    // searching to determine the actual size of the element.\n                    if (id === EBMLId.Cluster) {\n                        // The cluster should have already computed its length, we can just copy that result\n                        assert(prevCluster);\n                        size = prevCluster.elementEndPos - dataStartPos;\n                    }\n                    else {\n                        // Search for the next element at level 0 or 1\n                        clusterReader.pos = dataStartPos;\n                        const nextElementPos = await clusterReader.searchForNextElementId(LEVEL_0_AND_1_EBML_IDS, segment.elementEndPos);\n                        size = (nextElementPos ?? segment.elementEndPos) - dataStartPos;\n                    }\n                    const endPos = dataStartPos + size;\n                    if (endPos > segment.elementEndPos - MIN_HEADER_SIZE) {\n                        // No more elements fit in this segment\n                        break;\n                    }\n                    else {\n                        // Check the next element. If it's a new segment, we know this segment ends here. The new\n                        // segment is just ignored, since we're likely in a livestreamed file and thus only care about\n                        // the first segment.\n                        clusterReader.pos = endPos;\n                        const elementId = clusterReader.readElementId();\n                        if (elementId === EBMLId.Segment) {\n                            segment.elementEndPos = endPos;\n                            break;\n                        }\n                    }\n                }\n                metadataReader.pos = dataStartPos + size;\n            }\n            let result = null;\n            const bestCluster = bestClusterIndex !== -1 ? this.internalTrack.clusters[bestClusterIndex] : null;\n            if (bestCluster) {\n                // If we finished looping but didn't find a perfect match, still return the best match we found\n                result = await this.fetchPacketInCluster(bestCluster, bestBlockIndex, options);\n            }\n            // Catch faulty cue points\n            if (!result && cuePoint && (!bestCluster || bestCluster.elementStartPos < cuePoint.clusterPosition)) {\n                // The cue point lied to us! We found a cue point but no cluster there that satisfied the match. In this\n                // case, let's search again but using the cue point before that.\n                const previousCuePoint = this.internalTrack.cuePoints[cuePointIndex - 1];\n                const newSearchTimestamp = previousCuePoint?.time ?? -Infinity;\n                return this.performClusterLookup(getBestMatch, newSearchTimestamp, latestTimestamp, options);\n            }\n            return result;\n        }\n        finally {\n            release();\n        }\n    }\n}\nclass MatroskaVideoTrackBacking extends MatroskaTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfigPromise = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getCodedWidth() {\n        return this.internalTrack.info.width;\n    }\n    getCodedHeight() {\n        return this.internalTrack.info.height;\n    }\n    getRotation() {\n        return this.internalTrack.info.rotation;\n    }\n    async getColorSpace() {\n        return {\n            primaries: this.internalTrack.info.colorSpace?.primaries,\n            transfer: this.internalTrack.info.colorSpace?.transfer,\n            matrix: this.internalTrack.info.colorSpace?.matrix,\n            fullRange: this.internalTrack.info.colorSpace?.fullRange,\n        };\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfigPromise ??= (async () => {\n            let firstPacket = null;\n            const needsPacketForAdditionalInfo = this.internalTrack.info.codec === 'vp9'\n                || this.internalTrack.info.codec === 'av1'\n                // Packets are in Annex B format:\n                || (this.internalTrack.info.codec === 'avc' && !this.internalTrack.info.codecDescription)\n                // Packets are in Annex B format:\n                || (this.internalTrack.info.codec === 'hevc' && !this.internalTrack.info.codecDescription);\n            if (needsPacketForAdditionalInfo) {\n                firstPacket = await this.getFirstPacket({});\n            }\n            return {\n                codec: extractVideoCodecString({\n                    width: this.internalTrack.info.width,\n                    height: this.internalTrack.info.height,\n                    codec: this.internalTrack.info.codec,\n                    codecDescription: this.internalTrack.info.codecDescription,\n                    colorSpace: this.internalTrack.info.colorSpace,\n                    avcCodecInfo: this.internalTrack.info.codec === 'avc' && firstPacket\n                        ? extractAvcDecoderConfigurationRecord(firstPacket.data)\n                        : null,\n                    hevcCodecInfo: this.internalTrack.info.codec === 'hevc' && firstPacket\n                        ? extractHevcDecoderConfigurationRecord(firstPacket.data)\n                        : null,\n                    vp9CodecInfo: this.internalTrack.info.codec === 'vp9' && firstPacket\n                        ? extractVp9CodecInfoFromPacket(firstPacket.data)\n                        : null,\n                    av1CodecInfo: this.internalTrack.info.codec === 'av1' && firstPacket\n                        ? extractAv1CodecInfoFromPacket(firstPacket.data)\n                        : null,\n                }),\n                codedWidth: this.internalTrack.info.width,\n                codedHeight: this.internalTrack.info.height,\n                description: this.internalTrack.info.codecDescription ?? undefined,\n                colorSpace: this.internalTrack.info.colorSpace ?? undefined,\n            };\n        })();\n    }\n}\nclass MatroskaAudioTrackBacking extends MatroskaTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfig = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getNumberOfChannels() {\n        return this.internalTrack.info.numberOfChannels;\n    }\n    getSampleRate() {\n        return this.internalTrack.info.sampleRate;\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfig ??= {\n            codec: extractAudioCodecString({\n                codec: this.internalTrack.info.codec,\n                codecDescription: this.internalTrack.info.codecDescription,\n                aacCodecInfo: this.internalTrack.info.aacCodecInfo,\n            }),\n            numberOfChannels: this.internalTrack.info.numberOfChannels,\n            sampleRate: this.internalTrack.info.sampleRate,\n            description: this.internalTrack.info.codecDescription ?? undefined,\n        };\n    }\n}\n/** Sorts blocks such that referenced blocks come before the blocks that reference them. */\nconst sortBlocksByReferences = (blocks) => {\n    const timestampToBlock = new Map();\n    for (let i = 0; i < blocks.length; i++) {\n        const block = blocks[i];\n        timestampToBlock.set(block.timestamp, block);\n    }\n    const processedBlocks = new Set();\n    const result = [];\n    const processBlock = (block) => {\n        if (processedBlocks.has(block)) {\n            return;\n        }\n        // Marking the block as processed here already; prevents this algorithm from dying on cycles\n        processedBlocks.add(block);\n        for (let j = 0; j < block.referencedTimestamps.length; j++) {\n            const timestamp = block.referencedTimestamps[j];\n            const otherBlock = timestampToBlock.get(timestamp);\n            if (!otherBlock) {\n                continue;\n            }\n            processBlock(otherBlock);\n        }\n        result.push(block);\n    };\n    for (let i = 0; i < blocks.length; i++) {\n        processBlock(blocks[i]);\n    }\n    return result;\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10345, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/shared/mp3-misc.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const FRAME_HEADER_SIZE = 4;\n// These are in kbps:\nexport const MPEG_V1_BITRATES = {\n    // Layer 3\n    1: [-1, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1],\n    // Layer 2\n    2: [-1, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1],\n    // Layer 1\n    3: [-1, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1],\n};\nexport const MPEG_V2_BITRATES = {\n    // Layer 3\n    1: [-1, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, -1],\n    // Layer 2\n    2: [-1, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1],\n    // Layer 1\n    3: [-1, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1],\n};\nexport const SAMPLING_RATES = {\n    // MPEG Version 2.5\n    0: [11025, 12000, 8000, -1],\n    // MPEG Version 2 (ISO/IEC 13818-3)\n    2: [22050, 24000, 16000, -1],\n    // MPEG Version 1 (ISO/IEC 11172-3)\n    3: [44100, 48000, 32000, -1],\n};\n/** 'Xing' */\nexport const XING = 0x58696e67;\n/** 'Info' */\nexport const INFO = 0x496e666f;\nexport const computeMp3FrameSize = (layer, bitrate, sampleRate, padding) => {\n    if (layer === 3) {\n        // Layer 1\n        return Math.floor((12 * bitrate / sampleRate + padding) * 4);\n    }\n    else {\n        return Math.floor((144 * bitrate / sampleRate) + padding);\n    }\n};\nexport const getXingOffset = (mpegVersionId, channel) => {\n    return mpegVersionId === 3\n        ? (channel === 3 ? 21 : 36)\n        : (channel === 3 ? 13 : 21);\n};\nexport const readFrameHeader = (word, reader) => {\n    const startPos = reader.pos;\n    const firstByte = word >>> 24;\n    const secondByte = (word >>> 16) & 0xff;\n    const thirdByte = (word >>> 8) & 0xff;\n    const fourthByte = word & 0xff;\n    if (firstByte !== 0xff && secondByte !== 0xff && thirdByte !== 0xff && fourthByte !== 0xff) {\n        reader.pos += 4;\n        return null;\n    }\n    reader.pos += 1;\n    if (firstByte !== 0xff) {\n        return null;\n    }\n    if ((secondByte & 0xe0) !== 0xe0) {\n        return null;\n    }\n    const mpegVersionId = (secondByte >> 3) & 0x3;\n    const layer = (secondByte >> 1) & 0x3;\n    const bitrateIndex = (thirdByte >> 4) & 0xf;\n    const frequencyIndex = (thirdByte >> 2) & 0x3;\n    const padding = (thirdByte >> 1) & 0x1;\n    const channel = (fourthByte >> 6) & 0x3;\n    const modeExtension = (fourthByte >> 4) & 0x3;\n    const copyright = (fourthByte >> 3) & 0x1;\n    const original = (fourthByte >> 2) & 0x1;\n    const emphasis = fourthByte & 0x3;\n    const kilobitRate = mpegVersionId === 3\n        ? MPEG_V1_BITRATES[layer]?.[bitrateIndex]\n        : MPEG_V2_BITRATES[layer]?.[bitrateIndex];\n    if (!kilobitRate || kilobitRate === -1) {\n        return null;\n    }\n    const bitrate = kilobitRate * 1000;\n    const sampleRate = SAMPLING_RATES[mpegVersionId]?.[frequencyIndex];\n    if (!sampleRate || sampleRate === -1) {\n        return null;\n    }\n    const frameLength = computeMp3FrameSize(layer, bitrate, sampleRate, padding);\n    if (reader.fileSize !== null && reader.fileSize - startPos < frameLength) {\n        // The frame doesn't fit into the rest of the file\n        return null;\n    }\n    let audioSamplesInFrame;\n    if (mpegVersionId === 3) {\n        audioSamplesInFrame = layer === 3 ? 384 : 1152;\n    }\n    else {\n        if (layer === 3) {\n            audioSamplesInFrame = 384;\n        }\n        else if (layer === 2) {\n            audioSamplesInFrame = 1152;\n        }\n        else {\n            audioSamplesInFrame = 576;\n        }\n    }\n    return {\n        startPos: startPos,\n        totalSize: frameLength,\n        mpegVersionId,\n        layer,\n        bitrate,\n        frequencyIndex,\n        sampleRate,\n        channel,\n        modeExtension,\n        copyright,\n        original,\n        emphasis,\n        audioSamplesInFrame,\n    };\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10590, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/mp3/mp3-reader.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert } from '../misc.js';\nimport { FRAME_HEADER_SIZE, readFrameHeader } from '../../shared/mp3-misc.js';\nexport class Mp3Reader {\n    constructor(reader) {\n        this.reader = reader;\n        this.pos = 0;\n        this.fileSize = null;\n    }\n    readBytes(length) {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + length);\n        this.pos += length;\n        return new Uint8Array(view.buffer, offset, length);\n    }\n    readU16() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 2);\n        this.pos += 2;\n        return view.getUint16(offset, false);\n    }\n    readU32() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 4);\n        this.pos += 4;\n        return view.getUint32(offset, false);\n    }\n    readAscii(length) {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + length);\n        this.pos += length;\n        let str = '';\n        for (let i = 0; i < length; i++) {\n            str += String.fromCharCode(view.getUint8(offset + i));\n        }\n        return str;\n    }\n    readId3() {\n        const tag = this.readAscii(3);\n        if (tag !== 'ID3') {\n            this.pos -= 3;\n            return null;\n        }\n        this.pos += 3;\n        const size = decodeSynchsafe(this.readU32());\n        return { size };\n    }\n    readNextFrameHeader(until) {\n        assert(this.fileSize);\n        until ??= this.fileSize;\n        while (this.pos <= until - FRAME_HEADER_SIZE) {\n            const word = this.readU32();\n            this.pos -= 4;\n            const header = readFrameHeader(word, this);\n            if (header) {\n                return header;\n            }\n        }\n        return null;\n    }\n}\nexport const decodeSynchsafe = (synchsafed) => {\n    let mask = 0x7f000000;\n    let unsynchsafed = 0;\n    while (mask !== 0) {\n        unsynchsafed >>= 1;\n        unsynchsafed |= synchsafed & mask;\n        mask >>= 8;\n    }\n    return unsynchsafed;\n};\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;AACD;AACA;;;AACO,MAAM;IACT,YAAY,MAAM,CAAE;QAChB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA,UAAU,MAAM,EAAE;QACd,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG;QAC3E,IAAI,CAAC,GAAG,IAAI;QACZ,OAAO,IAAI,WAAW,KAAK,MAAM,EAAE,QAAQ;IAC/C;IACA,UAAU;QACN,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG;QAC3E,IAAI,CAAC,GAAG,IAAI;QACZ,OAAO,KAAK,SAAS,CAAC,QAAQ;IAClC;IACA,UAAU;QACN,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG;QAC3E,IAAI,CAAC,GAAG,IAAI;QACZ,OAAO,KAAK,SAAS,CAAC,QAAQ;IAClC;IACA,UAAU,MAAM,EAAE;QACd,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG;QAC3E,IAAI,CAAC,GAAG,IAAI;QACZ,IAAI,MAAM;QACV,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,OAAO,OAAO,YAAY,CAAC,KAAK,QAAQ,CAAC,SAAS;QACtD;QACA,OAAO;IACX;IACA,UAAU;QACN,MAAM,MAAM,IAAI,CAAC,SAAS,CAAC;QAC3B,IAAI,QAAQ,OAAO;YACf,IAAI,CAAC,GAAG,IAAI;YACZ,OAAO;QACX;QACA,IAAI,CAAC,GAAG,IAAI;QACZ,MAAM,OAAO,gBAAgB,IAAI,CAAC,OAAO;QACzC,OAAO;YAAE;QAAK;IAClB;IACA,oBAAoB,KAAK,EAAE;QACvB,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,QAAQ;QACpB,UAAU,IAAI,CAAC,QAAQ;QACvB,MAAO,IAAI,CAAC,GAAG,IAAI,QAAQ,4NAAA,CAAA,oBAAiB,CAAE;YAC1C,MAAM,OAAO,IAAI,CAAC,OAAO;YACzB,IAAI,CAAC,GAAG,IAAI;YACZ,MAAM,SAAS,CAAA,GAAA,4NAAA,CAAA,kBAAe,AAAD,EAAE,MAAM,IAAI;YACzC,IAAI,QAAQ;gBACR,OAAO;YACX;QACJ;QACA,OAAO;IACX;AACJ;AACO,MAAM,kBAAkB,CAAC;IAC5B,IAAI,OAAO;IACX,IAAI,eAAe;IACnB,MAAO,SAAS,EAAG;QACf,iBAAiB;QACjB,gBAAgB,aAAa;QAC7B,SAAS;IACb;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10674, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/mp3/mp3-demuxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack } from '../input-track.js';\nimport { assert, AsyncMutex, binarySearchExact, binarySearchLessOrEqual, UNDETERMINED_LANGUAGE } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { getXingOffset, INFO, XING } from '../../shared/mp3-misc.js';\nimport { Mp3Reader } from './mp3-reader.js';\nexport class Mp3Demuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.metadataPromise = null;\n        this.firstFrameHeader = null;\n        this.loadedSamples = []; // All samples from the start of the file to lastLoadedPos\n        this.tracks = [];\n        this.readingMutex = new AsyncMutex();\n        this.lastLoadedPos = 0;\n        this.fileSize = 0;\n        this.nextTimestampInSamples = 0;\n        this.reader = new Mp3Reader(input._mainReader);\n    }\n    async readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            this.fileSize = await this.input.source.getSize();\n            this.reader.fileSize = this.fileSize;\n            // Keep loading until we find the first frame header\n            while (!this.firstFrameHeader && this.lastLoadedPos < this.fileSize) {\n                await this.loadNextChunk();\n            }\n            // There has to be a frame if this demuxer got selected\n            assert(this.firstFrameHeader);\n            this.tracks = [new InputAudioTrack(new Mp3AudioTrackBacking(this))];\n        })();\n    }\n    /** Loads the next 0.5 MiB of frames. */\n    async loadNextChunk() {\n        assert(this.lastLoadedPos < this.fileSize);\n        const chunkSize = 0.5 * 1024 * 1024; // 0.5 MiB\n        const endPos = Math.min(this.lastLoadedPos + chunkSize, this.fileSize);\n        await this.reader.reader.loadRange(this.lastLoadedPos, endPos);\n        this.lastLoadedPos = endPos;\n        assert(this.lastLoadedPos <= this.fileSize);\n        if (this.reader.pos === 0) {\n            // First time, let's see if there's an ID3 tag\n            const id3Tag = this.reader.readId3();\n            if (id3Tag) {\n                this.reader.pos += id3Tag.size;\n            }\n        }\n        this.parseFramesFromLoadedData();\n    }\n    parseFramesFromLoadedData() {\n        while (true) {\n            const startPos = this.reader.pos;\n            const header = this.reader.readNextFrameHeader();\n            if (!header) {\n                break;\n            }\n            // Check if the entire frame fits in the loaded data\n            if (header.startPos + header.totalSize > this.lastLoadedPos) {\n                // Frame doesn't fit, reset positions and stop\n                this.reader.pos = startPos;\n                this.lastLoadedPos = startPos; // Snap this back too so that the next read is frame-aligned\n                break;\n            }\n            const xingOffset = getXingOffset(header.mpegVersionId, header.channel);\n            this.reader.pos = header.startPos + xingOffset;\n            const word = this.reader.readU32();\n            const isXing = word === XING || word === INFO;\n            this.reader.pos = header.startPos + header.totalSize - 1; // -1 in case the frame is 1 byte too short\n            if (isXing) {\n                // There's no actual audio data in this frame, so let's skip it\n                continue;\n            }\n            if (!this.firstFrameHeader) {\n                this.firstFrameHeader = header;\n            }\n            const sampleDuration = header.audioSamplesInFrame / header.sampleRate;\n            const sample = {\n                timestamp: this.nextTimestampInSamples / header.sampleRate,\n                duration: sampleDuration,\n                dataStart: header.startPos,\n                dataSize: header.totalSize,\n            };\n            this.loadedSamples.push(sample);\n            this.nextTimestampInSamples += header.audioSamplesInFrame;\n        }\n    }\n    async getMimeType() {\n        return 'audio/mpeg';\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks;\n    }\n    async computeDuration() {\n        await this.readMetadata();\n        const track = this.tracks[0];\n        assert(track);\n        return track.computeDuration();\n    }\n}\nclass Mp3AudioTrackBacking {\n    constructor(demuxer) {\n        this.demuxer = demuxer;\n    }\n    getId() {\n        return 1;\n    }\n    async getFirstTimestamp() {\n        return 0;\n    }\n    getTimeResolution() {\n        assert(this.demuxer.firstFrameHeader);\n        return this.demuxer.firstFrameHeader.sampleRate / this.demuxer.firstFrameHeader.audioSamplesInFrame;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    getLanguageCode() {\n        return UNDETERMINED_LANGUAGE;\n    }\n    getCodec() {\n        return 'mp3';\n    }\n    getNumberOfChannels() {\n        assert(this.demuxer.firstFrameHeader);\n        return this.demuxer.firstFrameHeader.channel === 3 ? 1 : 2;\n    }\n    getSampleRate() {\n        assert(this.demuxer.firstFrameHeader);\n        return this.demuxer.firstFrameHeader.sampleRate;\n    }\n    async getDecoderConfig() {\n        assert(this.demuxer.firstFrameHeader);\n        return {\n            codec: 'mp3',\n            numberOfChannels: this.demuxer.firstFrameHeader.channel === 3 ? 1 : 2,\n            sampleRate: this.demuxer.firstFrameHeader.sampleRate,\n        };\n    }\n    getPacketAtIndex(sampleIndex, options) {\n        if (sampleIndex === -1) {\n            return null;\n        }\n        const rawSample = this.demuxer.loadedSamples[sampleIndex];\n        if (!rawSample) {\n            return null;\n        }\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            this.demuxer.reader.pos = rawSample.dataStart;\n            data = this.demuxer.reader.readBytes(rawSample.dataSize);\n        }\n        return new EncodedPacket(data, 'key', rawSample.timestamp, rawSample.duration, sampleIndex, rawSample.dataSize);\n    }\n    async getFirstPacket(options) {\n        return this.getPacketAtIndex(0, options);\n    }\n    async getNextPacket(packet, options) {\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            const sampleIndex = binarySearchExact(this.demuxer.loadedSamples, packet.timestamp, x => x.timestamp);\n            if (sampleIndex === -1) {\n                throw new Error('Packet was not created from this track.');\n            }\n            const nextIndex = sampleIndex + 1;\n            // Ensure the next sample exists\n            while (nextIndex >= this.demuxer.loadedSamples.length\n                && this.demuxer.lastLoadedPos < this.demuxer.fileSize) {\n                await this.demuxer.loadNextChunk();\n            }\n            return this.getPacketAtIndex(nextIndex, options);\n        }\n        finally {\n            release();\n        }\n    }\n    async getPacket(timestamp, options) {\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            while (true) {\n                const index = binarySearchLessOrEqual(this.demuxer.loadedSamples, timestamp, x => x.timestamp);\n                if (index === -1 && this.demuxer.loadedSamples.length > 0) {\n                    // We're before the first sample\n                    return null;\n                }\n                if (this.demuxer.lastLoadedPos === this.demuxer.fileSize) {\n                    // All data is loaded, return what we found\n                    return this.getPacketAtIndex(index, options);\n                }\n                if (index >= 0 && index + 1 < this.demuxer.loadedSamples.length) {\n                    // The next packet also exists, we're done\n                    return this.getPacketAtIndex(index, options);\n                }\n                // Otherwise, keep loading data\n                await this.demuxer.loadNextChunk();\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    getKeyPacket(timestamp, options) {\n        return this.getPacket(timestamp, options);\n    }\n    getNextKeyPacket(packet, options) {\n        return this.getNextPacket(packet, options);\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AACD;AACA;AACA;AACA;AACA;AACA;;;;;;;AACO,MAAM,mBAAmB,qNAAA,CAAA,UAAO;IACnC,YAAY,KAAK,CAAE;QACf,KAAK,CAAC;QACN,IAAI,CAAC,eAAe,GAAG;QACvB,IAAI,CAAC,gBAAgB,GAAG;QACxB,IAAI,CAAC,aAAa,GAAG,EAAE,EAAE,0DAA0D;QACnF,IAAI,CAAC,MAAM,GAAG,EAAE;QAChB,IAAI,CAAC,YAAY,GAAG,IAAI,kNAAA,CAAA,aAAU;QAClC,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,sBAAsB,GAAG;QAC9B,IAAI,CAAC,MAAM,GAAG,IAAI,kOAAA,CAAA,YAAS,CAAC,MAAM,WAAW;IACjD;IACA,MAAM,eAAe;QACjB,OAAO,IAAI,CAAC,eAAe,KAAK,CAAC;YAC7B,IAAI,CAAC,QAAQ,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO;YAC/C,IAAI,CAAC,MAAM,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ;YACpC,oDAAoD;YACpD,MAAO,CAAC,IAAI,CAAC,gBAAgB,IAAI,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAE;gBACjE,MAAM,IAAI,CAAC,aAAa;YAC5B;YACA,uDAAuD;YACvD,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,gBAAgB;YAC5B,IAAI,CAAC,MAAM,GAAG;gBAAC,IAAI,4NAAA,CAAA,kBAAe,CAAC,IAAI,qBAAqB,IAAI;aAAG;QACvE,CAAC;IACL;IACA,sCAAsC,GACtC,MAAM,gBAAgB;QAClB,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ;QACzC,MAAM,YAAY,MAAM,OAAO,MAAM,UAAU;QAC/C,MAAM,SAAS,KAAK,GAAG,CAAC,IAAI,CAAC,aAAa,GAAG,WAAW,IAAI,CAAC,QAAQ;QACrE,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,aAAa,EAAE;QACvD,IAAI,CAAC,aAAa,GAAG;QACrB,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,QAAQ;QAC1C,IAAI,IAAI,CAAC,MAAM,CAAC,GAAG,KAAK,GAAG;YACvB,8CAA8C;YAC9C,MAAM,SAAS,IAAI,CAAC,MAAM,CAAC,OAAO;YAClC,IAAI,QAAQ;gBACR,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,OAAO,IAAI;YAClC;QACJ;QACA,IAAI,CAAC,yBAAyB;IAClC;IACA,4BAA4B;QACxB,MAAO,KAAM;YACT,MAAM,WAAW,IAAI,CAAC,MAAM,CAAC,GAAG;YAChC,MAAM,SAAS,IAAI,CAAC,MAAM,CAAC,mBAAmB;YAC9C,IAAI,CAAC,QAAQ;gBACT;YACJ;YACA,oDAAoD;YACpD,IAAI,OAAO,QAAQ,GAAG,OAAO,SAAS,GAAG,IAAI,CAAC,aAAa,EAAE;gBACzD,8CAA8C;gBAC9C,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG;gBAClB,IAAI,CAAC,aAAa,GAAG,UAAU,4DAA4D;gBAC3F;YACJ;YACA,MAAM,aAAa,CAAA,GAAA,4NAAA,CAAA,gBAAa,AAAD,EAAE,OAAO,aAAa,EAAE,OAAO,OAAO;YACrE,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG,OAAO,QAAQ,GAAG;YACpC,MAAM,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO;YAChC,MAAM,SAAS,SAAS,4NAAA,CAAA,OAAI,IAAI,SAAS,4NAAA,CAAA,OAAI;YAC7C,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG,OAAO,QAAQ,GAAG,OAAO,SAAS,GAAG,GAAG,2CAA2C;YACrG,IAAI,QAAQ;gBAER;YACJ;YACA,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE;gBACxB,IAAI,CAAC,gBAAgB,GAAG;YAC5B;YACA,MAAM,iBAAiB,OAAO,mBAAmB,GAAG,OAAO,UAAU;YACrE,MAAM,SAAS;gBACX,WAAW,IAAI,CAAC,sBAAsB,GAAG,OAAO,UAAU;gBAC1D,UAAU;gBACV,WAAW,OAAO,QAAQ;gBAC1B,UAAU,OAAO,SAAS;YAC9B;YACA,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC;YACxB,IAAI,CAAC,sBAAsB,IAAI,OAAO,mBAAmB;QAC7D;IACJ;IACA,MAAM,cAAc;QAChB,OAAO;IACX;IACA,MAAM,YAAY;QACd,MAAM,IAAI,CAAC,YAAY;QACvB,OAAO,IAAI,CAAC,MAAM;IACtB;IACA,MAAM,kBAAkB;QACpB,MAAM,IAAI,CAAC,YAAY;QACvB,MAAM,QAAQ,IAAI,CAAC,MAAM,CAAC,EAAE;QAC5B,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE;QACP,OAAO,MAAM,eAAe;IAChC;AACJ;AACA,MAAM;IACF,YAAY,OAAO,CAAE;QACjB,IAAI,CAAC,OAAO,GAAG;IACnB;IACA,QAAQ;QACJ,OAAO;IACX;IACA,MAAM,oBAAoB;QACtB,OAAO;IACX;IACA,oBAAoB;QAChB,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,gBAAgB;QACpC,OAAO,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,mBAAmB;IACvG;IACA,MAAM,kBAAkB;QACpB,MAAM,aAAa,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU;YAAE,cAAc;QAAK;QACvE,OAAO,CAAC,YAAY,aAAa,CAAC,IAAI,CAAC,YAAY,YAAY,CAAC;IACpE;IACA,kBAAkB;QACd,OAAO,kNAAA,CAAA,wBAAqB;IAChC;IACA,WAAW;QACP,OAAO;IACX;IACA,sBAAsB;QAClB,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,gBAAgB;QACpC,OAAO,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,OAAO,KAAK,IAAI,IAAI;IAC7D;IACA,gBAAgB;QACZ,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,gBAAgB;QACpC,OAAO,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,UAAU;IACnD;IACA,MAAM,mBAAmB;QACrB,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,gBAAgB;QACpC,OAAO;YACH,OAAO;YACP,kBAAkB,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,OAAO,KAAK,IAAI,IAAI;YACpE,YAAY,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,UAAU;QACxD;IACJ;IACA,iBAAiB,WAAW,EAAE,OAAO,EAAE;QACnC,IAAI,gBAAgB,CAAC,GAAG;YACpB,OAAO;QACX;QACA,MAAM,YAAY,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,YAAY;QACzD,IAAI,CAAC,WAAW;YACZ,OAAO;QACX;QACA,IAAI;QACJ,IAAI,QAAQ,YAAY,EAAE;YACtB,OAAO,oNAAA,CAAA,mBAAgB;QAC3B,OACK;YACD,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,GAAG,UAAU,SAAS;YAC7C,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,UAAU,QAAQ;QAC3D;QACA,OAAO,IAAI,oNAAA,CAAA,gBAAa,CAAC,MAAM,OAAO,UAAU,SAAS,EAAE,UAAU,QAAQ,EAAE,aAAa,UAAU,QAAQ;IAClH;IACA,MAAM,eAAe,OAAO,EAAE;QAC1B,OAAO,IAAI,CAAC,gBAAgB,CAAC,GAAG;IACpC;IACA,MAAM,cAAc,MAAM,EAAE,OAAO,EAAE;QACjC,MAAM,UAAU,MAAM,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,OAAO;QACvD,IAAI;YACA,MAAM,cAAc,CAAA,GAAA,kNAAA,CAAA,oBAAiB,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,OAAO,SAAS,EAAE,CAAA,IAAK,EAAE,SAAS;YACpG,IAAI,gBAAgB,CAAC,GAAG;gBACpB,MAAM,IAAI,MAAM;YACpB;YACA,MAAM,YAAY,cAAc;YAChC,gCAAgC;YAChC,MAAO,aAAa,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,MAAM,IAC9C,IAAI,CAAC,OAAO,CAAC,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAE;gBACvD,MAAM,IAAI,CAAC,OAAO,CAAC,aAAa;YACpC;YACA,OAAO,IAAI,CAAC,gBAAgB,CAAC,WAAW;QAC5C,SACQ;YACJ;QACJ;IACJ;IACA,MAAM,UAAU,SAAS,EAAE,OAAO,EAAE;QAChC,MAAM,UAAU,MAAM,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,OAAO;QACvD,IAAI;YACA,MAAO,KAAM;gBACT,MAAM,QAAQ,CAAA,GAAA,kNAAA,CAAA,0BAAuB,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,WAAW,CAAA,IAAK,EAAE,SAAS;gBAC7F,IAAI,UAAU,CAAC,KAAK,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,MAAM,GAAG,GAAG;oBACvD,gCAAgC;oBAChC,OAAO;gBACX;gBACA,IAAI,IAAI,CAAC,OAAO,CAAC,aAAa,KAAK,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE;oBACtD,2CAA2C;oBAC3C,OAAO,IAAI,CAAC,gBAAgB,CAAC,OAAO;gBACxC;gBACA,IAAI,SAAS,KAAK,QAAQ,IAAI,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,MAAM,EAAE;oBAC7D,0CAA0C;oBAC1C,OAAO,IAAI,CAAC,gBAAgB,CAAC,OAAO;gBACxC;gBACA,+BAA+B;gBAC/B,MAAM,IAAI,CAAC,OAAO,CAAC,aAAa;YACpC;QACJ,SACQ;YACJ;QACJ;IACJ;IACA,aAAa,SAAS,EAAE,OAAO,EAAE;QAC7B,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW;IACrC;IACA,iBAAiB,MAAM,EAAE,OAAO,EAAE;QAC9B,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ;IACtC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10903, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/ogg/ogg-misc.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { parseOpusTocByte } from '../codec-data.js';\nimport { assert, ilog, toDataView } from '../misc.js';\nexport const OGGS = 0x5367674f; // 'OggS'\nconst OGG_CRC_POLYNOMIAL = 0x04c11db7;\nconst OGG_CRC_TABLE = new Uint32Array(256);\nfor (let n = 0; n < 256; n++) {\n    let crc = n << 24;\n    for (let k = 0; k < 8; k++) {\n        crc = (crc & 0x80000000)\n            ? ((crc << 1) ^ OGG_CRC_POLYNOMIAL)\n            : (crc << 1);\n    }\n    OGG_CRC_TABLE[n] = (crc >>> 0) & 0xffffffff;\n}\nexport const computeOggPageCrc = (bytes) => {\n    const view = toDataView(bytes);\n    const originalChecksum = view.getUint32(22, true);\n    view.setUint32(22, 0, true); // Zero out checksum field\n    let crc = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const byte = bytes[i];\n        crc = ((crc << 8) ^ OGG_CRC_TABLE[(crc >>> 24) ^ byte]) >>> 0;\n    }\n    view.setUint32(22, originalChecksum, true); // Restore checksum field\n    return crc;\n};\nexport const extractSampleMetadata = (data, codecInfo, vorbisLastBlocksize) => {\n    let durationInSamples = 0;\n    let currentBlocksize = null;\n    if (data.length > 0) {\n        // To know sample duration, we'll need to peak inside the packet\n        if (codecInfo.codec === 'vorbis') {\n            assert(codecInfo.vorbisInfo);\n            const vorbisModeCount = codecInfo.vorbisInfo.modeBlockflags.length;\n            const bitCount = ilog(vorbisModeCount - 1);\n            const modeMask = ((1 << bitCount) - 1) << 1;\n            const modeNumber = (data[0] & modeMask) >> 1;\n            if (modeNumber >= codecInfo.vorbisInfo.modeBlockflags.length) {\n                throw new Error('Invalid mode number.');\n            }\n            // In Vorbis, packet duration also depends on the blocksize of the previous packet\n            let prevBlocksize = vorbisLastBlocksize;\n            const blockflag = codecInfo.vorbisInfo.modeBlockflags[modeNumber];\n            currentBlocksize = codecInfo.vorbisInfo.blocksizes[blockflag];\n            if (blockflag === 1) {\n                const prevMask = (modeMask | 0x1) + 1;\n                const flag = data[0] & prevMask ? 1 : 0;\n                prevBlocksize = codecInfo.vorbisInfo.blocksizes[flag];\n            }\n            durationInSamples = prevBlocksize !== null\n                ? (prevBlocksize + currentBlocksize) >> 2\n                : 0; // The first sample outputs no audio data and therefore has a duration of 0\n        }\n        else if (codecInfo.codec === 'opus') {\n            const toc = parseOpusTocByte(data);\n            durationInSamples = toc.durationInSamples;\n        }\n    }\n    return {\n        durationInSamples,\n        vorbisBlockSize: currentBlocksize,\n    };\n};\nexport const buildOggMimeType = (info) => {\n    let string = 'audio/ogg';\n    if (info.codecStrings) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings)];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;AACD;AACA;;;AACO,MAAM,OAAO,YAAY,SAAS;AACzC,MAAM,qBAAqB;AAC3B,MAAM,gBAAgB,IAAI,YAAY;AACtC,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;IAC1B,IAAI,MAAM,KAAK;IACf,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;QACxB,MAAM,AAAC,MAAM,aACN,AAAC,OAAO,IAAK,qBACb,OAAO;IAClB;IACA,aAAa,CAAC,EAAE,GAAG,AAAC,QAAQ,IAAK;AACrC;AACO,MAAM,oBAAoB,CAAC;IAC9B,MAAM,OAAO,CAAA,GAAA,kNAAA,CAAA,aAAU,AAAD,EAAE;IACxB,MAAM,mBAAmB,KAAK,SAAS,CAAC,IAAI;IAC5C,KAAK,SAAS,CAAC,IAAI,GAAG,OAAO,0BAA0B;IACvD,IAAI,MAAM;IACV,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;QACnC,MAAM,OAAO,KAAK,CAAC,EAAE;QACrB,MAAM,CAAC,AAAC,OAAO,IAAK,aAAa,CAAC,AAAC,QAAQ,KAAM,KAAK,MAAM;IAChE;IACA,KAAK,SAAS,CAAC,IAAI,kBAAkB,OAAO,yBAAyB;IACrE,OAAO;AACX;AACO,MAAM,wBAAwB,CAAC,MAAM,WAAW;IACnD,IAAI,oBAAoB;IACxB,IAAI,mBAAmB;IACvB,IAAI,KAAK,MAAM,GAAG,GAAG;QACjB,gEAAgE;QAChE,IAAI,UAAU,KAAK,KAAK,UAAU;YAC9B,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,UAAU,UAAU;YAC3B,MAAM,kBAAkB,UAAU,UAAU,CAAC,cAAc,CAAC,MAAM;YAClE,MAAM,WAAW,CAAA,GAAA,kNAAA,CAAA,OAAI,AAAD,EAAE,kBAAkB;YACxC,MAAM,WAAW,AAAC,CAAC,KAAK,QAAQ,IAAI,KAAM;YAC1C,MAAM,aAAa,CAAC,IAAI,CAAC,EAAE,GAAG,QAAQ,KAAK;YAC3C,IAAI,cAAc,UAAU,UAAU,CAAC,cAAc,CAAC,MAAM,EAAE;gBAC1D,MAAM,IAAI,MAAM;YACpB;YACA,kFAAkF;YAClF,IAAI,gBAAgB;YACpB,MAAM,YAAY,UAAU,UAAU,CAAC,cAAc,CAAC,WAAW;YACjE,mBAAmB,UAAU,UAAU,CAAC,UAAU,CAAC,UAAU;YAC7D,IAAI,cAAc,GAAG;gBACjB,MAAM,WAAW,CAAC,WAAW,GAAG,IAAI;gBACpC,MAAM,OAAO,IAAI,CAAC,EAAE,GAAG,WAAW,IAAI;gBACtC,gBAAgB,UAAU,UAAU,CAAC,UAAU,CAAC,KAAK;YACzD;YACA,oBAAoB,kBAAkB,OAChC,AAAC,gBAAgB,oBAAqB,IACtC,GAAG,2EAA2E;QACxF,OACK,IAAI,UAAU,KAAK,KAAK,QAAQ;YACjC,MAAM,MAAM,CAAA,GAAA,2NAAA,CAAA,mBAAgB,AAAD,EAAE;YAC7B,oBAAoB,IAAI,iBAAiB;QAC7C;IACJ;IACA,OAAO;QACH;QACA,iBAAiB;IACrB;AACJ;AACO,MAAM,mBAAmB,CAAC;IAC7B,IAAI,SAAS;IACb,IAAI,KAAK,YAAY,EAAE;QACnB,MAAM,uBAAuB;eAAI,IAAI,IAAI,KAAK,YAAY;SAAE;QAC5D,UAAU,CAAC,UAAU,EAAE,qBAAqB,IAAI,CAAC,MAAM,CAAC,CAAC;IAC7D;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10989, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/ogg/ogg-reader.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { OGGS } from './ogg-misc.js';\nexport const MIN_PAGE_HEADER_SIZE = 27;\nexport const MAX_PAGE_HEADER_SIZE = 27 + 255;\nexport const MAX_PAGE_SIZE = MAX_PAGE_HEADER_SIZE + 255 * 255;\nexport class OggReader {\n    constructor(reader) {\n        this.reader = reader;\n        this.pos = 0;\n    }\n    readBytes(length) {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + length);\n        this.pos += length;\n        return new Uint8Array(view.buffer, offset, length);\n    }\n    readU8() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 1);\n        this.pos += 1;\n        return view.getUint8(offset);\n    }\n    readU32() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 4);\n        this.pos += 4;\n        return view.getUint32(offset, true);\n    }\n    readI32() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 4);\n        this.pos += 4;\n        return view.getInt32(offset, true);\n    }\n    readI64() {\n        const low = this.readU32();\n        const high = this.readI32();\n        return high * 0x100000000 + low;\n    }\n    readAscii(length) {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + length);\n        this.pos += length;\n        let str = '';\n        for (let i = 0; i < length; i++) {\n            str += String.fromCharCode(view.getUint8(offset + i));\n        }\n        return str;\n    }\n    readPageHeader() {\n        const startPos = this.pos;\n        const capturePattern = this.readU32();\n        if (capturePattern !== OGGS) {\n            return null;\n        }\n        this.pos += 1; // Version\n        const headerType = this.readU8();\n        const granulePosition = this.readI64();\n        const serialNumber = this.readU32();\n        const sequenceNumber = this.readU32();\n        const checksum = this.readU32();\n        const numberPageSegments = this.readU8();\n        const lacingValues = new Uint8Array(numberPageSegments);\n        for (let i = 0; i < numberPageSegments; i++) {\n            lacingValues[i] = this.readU8();\n        }\n        const headerSize = 27 + numberPageSegments;\n        const dataSize = lacingValues.reduce((a, b) => a + b, 0);\n        const totalSize = headerSize + dataSize;\n        return {\n            headerStartPos: startPos,\n            totalSize,\n            dataStartPos: startPos + headerSize,\n            dataSize,\n            headerType,\n            granulePosition,\n            serialNumber,\n            sequenceNumber,\n            checksum,\n            lacingValues,\n        };\n    }\n    findNextPageHeader(until) {\n        while (this.pos < until - (4 - 1)) { // Size of word minus 1\n            const word = this.readU32();\n            const firstByte = word & 0xff;\n            const secondByte = (word >>> 8) & 0xff;\n            const thirdByte = (word >>> 16) & 0xff;\n            const fourthByte = (word >>> 24) & 0xff;\n            const O = 0x4f; // 'O'\n            if (firstByte !== O && secondByte !== O && thirdByte !== O && fourthByte !== O) {\n                continue;\n            }\n            this.pos -= 4;\n            if (word === OGGS) {\n                // We have found the capture pattern\n                return true;\n            }\n            this.pos += 1;\n        }\n        return false;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11103, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/ogg/ogg-demuxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { OPUS_INTERNAL_SAMPLE_RATE } from '../codec.js';\nimport { parseModesFromVorbisSetupPacket, parseOpusIdentificationHeader } from '../codec-data.js';\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack } from '../input-track.js';\nimport { assert, AsyncMutex, findLast, roundToPrecision, toDataView, UNDETERMINED_LANGUAGE } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { Reader } from '../reader.js';\nimport { buildOggMimeType, computeOggPageCrc, extractSampleMetadata } from './ogg-misc.js';\nimport { MAX_PAGE_HEADER_SIZE, MAX_PAGE_SIZE, MIN_PAGE_HEADER_SIZE, OggReader } from './ogg-reader.js';\nexport class OggDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        /**\n         * Lots of reading operations require multiple async reads and thus need to be mutually exclusive to avoid\n         * conflicts in reader position.\n         */\n        this.readingMutex = new AsyncMutex();\n        this.metadataPromise = null;\n        this.fileSize = null;\n        this.bitstreams = [];\n        this.tracks = [];\n        // We don't need a persistent metadata reader as we read all metadata once at the start and then never again\n        this.reader = new OggReader(new Reader(input.source, 64 * 2 ** 20));\n    }\n    async readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            this.fileSize = await this.input.source.getSize();\n            while (this.reader.pos < this.fileSize - MIN_PAGE_HEADER_SIZE) {\n                await this.reader.reader.loadRange(this.reader.pos, this.reader.pos + MAX_PAGE_HEADER_SIZE);\n                const page = this.reader.readPageHeader();\n                if (!page) {\n                    break;\n                }\n                const isBos = !!(page.headerType & 0x02);\n                if (!isBos) {\n                    // All bos pages for all bitstreams are required to be at the start, so if the page is not bos then\n                    // we know we've seen all bitstreams (minus chaining)\n                    break;\n                }\n                this.bitstreams.push({\n                    serialNumber: page.serialNumber,\n                    bosPage: page,\n                    description: null,\n                    numberOfChannels: -1,\n                    sampleRate: -1,\n                    codecInfo: {\n                        codec: null,\n                        vorbisInfo: null,\n                        opusInfo: null,\n                    },\n                    lastMetadataPacket: null,\n                });\n                this.reader.pos = page.headerStartPos + page.totalSize;\n            }\n            for (const bitstream of this.bitstreams) {\n                const firstPacket = await this.readPacket(this.reader, bitstream.bosPage, 0);\n                if (!firstPacket) {\n                    continue;\n                }\n                if (\n                // Check for Vorbis\n                firstPacket.data.byteLength >= 7\n                    && firstPacket.data[0] === 0x01 // Packet type 1 = identification header\n                    && firstPacket.data[1] === 0x76 // 'v'\n                    && firstPacket.data[2] === 0x6f // 'o'\n                    && firstPacket.data[3] === 0x72 // 'r'\n                    && firstPacket.data[4] === 0x62 // 'b'\n                    && firstPacket.data[5] === 0x69 // 'i'\n                    && firstPacket.data[6] === 0x73 // 's'\n                ) {\n                    await this.readVorbisMetadata(firstPacket, bitstream);\n                }\n                else if (\n                // Check for Opus\n                firstPacket.data.byteLength >= 8\n                    && firstPacket.data[0] === 0x4f // 'O'\n                    && firstPacket.data[1] === 0x70 // 'p'\n                    && firstPacket.data[2] === 0x75 // 'u'\n                    && firstPacket.data[3] === 0x73 // 's'\n                    && firstPacket.data[4] === 0x48 // 'H'\n                    && firstPacket.data[5] === 0x65 // 'e'\n                    && firstPacket.data[6] === 0x61 // 'a'\n                    && firstPacket.data[7] === 0x64 // 'd'\n                ) {\n                    await this.readOpusMetadata(firstPacket, bitstream);\n                }\n                if (bitstream.codecInfo.codec !== null) {\n                    this.tracks.push(new InputAudioTrack(new OggAudioTrackBacking(bitstream, this)));\n                }\n            }\n        })();\n    }\n    async readVorbisMetadata(firstPacket, bitstream) {\n        let nextPacketPosition = await this.findNextPacketStart(this.reader, firstPacket);\n        if (!nextPacketPosition) {\n            return;\n        }\n        const secondPacket = await this.readPacket(this.reader, nextPacketPosition.startPage, nextPacketPosition.startSegmentIndex);\n        if (!secondPacket) {\n            return;\n        }\n        nextPacketPosition = await this.findNextPacketStart(this.reader, secondPacket);\n        if (!nextPacketPosition) {\n            return;\n        }\n        const thirdPacket = await this.readPacket(this.reader, nextPacketPosition.startPage, nextPacketPosition.startSegmentIndex);\n        if (!thirdPacket) {\n            return;\n        }\n        if (secondPacket.data[0] !== 0x03 || thirdPacket.data[0] !== 0x05) {\n            return;\n        }\n        const lacingValues = [];\n        const addBytesToSegmentTable = (bytes) => {\n            while (true) {\n                lacingValues.push(Math.min(255, bytes));\n                if (bytes < 255) {\n                    break;\n                }\n                bytes -= 255;\n            }\n        };\n        addBytesToSegmentTable(firstPacket.data.length);\n        addBytesToSegmentTable(secondPacket.data.length);\n        // We don't add the last packet to the segment table, as it is assumed to be whatever bytes remain\n        const description = new Uint8Array(1 + lacingValues.length\n            + firstPacket.data.length + secondPacket.data.length + thirdPacket.data.length);\n        description[0] = lacingValues.length;\n        description.set(lacingValues, 1);\n        description.set(firstPacket.data, 1 + lacingValues.length);\n        description.set(secondPacket.data, 1 + lacingValues.length + firstPacket.data.length);\n        description.set(thirdPacket.data, 1 + lacingValues.length + firstPacket.data.length + secondPacket.data.length);\n        bitstream.codecInfo.codec = 'vorbis';\n        bitstream.description = description;\n        bitstream.lastMetadataPacket = thirdPacket;\n        const view = toDataView(firstPacket.data);\n        bitstream.numberOfChannels = view.getUint8(11);\n        bitstream.sampleRate = view.getUint32(12, true);\n        const blockSizeByte = view.getUint8(28);\n        bitstream.codecInfo.vorbisInfo = {\n            blocksizes: [\n                1 << (blockSizeByte & 0xf),\n                1 << (blockSizeByte >> 4),\n            ],\n            modeBlockflags: parseModesFromVorbisSetupPacket(thirdPacket.data).modeBlockflags,\n        };\n    }\n    async readOpusMetadata(firstPacket, bitstream) {\n        // From https://datatracker.ietf.org/doc/html/rfc7845#section-5:\n        // \"An Ogg Opus logical stream contains exactly two mandatory header packets: an identification header and a\n        // comment header.\"\n        const nextPacketPosition = await this.findNextPacketStart(this.reader, firstPacket);\n        if (!nextPacketPosition) {\n            return;\n        }\n        const secondPacket = await this.readPacket(this.reader, nextPacketPosition.startPage, nextPacketPosition.startSegmentIndex);\n        if (!secondPacket) {\n            return;\n        }\n        // We don't make use of the comment header's data\n        bitstream.codecInfo.codec = 'opus';\n        bitstream.description = firstPacket.data;\n        bitstream.lastMetadataPacket = secondPacket;\n        const header = parseOpusIdentificationHeader(firstPacket.data);\n        bitstream.numberOfChannels = header.outputChannelCount;\n        bitstream.sampleRate = header.inputSampleRate;\n        bitstream.codecInfo.opusInfo = {\n            preSkip: header.preSkip,\n        };\n    }\n    async readPacket(reader, startPage, startSegmentIndex) {\n        assert(startSegmentIndex < startPage.lacingValues.length);\n        assert(this.fileSize);\n        let startDataOffset = 0;\n        for (let i = 0; i < startSegmentIndex; i++) {\n            startDataOffset += startPage.lacingValues[i];\n        }\n        let currentPage = startPage;\n        let currentDataOffset = startDataOffset;\n        let currentSegmentIndex = startSegmentIndex;\n        const chunks = [];\n        outer: while (true) {\n            // Load the entire page data\n            await reader.reader.loadRange(currentPage.dataStartPos, currentPage.dataStartPos + currentPage.dataSize);\n            reader.pos = currentPage.dataStartPos;\n            const pageData = reader.readBytes(currentPage.dataSize);\n            while (true) {\n                if (currentSegmentIndex === currentPage.lacingValues.length) {\n                    chunks.push(pageData.subarray(startDataOffset, currentDataOffset));\n                    break;\n                }\n                const lacingValue = currentPage.lacingValues[currentSegmentIndex];\n                currentDataOffset += lacingValue;\n                if (lacingValue < 255) {\n                    chunks.push(pageData.subarray(startDataOffset, currentDataOffset));\n                    break outer;\n                }\n                currentSegmentIndex++;\n            }\n            // The packet extends to the next page; let's find it\n            while (true) {\n                reader.pos = currentPage.headerStartPos + currentPage.totalSize;\n                if (reader.pos >= this.fileSize - MIN_PAGE_HEADER_SIZE) {\n                    return null;\n                }\n                await reader.reader.loadRange(reader.pos, reader.pos + MAX_PAGE_HEADER_SIZE);\n                const nextPage = reader.readPageHeader();\n                if (!nextPage) {\n                    return null;\n                }\n                currentPage = nextPage;\n                if (currentPage.serialNumber === startPage.serialNumber) {\n                    break;\n                }\n            }\n            startDataOffset = 0;\n            currentDataOffset = 0;\n            currentSegmentIndex = 0;\n        }\n        const totalPacketSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n        const packetData = new Uint8Array(totalPacketSize);\n        let offset = 0;\n        for (let i = 0; i < chunks.length; i++) {\n            const chunk = chunks[i];\n            packetData.set(chunk, offset);\n            offset += chunk.length;\n        }\n        return {\n            data: packetData,\n            endPage: currentPage,\n            endSegmentIndex: currentSegmentIndex,\n        };\n    }\n    async findNextPacketStart(reader, lastPacket) {\n        assert(this.fileSize !== null);\n        // If there's another segment in the same page, return it\n        if (lastPacket.endSegmentIndex < lastPacket.endPage.lacingValues.length - 1) {\n            return { startPage: lastPacket.endPage, startSegmentIndex: lastPacket.endSegmentIndex + 1 };\n        }\n        const isEos = !!(lastPacket.endPage.headerType & 0x04);\n        if (isEos) {\n            // The page is marked as the last page of the logical bitstream, so we won't find anything beyond it\n            return null;\n        }\n        // Otherwise, search for the next page belonging to the same bitstream\n        reader.pos = lastPacket.endPage.headerStartPos + lastPacket.endPage.totalSize;\n        while (true) {\n            if (reader.pos >= this.fileSize - MIN_PAGE_HEADER_SIZE) {\n                return null;\n            }\n            await reader.reader.loadRange(reader.pos, reader.pos + MAX_PAGE_HEADER_SIZE);\n            const nextPage = reader.readPageHeader();\n            if (!nextPage) {\n                return null;\n            }\n            if (nextPage.serialNumber === lastPacket.endPage.serialNumber) {\n                return { startPage: nextPage, startSegmentIndex: 0 };\n            }\n            reader.pos = nextPage.headerStartPos + nextPage.totalSize;\n        }\n    }\n    async getMimeType() {\n        await this.readMetadata();\n        const codecStrings = await Promise.all(this.tracks.map(x => x.getCodecParameterString()));\n        return buildOggMimeType({\n            codecStrings: codecStrings.filter(Boolean),\n        });\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks;\n    }\n    async computeDuration() {\n        const tracks = await this.getTracks();\n        const trackDurations = await Promise.all(tracks.map(x => x.computeDuration()));\n        return Math.max(0, ...trackDurations);\n    }\n}\nclass OggAudioTrackBacking {\n    constructor(bitstream, demuxer) {\n        this.bitstream = bitstream;\n        this.demuxer = demuxer;\n        this.encodedPacketToMetadata = new WeakMap();\n        // Opus always uses a fixed sample rate for its internal calculations, even if the actual rate is different\n        this.internalSampleRate = bitstream.codecInfo.codec === 'opus'\n            ? OPUS_INTERNAL_SAMPLE_RATE\n            : bitstream.sampleRate;\n    }\n    getId() {\n        return this.bitstream.serialNumber;\n    }\n    getNumberOfChannels() {\n        return this.bitstream.numberOfChannels;\n    }\n    getSampleRate() {\n        return this.bitstream.sampleRate;\n    }\n    getTimeResolution() {\n        return this.bitstream.sampleRate;\n    }\n    getCodec() {\n        return this.bitstream.codecInfo.codec;\n    }\n    async getDecoderConfig() {\n        assert(this.bitstream.codecInfo.codec);\n        return {\n            codec: this.bitstream.codecInfo.codec,\n            numberOfChannels: this.bitstream.numberOfChannels,\n            sampleRate: this.bitstream.sampleRate,\n            description: this.bitstream.description ?? undefined,\n        };\n    }\n    getLanguageCode() {\n        return UNDETERMINED_LANGUAGE;\n    }\n    async getFirstTimestamp() {\n        return 0;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    granulePositionToTimestampInSamples(granulePosition) {\n        if (this.bitstream.codecInfo.codec === 'opus') {\n            assert(this.bitstream.codecInfo.opusInfo);\n            return granulePosition - this.bitstream.codecInfo.opusInfo.preSkip;\n        }\n        return granulePosition;\n    }\n    createEncodedPacketFromOggPacket(packet, additional, options) {\n        if (!packet) {\n            return null;\n        }\n        const { durationInSamples, vorbisBlockSize } = extractSampleMetadata(packet.data, this.bitstream.codecInfo, additional.vorbisLastBlocksize);\n        const encodedPacket = new EncodedPacket(options.metadataOnly ? PLACEHOLDER_DATA : packet.data, 'key', Math.max(0, additional.timestampInSamples) / this.internalSampleRate, durationInSamples / this.internalSampleRate, packet.endPage.headerStartPos + packet.endSegmentIndex, packet.data.byteLength);\n        this.encodedPacketToMetadata.set(encodedPacket, {\n            packet,\n            timestampInSamples: additional.timestampInSamples,\n            durationInSamples,\n            vorbisBlockSize,\n        });\n        return encodedPacket;\n    }\n    async getFirstPacket(options, exclusive = true) {\n        const release = exclusive ? await this.demuxer.readingMutex.acquire() : null;\n        try {\n            assert(this.bitstream.lastMetadataPacket);\n            const packetPosition = await this.demuxer.findNextPacketStart(this.demuxer.reader, this.bitstream.lastMetadataPacket);\n            if (!packetPosition) {\n                return null;\n            }\n            let timestampInSamples = 0;\n            if (this.bitstream.codecInfo.codec === 'opus') {\n                assert(this.bitstream.codecInfo.opusInfo);\n                timestampInSamples -= this.bitstream.codecInfo.opusInfo.preSkip;\n            }\n            const packet = await this.demuxer.readPacket(this.demuxer.reader, packetPosition.startPage, packetPosition.startSegmentIndex);\n            return this.createEncodedPacketFromOggPacket(packet, {\n                timestampInSamples,\n                vorbisLastBlocksize: null,\n            }, options);\n        }\n        finally {\n            release?.();\n        }\n    }\n    async getNextPacket(prevPacket, options) {\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            const prevMetadata = this.encodedPacketToMetadata.get(prevPacket);\n            if (!prevMetadata) {\n                throw new Error('Packet was not created from this track.');\n            }\n            const packetPosition = await this.demuxer.findNextPacketStart(this.demuxer.reader, prevMetadata.packet);\n            if (!packetPosition) {\n                return null;\n            }\n            const timestampInSamples = prevMetadata.timestampInSamples + prevMetadata.durationInSamples;\n            const packet = await this.demuxer.readPacket(this.demuxer.reader, packetPosition.startPage, packetPosition.startSegmentIndex);\n            return this.createEncodedPacketFromOggPacket(packet, {\n                timestampInSamples,\n                vorbisLastBlocksize: prevMetadata.vorbisBlockSize,\n            }, options);\n        }\n        finally {\n            release();\n        }\n    }\n    async getPacket(timestamp, options) {\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            assert(this.demuxer.fileSize !== null);\n            const timestampInSamples = roundToPrecision(timestamp * this.internalSampleRate, 14);\n            if (timestampInSamples === 0) {\n                // Fast path for timestamp 0 - avoids binary search when playing back from the start\n                return this.getFirstPacket(options, false);\n            }\n            if (timestampInSamples < 0) {\n                // There's nothing here\n                return null;\n            }\n            const reader = this.demuxer.reader;\n            assert(this.bitstream.lastMetadataPacket);\n            const startPosition = await this.demuxer.findNextPacketStart(reader, this.bitstream.lastMetadataPacket);\n            if (!startPosition) {\n                return null;\n            }\n            let lowPage = startPosition.startPage;\n            let high = this.demuxer.fileSize;\n            const lowPages = [lowPage];\n            // First, let's perform a binary serach (bisection search) on the file to find the approximate page where\n            // we'll find the packet. We want to find a page whose end packet position is less than or equal to the\n            // packet position we're searching for.\n            // Outer loop: Does the binary serach\n            outer: while (lowPage.headerStartPos + lowPage.totalSize < high) {\n                const low = lowPage.headerStartPos;\n                const mid = Math.floor((low + high) / 2);\n                let searchStartPos = mid;\n                // Inner loop: Does a linear forward scan if the page cannot be found immediately\n                while (true) {\n                    const until = Math.min(searchStartPos + MAX_PAGE_SIZE, high - MIN_PAGE_HEADER_SIZE);\n                    await reader.reader.loadRange(searchStartPos, until);\n                    reader.pos = searchStartPos;\n                    const found = reader.findNextPageHeader(until);\n                    if (!found) {\n                        high = mid + MIN_PAGE_HEADER_SIZE;\n                        continue outer;\n                    }\n                    await reader.reader.loadRange(reader.pos, reader.pos + MAX_PAGE_HEADER_SIZE);\n                    const page = reader.readPageHeader();\n                    assert(page);\n                    let pageValid = false;\n                    if (page.serialNumber === this.bitstream.serialNumber) {\n                        // Serial numbers are basically random numbers, and the chance of finding a fake page with\n                        // matching serial number is astronomically low, so we can be pretty sure this page is legit.\n                        pageValid = true;\n                    }\n                    else {\n                        await reader.reader.loadRange(page.headerStartPos, page.headerStartPos + page.totalSize);\n                        // Validate the page by checking checksum\n                        reader.pos = page.headerStartPos;\n                        const bytes = reader.readBytes(page.totalSize);\n                        const crc = computeOggPageCrc(bytes);\n                        pageValid = crc === page.checksum;\n                    }\n                    if (!pageValid) {\n                        // Keep searching for a valid page\n                        searchStartPos = page.headerStartPos + 4; // 'OggS' is 4 bytes\n                        continue;\n                    }\n                    if (pageValid && page.serialNumber !== this.bitstream.serialNumber) {\n                        // Page is valid but from a different bitstream, so keep searching forward until we find one\n                        // belonging to the our bitstream\n                        searchStartPos = page.headerStartPos + page.totalSize;\n                        continue;\n                    }\n                    const isContinuationPage = page.granulePosition === -1;\n                    if (isContinuationPage) {\n                        // No packet ends on this page - keep looking\n                        searchStartPos = page.headerStartPos + page.totalSize;\n                        continue;\n                    }\n                    // The page is valid and belongs to our bitstream; let's check its granule position to see where we\n                    // need to take the bisection search.\n                    if (this.granulePositionToTimestampInSamples(page.granulePosition) > timestampInSamples) {\n                        high = page.headerStartPos;\n                    }\n                    else {\n                        lowPage = page;\n                        lowPages.push(page);\n                    }\n                    continue outer;\n                }\n            }\n            // Now we have the last page with a packet position <= the packet position we're looking for, but there\n            // might be multiple pages with the packet position, in which case we actually need to find the first of\n            // such pages. We'll do this in two steps: First, let's find the latest page we know with an earlier packet\n            // position, and then linear scan ourselves forward until we find the correct page.\n            let lowerPage = startPosition.startPage;\n            for (const otherLowPage of lowPages) {\n                if (otherLowPage.granulePosition === lowPage.granulePosition) {\n                    break;\n                }\n                if (!lowerPage || otherLowPage.headerStartPos > lowerPage.headerStartPos) {\n                    lowerPage = otherLowPage;\n                }\n            }\n            let currentPage = lowerPage;\n            // Keep track of the pages we traversed, we need these later for backwards seeking\n            const previousPages = [currentPage];\n            while (true) {\n                // This loop must terminate as we'll eventually reach lowPage\n                if (currentPage.serialNumber === this.bitstream.serialNumber\n                    && currentPage.granulePosition === lowPage.granulePosition) {\n                    break;\n                }\n                reader.pos = currentPage.headerStartPos + currentPage.totalSize;\n                await reader.reader.loadRange(reader.pos, reader.pos + MAX_PAGE_HEADER_SIZE);\n                const nextPage = reader.readPageHeader();\n                assert(nextPage);\n                currentPage = nextPage;\n                if (currentPage.serialNumber === this.bitstream.serialNumber) {\n                    previousPages.push(currentPage);\n                }\n            }\n            assert(currentPage.granulePosition !== -1);\n            let currentSegmentIndex = null;\n            let currentTimestampInSamples;\n            let currentTimestampIsCorrect;\n            // These indicate the end position of the packet that the granule position belongs to\n            let endPage = currentPage;\n            let endSegmentIndex = 0;\n            if (currentPage.headerStartPos === startPosition.startPage.headerStartPos) {\n                currentTimestampInSamples = this.granulePositionToTimestampInSamples(0);\n                currentTimestampIsCorrect = true;\n                currentSegmentIndex = 0;\n            }\n            else {\n                currentTimestampInSamples = 0; // Placeholder value! We'll refine it once we can\n                currentTimestampIsCorrect = false;\n                // Find the segment index of the next packet\n                for (let i = currentPage.lacingValues.length - 1; i >= 0; i--) {\n                    const value = currentPage.lacingValues[i];\n                    if (value < 255) {\n                        // We know the last packet ended at i, so the next one starts at i + 1\n                        currentSegmentIndex = i + 1;\n                        break;\n                    }\n                }\n                // This must hold: Since this page has a granule position set, that means there must be a packet that\n                // ends in this page.\n                if (currentSegmentIndex === null) {\n                    throw new Error('Invalid page with granule position: no packets end on this page.');\n                }\n                endSegmentIndex = currentSegmentIndex - 1;\n                const pseudopacket = {\n                    data: PLACEHOLDER_DATA,\n                    endPage,\n                    endSegmentIndex,\n                };\n                const nextPosition = await this.demuxer.findNextPacketStart(reader, pseudopacket);\n                if (nextPosition) {\n                    // Let's rewind a single step (packet) - this previous packet ensures that we'll correctly compute\n                    // the duration for the packet we're looking for.\n                    const endPosition = findPreviousPacketEndPosition(previousPages, currentPage, currentSegmentIndex);\n                    assert(endPosition);\n                    const startPosition = findPacketStartPosition(previousPages, endPosition.page, endPosition.segmentIndex);\n                    if (startPosition) {\n                        currentPage = startPosition.page;\n                        currentSegmentIndex = startPosition.segmentIndex;\n                    }\n                }\n                else {\n                    // There is no next position, which means we're looking for the last packet in the bitstream. The\n                    // granule position on the last page tends to be fucky, so let's instead start the search on the\n                    // page before that. So let's loop until we find a packet that ends in a previous page.\n                    while (true) {\n                        const endPosition = findPreviousPacketEndPosition(previousPages, currentPage, currentSegmentIndex);\n                        if (!endPosition) {\n                            break;\n                        }\n                        const startPosition = findPacketStartPosition(previousPages, endPosition.page, endPosition.segmentIndex);\n                        if (!startPosition) {\n                            break;\n                        }\n                        currentPage = startPosition.page;\n                        currentSegmentIndex = startPosition.segmentIndex;\n                        if (endPosition.page.headerStartPos !== endPage.headerStartPos) {\n                            endPage = endPosition.page;\n                            endSegmentIndex = endPosition.segmentIndex;\n                            break;\n                        }\n                    }\n                }\n            }\n            let lastEncodedPacket = null;\n            let lastEncodedPacketMetadata = null;\n            // Alright, now it's time for the final, granular seek: We keep iterating over packets until we've found the\n            // one with the correct timestamp - i.e., the last one with a timestamp <= the timestamp we're looking for.\n            while (currentPage !== null) {\n                assert(currentSegmentIndex !== null);\n                const packet = await this.demuxer.readPacket(reader, currentPage, currentSegmentIndex);\n                if (!packet) {\n                    break;\n                }\n                // We might need to skip the packet if it's a metadata one\n                const skipPacket = currentPage.headerStartPos === startPosition.startPage.headerStartPos\n                    && currentSegmentIndex < startPosition.startSegmentIndex;\n                if (!skipPacket) {\n                    let encodedPacket = this.createEncodedPacketFromOggPacket(packet, {\n                        timestampInSamples: currentTimestampInSamples,\n                        vorbisLastBlocksize: lastEncodedPacketMetadata?.vorbisBlockSize ?? null,\n                    }, options);\n                    assert(encodedPacket);\n                    let encodedPacketMetadata = this.encodedPacketToMetadata.get(encodedPacket);\n                    assert(encodedPacketMetadata);\n                    if (!currentTimestampIsCorrect\n                        && packet.endPage.headerStartPos === endPage.headerStartPos\n                        && packet.endSegmentIndex === endSegmentIndex) {\n                        // We know this packet end timestamp can be derived from the page's granule position\n                        currentTimestampInSamples = this.granulePositionToTimestampInSamples(currentPage.granulePosition);\n                        currentTimestampIsCorrect = true;\n                        // Let's backpatch the packet we just created with the correct timestamp\n                        encodedPacket = this.createEncodedPacketFromOggPacket(packet, {\n                            timestampInSamples: currentTimestampInSamples - encodedPacketMetadata.durationInSamples,\n                            vorbisLastBlocksize: lastEncodedPacketMetadata?.vorbisBlockSize ?? null,\n                        }, options);\n                        assert(encodedPacket);\n                        encodedPacketMetadata = this.encodedPacketToMetadata.get(encodedPacket);\n                        assert(encodedPacketMetadata);\n                    }\n                    else {\n                        currentTimestampInSamples += encodedPacketMetadata.durationInSamples;\n                    }\n                    lastEncodedPacket = encodedPacket;\n                    lastEncodedPacketMetadata = encodedPacketMetadata;\n                    if (currentTimestampIsCorrect\n                        && (\n                        // Next timestamp will be too late\n                        Math.max(currentTimestampInSamples, 0) > timestampInSamples\n                            // This timestamp already matches\n                            || Math.max(encodedPacketMetadata.timestampInSamples, 0) === timestampInSamples)) {\n                        break;\n                    }\n                }\n                const nextPosition = await this.demuxer.findNextPacketStart(reader, packet);\n                if (!nextPosition) {\n                    break;\n                }\n                currentPage = nextPosition.startPage;\n                currentSegmentIndex = nextPosition.startSegmentIndex;\n            }\n            return lastEncodedPacket;\n        }\n        finally {\n            release();\n        }\n    }\n    getKeyPacket(timestamp, options) {\n        return this.getPacket(timestamp, options);\n    }\n    getNextKeyPacket(packet, options) {\n        return this.getNextPacket(packet, options);\n    }\n}\n/** Finds the start position of a packet given its end position. */\nconst findPacketStartPosition = (pageList, endPage, endSegmentIndex) => {\n    let page = endPage;\n    let segmentIndex = endSegmentIndex;\n    outer: while (true) {\n        segmentIndex--;\n        for (segmentIndex; segmentIndex >= 0; segmentIndex--) {\n            const lacingValue = page.lacingValues[segmentIndex];\n            if (lacingValue < 255) {\n                segmentIndex++; // We know the last packet starts here\n                break outer;\n            }\n        }\n        assert(segmentIndex === -1);\n        const pageStartsWithFreshPacket = !(page.headerType & 0x01);\n        if (pageStartsWithFreshPacket) {\n            // Fast exit: We know we don't need to look in the previous page\n            segmentIndex = 0;\n            break;\n        }\n        const previousPage = findLast(pageList, x => x.headerStartPos < page.headerStartPos);\n        if (!previousPage) {\n            return null;\n        }\n        page = previousPage;\n        segmentIndex = page.lacingValues.length;\n    }\n    assert(segmentIndex !== -1);\n    if (segmentIndex === page.lacingValues.length) {\n        // Wrap back around to the first segment of the next page\n        const nextPage = pageList[pageList.indexOf(page) + 1];\n        assert(nextPage);\n        page = nextPage;\n        segmentIndex = 0;\n    }\n    return { page, segmentIndex };\n};\n/** Finds the end position of a packet given the start position of the following packet. */\nconst findPreviousPacketEndPosition = (pageList, startPage, startSegmentIndex) => {\n    if (startSegmentIndex > 0) {\n        // Easy\n        return { page: startPage, segmentIndex: startSegmentIndex - 1 };\n    }\n    const previousPage = findLast(pageList, x => x.headerStartPos < startPage.headerStartPos);\n    if (!previousPage) {\n        return null;\n    }\n    return { page: previousPage, segmentIndex: previousPage.lacingValues.length - 1 };\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11811, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/wave/riff-reader.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport class RiffReader {\n    constructor(reader) {\n        this.reader = reader;\n        this.pos = 0;\n        this.littleEndian = true;\n    }\n    readBytes(length) {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + length);\n        this.pos += length;\n        return new Uint8Array(view.buffer, offset, length);\n    }\n    readU16() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 2);\n        this.pos += 2;\n        return view.getUint16(offset, this.littleEndian);\n    }\n    readU32() {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + 4);\n        this.pos += 4;\n        return view.getUint32(offset, this.littleEndian);\n    }\n    readU64() {\n        let low;\n        let high;\n        if (this.littleEndian) {\n            low = this.readU32();\n            high = this.readU32();\n        }\n        else {\n            high = this.readU32();\n            low = this.readU32();\n        }\n        return high * 0x100000000 + low;\n    }\n    readAscii(length) {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + length);\n        this.pos += length;\n        let str = '';\n        for (let i = 0; i < length; i++) {\n            str += String.fromCharCode(view.getUint8(offset + i));\n        }\n        return str;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AACM,MAAM;IACT,YAAY,MAAM,CAAE;QAChB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,YAAY,GAAG;IACxB;IACA,UAAU,MAAM,EAAE;QACd,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG;QAC3E,IAAI,CAAC,GAAG,IAAI;QACZ,OAAO,IAAI,WAAW,KAAK,MAAM,EAAE,QAAQ;IAC/C;IACA,UAAU;QACN,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG;QAC3E,IAAI,CAAC,GAAG,IAAI;QACZ,OAAO,KAAK,SAAS,CAAC,QAAQ,IAAI,CAAC,YAAY;IACnD;IACA,UAAU;QACN,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG;QAC3E,IAAI,CAAC,GAAG,IAAI;QACZ,OAAO,KAAK,SAAS,CAAC,QAAQ,IAAI,CAAC,YAAY;IACnD;IACA,UAAU;QACN,IAAI;QACJ,IAAI;QACJ,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,MAAM,IAAI,CAAC,OAAO;YAClB,OAAO,IAAI,CAAC,OAAO;QACvB,OACK;YACD,OAAO,IAAI,CAAC,OAAO;YACnB,MAAM,IAAI,CAAC,OAAO;QACtB;QACA,OAAO,OAAO,cAAc;IAChC;IACA,UAAU,MAAM,EAAE;QACd,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG;QAC3E,IAAI,CAAC,GAAG,IAAI;QACZ,IAAI,MAAM;QACV,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;YAC7B,OAAO,OAAO,YAAY,CAAC,KAAK,QAAQ,CAAC,SAAS;QACtD;QACA,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11867, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/wave/wave-demuxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack } from '../input-track.js';\nimport { assert, UNDETERMINED_LANGUAGE } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { Reader } from '../reader.js';\nimport { RiffReader } from './riff-reader.js';\nexport var WaveFormat;\n(function (WaveFormat) {\n    WaveFormat[WaveFormat[\"PCM\"] = 1] = \"PCM\";\n    WaveFormat[WaveFormat[\"IEEE_FLOAT\"] = 3] = \"IEEE_FLOAT\";\n    WaveFormat[WaveFormat[\"ALAW\"] = 6] = \"ALAW\";\n    WaveFormat[WaveFormat[\"MULAW\"] = 7] = \"MULAW\";\n    WaveFormat[WaveFormat[\"EXTENSIBLE\"] = 65534] = \"EXTENSIBLE\";\n})(WaveFormat || (WaveFormat = {}));\nexport class WaveDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.metadataPromise = null;\n        this.dataStart = -1;\n        this.dataSize = -1;\n        this.audioInfo = null;\n        this.tracks = [];\n        this.metadataReader = new RiffReader(input._mainReader);\n        this.chunkReader = new RiffReader(new Reader(input.source, 64 * 2 ** 20));\n    }\n    async readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            const actualFileSize = await this.metadataReader.reader.source.getSize();\n            const riffType = this.metadataReader.readAscii(4);\n            this.metadataReader.littleEndian = riffType !== 'RIFX';\n            const isRf64 = riffType === 'RF64';\n            const outerChunkSize = this.metadataReader.readU32();\n            let totalFileSize = isRf64 ? actualFileSize : Math.min(outerChunkSize + 8, actualFileSize);\n            const format = this.metadataReader.readAscii(4);\n            if (format !== 'WAVE') {\n                throw new Error('Invalid WAVE file - wrong format');\n            }\n            this.metadataReader.pos = 12;\n            let chunksRead = 0;\n            let dataChunkSize = null;\n            while (this.metadataReader.pos < totalFileSize) {\n                await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + 8);\n                const chunkId = this.metadataReader.readAscii(4);\n                const chunkSize = this.metadataReader.readU32();\n                const startPos = this.metadataReader.pos;\n                if (isRf64 && chunksRead === 0 && chunkId !== 'ds64') {\n                    throw new Error('Invalid RF64 file: First chunk must be \"ds64\".');\n                }\n                if (chunkId === 'fmt ') {\n                    await this.parseFmtChunk(chunkSize);\n                }\n                else if (chunkId === 'data') {\n                    dataChunkSize ??= chunkSize;\n                    this.dataStart = this.metadataReader.pos;\n                    this.dataSize = Math.min(dataChunkSize, totalFileSize - this.dataStart);\n                }\n                else if (chunkId === 'ds64') {\n                    // File and data chunk sizes are defined in here instead\n                    const riffChunkSize = this.metadataReader.readU64();\n                    dataChunkSize = this.metadataReader.readU64();\n                    totalFileSize = Math.min(riffChunkSize + 8, actualFileSize);\n                }\n                this.metadataReader.pos = startPos + chunkSize + (chunkSize & 1); // Handle padding\n                chunksRead++;\n            }\n            if (!this.audioInfo) {\n                throw new Error('Invalid WAVE file - missing \"fmt \" chunk');\n            }\n            if (this.dataStart === -1) {\n                throw new Error('Invalid WAVE file - missing \"data\" chunk');\n            }\n            const blockSize = this.audioInfo.blockSizeInBytes;\n            this.dataSize = Math.floor(this.dataSize / blockSize) * blockSize;\n            this.tracks.push(new InputAudioTrack(new WaveAudioTrackBacking(this)));\n        })();\n    }\n    async parseFmtChunk(size) {\n        await this.metadataReader.reader.loadRange(this.metadataReader.pos, this.metadataReader.pos + size);\n        let formatTag = this.metadataReader.readU16();\n        const numChannels = this.metadataReader.readU16();\n        const sampleRate = this.metadataReader.readU32();\n        this.metadataReader.pos += 4; // Bytes per second\n        const blockAlign = this.metadataReader.readU16();\n        let bitsPerSample;\n        if (size === 14) { // Plain WAVEFORMAT\n            bitsPerSample = 8;\n        }\n        else {\n            bitsPerSample = this.metadataReader.readU16();\n        }\n        // Handle WAVEFORMATEXTENSIBLE\n        if (size >= 18 && formatTag !== 0x0165) {\n            const cbSize = this.metadataReader.readU16();\n            const remainingSize = size - 18;\n            const extensionSize = Math.min(remainingSize, cbSize);\n            if (extensionSize >= 22 && formatTag === WaveFormat.EXTENSIBLE) {\n                // Parse WAVEFORMATEXTENSIBLE\n                this.metadataReader.pos += 2 + 4;\n                const subFormat = this.metadataReader.readBytes(16);\n                // Get actual format from subFormat GUID\n                formatTag = subFormat[0] | (subFormat[1] << 8);\n            }\n        }\n        if (formatTag === WaveFormat.MULAW || formatTag === WaveFormat.ALAW) {\n            bitsPerSample = 8;\n        }\n        this.audioInfo = {\n            format: formatTag,\n            numberOfChannels: numChannels,\n            sampleRate,\n            sampleSizeInBytes: Math.ceil(bitsPerSample / 8),\n            blockSizeInBytes: blockAlign,\n        };\n    }\n    getCodec() {\n        assert(this.audioInfo);\n        if (this.audioInfo.format === WaveFormat.MULAW) {\n            return 'ulaw';\n        }\n        if (this.audioInfo.format === WaveFormat.ALAW) {\n            return 'alaw';\n        }\n        if (this.audioInfo.format === WaveFormat.PCM) {\n            // All formats are little-endian\n            if (this.audioInfo.sampleSizeInBytes === 1) {\n                return 'pcm-u8';\n            }\n            else if (this.audioInfo.sampleSizeInBytes === 2) {\n                return 'pcm-s16';\n            }\n            else if (this.audioInfo.sampleSizeInBytes === 3) {\n                return 'pcm-s24';\n            }\n            else if (this.audioInfo.sampleSizeInBytes === 4) {\n                return 'pcm-s32';\n            }\n        }\n        if (this.audioInfo.format === WaveFormat.IEEE_FLOAT) {\n            if (this.audioInfo.sampleSizeInBytes === 4) {\n                return 'pcm-f32';\n            }\n        }\n        return null;\n    }\n    async getMimeType() {\n        return 'audio/wav';\n    }\n    async computeDuration() {\n        await this.readMetadata();\n        assert(this.audioInfo);\n        const numberOfBlocks = this.dataSize / this.audioInfo.blockSizeInBytes;\n        return numberOfBlocks / this.audioInfo.sampleRate;\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks;\n    }\n}\nconst PACKET_SIZE_IN_FRAMES = 2048;\nclass WaveAudioTrackBacking {\n    constructor(demuxer) {\n        this.demuxer = demuxer;\n    }\n    getId() {\n        return 1;\n    }\n    getCodec() {\n        return this.demuxer.getCodec();\n    }\n    async getDecoderConfig() {\n        const codec = this.demuxer.getCodec();\n        if (!codec) {\n            return null;\n        }\n        assert(this.demuxer.audioInfo);\n        return {\n            codec,\n            numberOfChannels: this.demuxer.audioInfo.numberOfChannels,\n            sampleRate: this.demuxer.audioInfo.sampleRate,\n        };\n    }\n    computeDuration() {\n        return this.demuxer.computeDuration();\n    }\n    getNumberOfChannels() {\n        assert(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.numberOfChannels;\n    }\n    getSampleRate() {\n        assert(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.sampleRate;\n    }\n    getTimeResolution() {\n        assert(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.sampleRate;\n    }\n    getLanguageCode() {\n        return UNDETERMINED_LANGUAGE;\n    }\n    async getFirstTimestamp() {\n        return 0;\n    }\n    async getPacketAtIndex(packetIndex, options) {\n        assert(this.demuxer.audioInfo);\n        const startOffset = packetIndex * PACKET_SIZE_IN_FRAMES * this.demuxer.audioInfo.blockSizeInBytes;\n        if (startOffset >= this.demuxer.dataSize) {\n            return null;\n        }\n        const sizeInBytes = Math.min(PACKET_SIZE_IN_FRAMES * this.demuxer.audioInfo.blockSizeInBytes, this.demuxer.dataSize - startOffset);\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            const sizeOfOnePacket = PACKET_SIZE_IN_FRAMES * this.demuxer.audioInfo.blockSizeInBytes;\n            const chunkSize = Math.ceil(2 ** 19 / sizeOfOnePacket) * sizeOfOnePacket;\n            const chunkStart = Math.floor(startOffset / chunkSize) * chunkSize;\n            const chunkEnd = chunkStart + chunkSize;\n            // Always load large 0.5 MiB chunks instead of just the required packet\n            await this.demuxer.chunkReader.reader.loadRange(this.demuxer.dataStart + chunkStart, this.demuxer.dataStart + chunkEnd);\n            this.demuxer.chunkReader.pos = this.demuxer.dataStart + startOffset;\n            data = this.demuxer.chunkReader.readBytes(sizeInBytes);\n        }\n        const timestamp = packetIndex * PACKET_SIZE_IN_FRAMES / this.demuxer.audioInfo.sampleRate;\n        const duration = sizeInBytes / this.demuxer.audioInfo.blockSizeInBytes / this.demuxer.audioInfo.sampleRate;\n        return new EncodedPacket(data, 'key', timestamp, duration, packetIndex, sizeInBytes);\n    }\n    getFirstPacket(options) {\n        return this.getPacketAtIndex(0, options);\n    }\n    getPacket(timestamp, options) {\n        assert(this.demuxer.audioInfo);\n        const packetIndex = Math.floor(timestamp * this.demuxer.audioInfo.sampleRate / PACKET_SIZE_IN_FRAMES);\n        return this.getPacketAtIndex(packetIndex, options);\n    }\n    getNextPacket(packet, options) {\n        assert(this.demuxer.audioInfo);\n        const packetIndex = Math.round(packet.timestamp * this.demuxer.audioInfo.sampleRate / PACKET_SIZE_IN_FRAMES);\n        return this.getPacketAtIndex(packetIndex + 1, options);\n    }\n    getKeyPacket(timestamp, options) {\n        return this.getPacket(timestamp, options);\n    }\n    getNextKeyPacket(packet, options) {\n        return this.getNextPacket(packet, options);\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;AACD;AACA;AACA;AACA;AACA;AACA;;;;;;;AACO,IAAI;AACX,CAAC,SAAU,UAAU;IACjB,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,EAAE,GAAG;IACpC,UAAU,CAAC,UAAU,CAAC,aAAa,GAAG,EAAE,GAAG;IAC3C,UAAU,CAAC,UAAU,CAAC,OAAO,GAAG,EAAE,GAAG;IACrC,UAAU,CAAC,UAAU,CAAC,QAAQ,GAAG,EAAE,GAAG;IACtC,UAAU,CAAC,UAAU,CAAC,aAAa,GAAG,MAAM,GAAG;AACnD,CAAC,EAAE,cAAc,CAAC,aAAa,CAAC,CAAC;AAC1B,MAAM,oBAAoB,qNAAA,CAAA,UAAO;IACpC,YAAY,KAAK,CAAE;QACf,KAAK,CAAC;QACN,IAAI,CAAC,eAAe,GAAG;QACvB,IAAI,CAAC,SAAS,GAAG,CAAC;QAClB,IAAI,CAAC,QAAQ,GAAG,CAAC;QACjB,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,MAAM,GAAG,EAAE;QAChB,IAAI,CAAC,cAAc,GAAG,IAAI,oOAAA,CAAA,aAAU,CAAC,MAAM,WAAW;QACtD,IAAI,CAAC,WAAW,GAAG,IAAI,oOAAA,CAAA,aAAU,CAAC,IAAI,oNAAA,CAAA,SAAM,CAAC,MAAM,MAAM,EAAE,KAAK,KAAK;IACzE;IACA,MAAM,eAAe;QACjB,OAAO,IAAI,CAAC,eAAe,KAAK,CAAC;YAC7B,MAAM,iBAAiB,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO;YACtE,MAAM,WAAW,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC;YAC/C,IAAI,CAAC,cAAc,CAAC,YAAY,GAAG,aAAa;YAChD,MAAM,SAAS,aAAa;YAC5B,MAAM,iBAAiB,IAAI,CAAC,cAAc,CAAC,OAAO;YAClD,IAAI,gBAAgB,SAAS,iBAAiB,KAAK,GAAG,CAAC,iBAAiB,GAAG;YAC3E,MAAM,SAAS,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC;YAC7C,IAAI,WAAW,QAAQ;gBACnB,MAAM,IAAI,MAAM;YACpB;YACA,IAAI,CAAC,cAAc,CAAC,GAAG,GAAG;YAC1B,IAAI,aAAa;YACjB,IAAI,gBAAgB;YACpB,MAAO,IAAI,CAAC,cAAc,CAAC,GAAG,GAAG,cAAe;gBAC5C,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,IAAI,CAAC,cAAc,CAAC,GAAG,GAAG;gBAC9F,MAAM,UAAU,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC;gBAC9C,MAAM,YAAY,IAAI,CAAC,cAAc,CAAC,OAAO;gBAC7C,MAAM,WAAW,IAAI,CAAC,cAAc,CAAC,GAAG;gBACxC,IAAI,UAAU,eAAe,KAAK,YAAY,QAAQ;oBAClD,MAAM,IAAI,MAAM;gBACpB;gBACA,IAAI,YAAY,QAAQ;oBACpB,MAAM,IAAI,CAAC,aAAa,CAAC;gBAC7B,OACK,IAAI,YAAY,QAAQ;oBACzB,kBAAkB;oBAClB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG;oBACxC,IAAI,CAAC,QAAQ,GAAG,KAAK,GAAG,CAAC,eAAe,gBAAgB,IAAI,CAAC,SAAS;gBAC1E,OACK,IAAI,YAAY,QAAQ;oBACzB,wDAAwD;oBACxD,MAAM,gBAAgB,IAAI,CAAC,cAAc,CAAC,OAAO;oBACjD,gBAAgB,IAAI,CAAC,cAAc,CAAC,OAAO;oBAC3C,gBAAgB,KAAK,GAAG,CAAC,gBAAgB,GAAG;gBAChD;gBACA,IAAI,CAAC,cAAc,CAAC,GAAG,GAAG,WAAW,YAAY,CAAC,YAAY,CAAC,GAAG,iBAAiB;gBACnF;YACJ;YACA,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;gBACjB,MAAM,IAAI,MAAM;YACpB;YACA,IAAI,IAAI,CAAC,SAAS,KAAK,CAAC,GAAG;gBACvB,MAAM,IAAI,MAAM;YACpB;YACA,MAAM,YAAY,IAAI,CAAC,SAAS,CAAC,gBAAgB;YACjD,IAAI,CAAC,QAAQ,GAAG,KAAK,KAAK,CAAC,IAAI,CAAC,QAAQ,GAAG,aAAa;YACxD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,4NAAA,CAAA,kBAAe,CAAC,IAAI,sBAAsB,IAAI;QACvE,CAAC;IACL;IACA,MAAM,cAAc,IAAI,EAAE;QACtB,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,IAAI,CAAC,cAAc,CAAC,GAAG,GAAG;QAC9F,IAAI,YAAY,IAAI,CAAC,cAAc,CAAC,OAAO;QAC3C,MAAM,cAAc,IAAI,CAAC,cAAc,CAAC,OAAO;QAC/C,MAAM,aAAa,IAAI,CAAC,cAAc,CAAC,OAAO;QAC9C,IAAI,CAAC,cAAc,CAAC,GAAG,IAAI,GAAG,mBAAmB;QACjD,MAAM,aAAa,IAAI,CAAC,cAAc,CAAC,OAAO;QAC9C,IAAI;QACJ,IAAI,SAAS,IAAI;YACb,gBAAgB;QACpB,OACK;YACD,gBAAgB,IAAI,CAAC,cAAc,CAAC,OAAO;QAC/C;QACA,8BAA8B;QAC9B,IAAI,QAAQ,MAAM,cAAc,QAAQ;YACpC,MAAM,SAAS,IAAI,CAAC,cAAc,CAAC,OAAO;YAC1C,MAAM,gBAAgB,OAAO;YAC7B,MAAM,gBAAgB,KAAK,GAAG,CAAC,eAAe;YAC9C,IAAI,iBAAiB,MAAM,cAAc,WAAW,UAAU,EAAE;gBAC5D,6BAA6B;gBAC7B,IAAI,CAAC,cAAc,CAAC,GAAG,IAAI,IAAI;gBAC/B,MAAM,YAAY,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC;gBAChD,wCAAwC;gBACxC,YAAY,SAAS,CAAC,EAAE,GAAI,SAAS,CAAC,EAAE,IAAI;YAChD;QACJ;QACA,IAAI,cAAc,WAAW,KAAK,IAAI,cAAc,WAAW,IAAI,EAAE;YACjE,gBAAgB;QACpB;QACA,IAAI,CAAC,SAAS,GAAG;YACb,QAAQ;YACR,kBAAkB;YAClB;YACA,mBAAmB,KAAK,IAAI,CAAC,gBAAgB;YAC7C,kBAAkB;QACtB;IACJ;IACA,WAAW;QACP,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,SAAS;QACrB,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,WAAW,KAAK,EAAE;YAC5C,OAAO;QACX;QACA,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,WAAW,IAAI,EAAE;YAC3C,OAAO;QACX;QACA,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,WAAW,GAAG,EAAE;YAC1C,gCAAgC;YAChC,IAAI,IAAI,CAAC,SAAS,CAAC,iBAAiB,KAAK,GAAG;gBACxC,OAAO;YACX,OACK,IAAI,IAAI,CAAC,SAAS,CAAC,iBAAiB,KAAK,GAAG;gBAC7C,OAAO;YACX,OACK,IAAI,IAAI,CAAC,SAAS,CAAC,iBAAiB,KAAK,GAAG;gBAC7C,OAAO;YACX,OACK,IAAI,IAAI,CAAC,SAAS,CAAC,iBAAiB,KAAK,GAAG;gBAC7C,OAAO;YACX;QACJ;QACA,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,WAAW,UAAU,EAAE;YACjD,IAAI,IAAI,CAAC,SAAS,CAAC,iBAAiB,KAAK,GAAG;gBACxC,OAAO;YACX;QACJ;QACA,OAAO;IACX;IACA,MAAM,cAAc;QAChB,OAAO;IACX;IACA,MAAM,kBAAkB;QACpB,MAAM,IAAI,CAAC,YAAY;QACvB,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,SAAS;QACrB,MAAM,iBAAiB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,gBAAgB;QACtE,OAAO,iBAAiB,IAAI,CAAC,SAAS,CAAC,UAAU;IACrD;IACA,MAAM,YAAY;QACd,MAAM,IAAI,CAAC,YAAY;QACvB,OAAO,IAAI,CAAC,MAAM;IACtB;AACJ;AACA,MAAM,wBAAwB;AAC9B,MAAM;IACF,YAAY,OAAO,CAAE;QACjB,IAAI,CAAC,OAAO,GAAG;IACnB;IACA,QAAQ;QACJ,OAAO;IACX;IACA,WAAW;QACP,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ;IAChC;IACA,MAAM,mBAAmB;QACrB,MAAM,QAAQ,IAAI,CAAC,OAAO,CAAC,QAAQ;QACnC,IAAI,CAAC,OAAO;YACR,OAAO;QACX;QACA,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS;QAC7B,OAAO;YACH;YACA,kBAAkB,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,gBAAgB;YACzD,YAAY,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU;QACjD;IACJ;IACA,kBAAkB;QACd,OAAO,IAAI,CAAC,OAAO,CAAC,eAAe;IACvC;IACA,sBAAsB;QAClB,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS;QAC7B,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,gBAAgB;IAClD;IACA,gBAAgB;QACZ,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS;QAC7B,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU;IAC5C;IACA,oBAAoB;QAChB,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS;QAC7B,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU;IAC5C;IACA,kBAAkB;QACd,OAAO,kNAAA,CAAA,wBAAqB;IAChC;IACA,MAAM,oBAAoB;QACtB,OAAO;IACX;IACA,MAAM,iBAAiB,WAAW,EAAE,OAAO,EAAE;QACzC,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS;QAC7B,MAAM,cAAc,cAAc,wBAAwB,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,gBAAgB;QACjG,IAAI,eAAe,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE;YACtC,OAAO;QACX;QACA,MAAM,cAAc,KAAK,GAAG,CAAC,wBAAwB,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,gBAAgB,EAAE,IAAI,CAAC,OAAO,CAAC,QAAQ,GAAG;QACtH,IAAI;QACJ,IAAI,QAAQ,YAAY,EAAE;YACtB,OAAO,oNAAA,CAAA,mBAAgB;QAC3B,OACK;YACD,MAAM,kBAAkB,wBAAwB,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,gBAAgB;YACvF,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK,KAAK,mBAAmB;YACzD,MAAM,aAAa,KAAK,KAAK,CAAC,cAAc,aAAa;YACzD,MAAM,WAAW,aAAa;YAC9B,uEAAuE;YACvE,MAAM,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,YAAY,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG;YAC9G,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG;YACxD,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,SAAS,CAAC;QAC9C;QACA,MAAM,YAAY,cAAc,wBAAwB,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU;QACzF,MAAM,WAAW,cAAc,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,gBAAgB,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU;QAC1G,OAAO,IAAI,oNAAA,CAAA,gBAAa,CAAC,MAAM,OAAO,WAAW,UAAU,aAAa;IAC5E;IACA,eAAe,OAAO,EAAE;QACpB,OAAO,IAAI,CAAC,gBAAgB,CAAC,GAAG;IACpC;IACA,UAAU,SAAS,EAAE,OAAO,EAAE;QAC1B,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS;QAC7B,MAAM,cAAc,KAAK,KAAK,CAAC,YAAY,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU,GAAG;QAC/E,OAAO,IAAI,CAAC,gBAAgB,CAAC,aAAa;IAC9C;IACA,cAAc,MAAM,EAAE,OAAO,EAAE;QAC3B,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS;QAC7B,MAAM,cAAc,KAAK,KAAK,CAAC,OAAO,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU,GAAG;QACtF,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,GAAG;IAClD;IACA,aAAa,SAAS,EAAE,OAAO,EAAE;QAC7B,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW;IACrC;IACA,iBAAiB,MAAM,EAAE,OAAO,EAAE;QAC9B,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ;IACtC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12127, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/adts/adts-reader.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream } from '../misc.js';\nexport const MAX_FRAME_HEADER_SIZE = 9;\nexport class AdtsReader {\n    constructor(reader) {\n        this.reader = reader;\n        this.pos = 0;\n    }\n    readBytes(length) {\n        const { view, offset } = this.reader.getViewAndOffset(this.pos, this.pos + length);\n        this.pos += length;\n        return new Uint8Array(view.buffer, offset, length);\n    }\n    readFrameHeader() {\n        // https://wiki.multimedia.cx/index.php/ADTS (last visited: 2025/08/17)\n        const startPos = this.pos;\n        const bytes = this.readBytes(9); // 9 with CRC, 7 without CRC\n        const bitstream = new Bitstream(bytes);\n        const syncword = bitstream.readBits(12);\n        if (syncword !== 0b1111_11111111) {\n            return null;\n        }\n        bitstream.skipBits(1); // MPEG version\n        const layer = bitstream.readBits(2);\n        if (layer !== 0) {\n            return null;\n        }\n        const protectionAbsence = bitstream.readBits(1);\n        const objectType = bitstream.readBits(2) + 1;\n        const samplingFrequencyIndex = bitstream.readBits(4);\n        if (samplingFrequencyIndex === 15) {\n            return null;\n        }\n        bitstream.skipBits(1); // Private bit\n        const channelConfiguration = bitstream.readBits(3);\n        if (channelConfiguration === 0) {\n            throw new Error('ADTS frames with channel configuration 0 are not supported.');\n        }\n        bitstream.skipBits(1); // Originality\n        bitstream.skipBits(1); // Home\n        bitstream.skipBits(1); // Copyright ID bit\n        bitstream.skipBits(1); // Copyright ID start\n        const frameLength = bitstream.readBits(13);\n        bitstream.skipBits(11); // Buffer fullness\n        const numberOfAacFrames = bitstream.readBits(2) + 1;\n        if (numberOfAacFrames !== 1) {\n            throw new Error('ADTS frames with more than one AAC frame are not supported.');\n        }\n        let crcCheck = null;\n        if (protectionAbsence === 1) { // No CRC\n            this.pos -= 2;\n        }\n        else { // CRC\n            crcCheck = bitstream.readBits(16);\n        }\n        return {\n            objectType,\n            samplingFrequencyIndex,\n            channelConfiguration,\n            frameLength,\n            numberOfAacFrames,\n            crcCheck,\n            startPos,\n        };\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;AACD;;AACO,MAAM,wBAAwB;AAC9B,MAAM;IACT,YAAY,MAAM,CAAE;QAChB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,GAAG,GAAG;IACf;IACA,UAAU,MAAM,EAAE;QACd,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG;QAC3E,IAAI,CAAC,GAAG,IAAI;QACZ,OAAO,IAAI,WAAW,KAAK,MAAM,EAAE,QAAQ;IAC/C;IACA,kBAAkB;QACd,uEAAuE;QACvE,MAAM,WAAW,IAAI,CAAC,GAAG;QACzB,MAAM,QAAQ,IAAI,CAAC,SAAS,CAAC,IAAI,4BAA4B;QAC7D,MAAM,YAAY,IAAI,kNAAA,CAAA,YAAS,CAAC;QAChC,MAAM,WAAW,UAAU,QAAQ,CAAC;QACpC,IAAI,aAAa,iBAAiB;YAC9B,OAAO;QACX;QACA,UAAU,QAAQ,CAAC,IAAI,eAAe;QACtC,MAAM,QAAQ,UAAU,QAAQ,CAAC;QACjC,IAAI,UAAU,GAAG;YACb,OAAO;QACX;QACA,MAAM,oBAAoB,UAAU,QAAQ,CAAC;QAC7C,MAAM,aAAa,UAAU,QAAQ,CAAC,KAAK;QAC3C,MAAM,yBAAyB,UAAU,QAAQ,CAAC;QAClD,IAAI,2BAA2B,IAAI;YAC/B,OAAO;QACX;QACA,UAAU,QAAQ,CAAC,IAAI,cAAc;QACrC,MAAM,uBAAuB,UAAU,QAAQ,CAAC;QAChD,IAAI,yBAAyB,GAAG;YAC5B,MAAM,IAAI,MAAM;QACpB;QACA,UAAU,QAAQ,CAAC,IAAI,cAAc;QACrC,UAAU,QAAQ,CAAC,IAAI,OAAO;QAC9B,UAAU,QAAQ,CAAC,IAAI,mBAAmB;QAC1C,UAAU,QAAQ,CAAC,IAAI,qBAAqB;QAC5C,MAAM,cAAc,UAAU,QAAQ,CAAC;QACvC,UAAU,QAAQ,CAAC,KAAK,kBAAkB;QAC1C,MAAM,oBAAoB,UAAU,QAAQ,CAAC,KAAK;QAClD,IAAI,sBAAsB,GAAG;YACzB,MAAM,IAAI,MAAM;QACpB;QACA,IAAI,WAAW;QACf,IAAI,sBAAsB,GAAG;YACzB,IAAI,CAAC,GAAG,IAAI;QAChB,OACK;YACD,WAAW,UAAU,QAAQ,CAAC;QAClC;QACA,OAAO;YACH;YACA;YACA;YACA;YACA;YACA;YACA;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12206, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/adts/adts-demuxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { aacChannelMap, aacFrequencyTable } from '../codec.js';\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack } from '../input-track.js';\nimport { assert, AsyncMutex, binarySearchExact, binarySearchLessOrEqual, Bitstream, UNDETERMINED_LANGUAGE, } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { AdtsReader, MAX_FRAME_HEADER_SIZE } from './adts-reader.js';\nconst SAMPLES_PER_AAC_FRAME = 1024;\nexport class AdtsDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.metadataPromise = null;\n        this.firstFrameHeader = null;\n        this.loadedSamples = []; // All samples from the start of the file to lastLoadedPos\n        this.tracks = [];\n        this.readingMutex = new AsyncMutex();\n        this.lastLoadedPos = 0;\n        this.fileSize = 0;\n        this.nextTimestampInSamples = 0;\n        this.reader = new AdtsReader(input._mainReader);\n    }\n    async readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            this.fileSize = await this.input.source.getSize();\n            await this.loadNextChunk();\n            // There has to be a frame if this demuxer got selected\n            assert(this.firstFrameHeader);\n            // Create the single audio track\n            this.tracks = [new InputAudioTrack(new AdtsAudioTrackBacking(this))];\n        })();\n    }\n    async loadNextChunk() {\n        assert(this.lastLoadedPos < this.fileSize);\n        const chunkSize = 0.5 * 1024 * 1024; // 0.5 MiB\n        const endPos = Math.min(this.lastLoadedPos + chunkSize, this.fileSize);\n        await this.reader.reader.loadRange(this.lastLoadedPos, endPos);\n        this.lastLoadedPos = endPos;\n        assert(this.lastLoadedPos <= this.fileSize);\n        this.parseFramesFromLoadedData();\n    }\n    parseFramesFromLoadedData() {\n        while (this.reader.pos <= this.fileSize - MAX_FRAME_HEADER_SIZE) {\n            const startPos = this.reader.pos;\n            const header = this.reader.readFrameHeader();\n            if (!header) {\n                break;\n            }\n            // Check if the entire frame fits in the loaded data\n            if (startPos + header.frameLength > this.lastLoadedPos) {\n                // Frame doesn't fit, reset positions and stop\n                this.reader.pos = startPos;\n                this.lastLoadedPos = startPos;\n                break;\n            }\n            if (!this.firstFrameHeader) {\n                this.firstFrameHeader = header;\n            }\n            const sampleRate = aacFrequencyTable[header.samplingFrequencyIndex];\n            assert(sampleRate !== undefined);\n            const sampleDuration = SAMPLES_PER_AAC_FRAME / sampleRate;\n            const headerSize = header.crcCheck ? MAX_FRAME_HEADER_SIZE : MAX_FRAME_HEADER_SIZE - 2;\n            const sample = {\n                timestamp: this.nextTimestampInSamples / sampleRate,\n                duration: sampleDuration,\n                dataStart: startPos + headerSize,\n                dataSize: header.frameLength - headerSize,\n            };\n            this.loadedSamples.push(sample);\n            this.nextTimestampInSamples += SAMPLES_PER_AAC_FRAME;\n            this.reader.pos = startPos + header.frameLength;\n        }\n    }\n    async getMimeType() {\n        return 'audio/aac';\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks;\n    }\n    async computeDuration() {\n        await this.readMetadata();\n        const track = this.tracks[0];\n        assert(track);\n        return track.computeDuration();\n    }\n}\nclass AdtsAudioTrackBacking {\n    constructor(demuxer) {\n        this.demuxer = demuxer;\n    }\n    getId() {\n        return 1;\n    }\n    async getFirstTimestamp() {\n        return 0;\n    }\n    getTimeResolution() {\n        const sampleRate = this.getSampleRate();\n        return sampleRate / SAMPLES_PER_AAC_FRAME;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    getLanguageCode() {\n        return UNDETERMINED_LANGUAGE;\n    }\n    getCodec() {\n        return 'aac';\n    }\n    getNumberOfChannels() {\n        assert(this.demuxer.firstFrameHeader);\n        const numberOfChannels = aacChannelMap[this.demuxer.firstFrameHeader.channelConfiguration];\n        assert(numberOfChannels !== undefined);\n        return numberOfChannels;\n    }\n    getSampleRate() {\n        assert(this.demuxer.firstFrameHeader);\n        const sampleRate = aacFrequencyTable[this.demuxer.firstFrameHeader.samplingFrequencyIndex];\n        assert(sampleRate !== undefined);\n        return sampleRate;\n    }\n    async getDecoderConfig() {\n        assert(this.demuxer.firstFrameHeader);\n        const bytes = new Uint8Array(3); // 19 bits max\n        const bitstream = new Bitstream(bytes);\n        const { objectType, samplingFrequencyIndex, channelConfiguration } = this.demuxer.firstFrameHeader;\n        if (objectType > 31) {\n            bitstream.writeBits(5, 31);\n            bitstream.writeBits(6, objectType - 32);\n        }\n        else {\n            bitstream.writeBits(5, objectType);\n        }\n        bitstream.writeBits(4, samplingFrequencyIndex); // samplingFrequencyIndex === 15 is forbidden\n        bitstream.writeBits(4, channelConfiguration);\n        return {\n            codec: `mp4a.40.${this.demuxer.firstFrameHeader.objectType}`,\n            numberOfChannels: this.getNumberOfChannels(),\n            sampleRate: this.getSampleRate(),\n            description: bytes.subarray(0, Math.ceil((bitstream.pos - 1) / 8)),\n        };\n    }\n    getPacketAtIndex(sampleIndex, options) {\n        if (sampleIndex === -1) {\n            return null;\n        }\n        const rawSample = this.demuxer.loadedSamples[sampleIndex];\n        if (!rawSample) {\n            return null;\n        }\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            this.demuxer.reader.pos = rawSample.dataStart;\n            data = this.demuxer.reader.readBytes(rawSample.dataSize);\n        }\n        return new EncodedPacket(data, 'key', rawSample.timestamp, rawSample.duration, sampleIndex, rawSample.dataSize);\n    }\n    async getFirstPacket(options) {\n        return this.getPacketAtIndex(0, options);\n    }\n    async getNextPacket(packet, options) {\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            const sampleIndex = binarySearchExact(this.demuxer.loadedSamples, packet.timestamp, x => x.timestamp);\n            if (sampleIndex === -1) {\n                throw new Error('Packet was not created from this track.');\n            }\n            const nextIndex = sampleIndex + 1;\n            // Ensure the next sample exists\n            while (nextIndex >= this.demuxer.loadedSamples.length\n                && this.demuxer.lastLoadedPos < this.demuxer.fileSize) {\n                await this.demuxer.loadNextChunk();\n            }\n            return this.getPacketAtIndex(nextIndex, options);\n        }\n        finally {\n            release();\n        }\n    }\n    async getPacket(timestamp, options) {\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            while (true) {\n                const index = binarySearchLessOrEqual(this.demuxer.loadedSamples, timestamp, x => x.timestamp);\n                if (index === -1 && this.demuxer.loadedSamples.length > 0) {\n                    // We're before the first sample\n                    return null;\n                }\n                if (this.demuxer.lastLoadedPos === this.demuxer.fileSize) {\n                    // All data is loaded, return what we found\n                    return this.getPacketAtIndex(index, options);\n                }\n                if (index >= 0 && index + 1 < this.demuxer.loadedSamples.length) {\n                    // The next packet also exists, we're done\n                    return this.getPacketAtIndex(index, options);\n                }\n                // Otherwise, keep loading data\n                await this.demuxer.loadNextChunk();\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    getKeyPacket(timestamp, options) {\n        return this.getPacket(timestamp, options);\n    }\n    getNextKeyPacket(packet, options) {\n        return this.getNextPacket(packet, options);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12438, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/input-format.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { IsobmffDemuxer } from './isobmff/isobmff-demuxer.js';\nimport { IsobmffReader } from './isobmff/isobmff-reader.js';\nimport { EBMLId, EBMLReader, MIN_HEADER_SIZE } from './matroska/ebml.js';\nimport { MatroskaDemuxer } from './matroska/matroska-demuxer.js';\nimport { Mp3Demuxer } from './mp3/mp3-demuxer.js';\nimport { FRAME_HEADER_SIZE } from '../shared/mp3-misc.js';\nimport { Mp3Reader } from './mp3/mp3-reader.js';\nimport { OggDemuxer } from './ogg/ogg-demuxer.js';\nimport { OggReader } from './ogg/ogg-reader.js';\nimport { RiffReader } from './wave/riff-reader.js';\nimport { WaveDemuxer } from './wave/wave-demuxer.js';\nimport { AdtsReader, MAX_FRAME_HEADER_SIZE } from './adts/adts-reader.js';\nimport { AdtsDemuxer } from './adts/adts-demuxer.js';\n/**\n * Base class representing an input media file format.\n * @public\n */\nexport class InputFormat {\n}\n/**\n * Format representing files compatible with the ISO base media file format (ISOBMFF), like MP4 or MOV files.\n * @public\n */\nexport class IsobmffInputFormat extends InputFormat {\n    /** @internal */\n    async _getMajorBrand(input) {\n        const sourceSize = await input._mainReader.source.getSize();\n        if (sourceSize < 12) {\n            return null;\n        }\n        const isobmffReader = new IsobmffReader(input._mainReader);\n        isobmffReader.pos = 4;\n        const fourCc = isobmffReader.readAscii(4);\n        if (fourCc !== 'ftyp') {\n            return null;\n        }\n        return isobmffReader.readAscii(4);\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new IsobmffDemuxer(input);\n    }\n}\n/**\n * MPEG-4 Part 14 (MP4) file format.\n * @public\n */\nexport class Mp4InputFormat extends IsobmffInputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        const majorBrand = await this._getMajorBrand(input);\n        return !!majorBrand && majorBrand !== 'qt  ';\n    }\n    get name() {\n        return 'MP4';\n    }\n    get mimeType() {\n        return 'video/mp4';\n    }\n}\n/**\n * QuickTime File Format (QTFF), often called MOV.\n * @public\n */\nexport class QuickTimeInputFormat extends IsobmffInputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        const majorBrand = await this._getMajorBrand(input);\n        return majorBrand === 'qt  ';\n    }\n    get name() {\n        return 'QuickTime File Format';\n    }\n    get mimeType() {\n        return 'video/quicktime';\n    }\n}\nfunction foo() {\n    return 5;\n}\n/**\n * Matroska file format.\n * @public\n */\nexport class MatroskaInputFormat extends InputFormat {\n    /** @internal */\n    async isSupportedEBMLOfDocType(input, desiredDocType) {\n        const sourceSize = await input._mainReader.source.getSize();\n        if (sourceSize < 8) {\n            return false;\n        }\n        const ebmlReader = new EBMLReader(input._mainReader);\n        const varIntSize = ebmlReader.readVarIntSize();\n        if (varIntSize === null) {\n            return false;\n        }\n        foo();\n        if (varIntSize < 1 || varIntSize > 8) {\n            return false;\n        }\n        const id = ebmlReader.readUnsignedInt(varIntSize);\n        if (id !== EBMLId.EBML) {\n            return false;\n        }\n        const dataSize = ebmlReader.readElementSize();\n        if (dataSize === null) {\n            return false; // Miss me with that shit\n        }\n        const startPos = ebmlReader.pos;\n        while (ebmlReader.pos <= startPos + dataSize - MIN_HEADER_SIZE) {\n            const header = ebmlReader.readElementHeader();\n            if (!header)\n                break;\n            const { id, size } = header;\n            const dataStartPos = ebmlReader.pos;\n            if (size === null)\n                return false;\n            switch (id) {\n                case EBMLId.EBMLVersion:\n                    {\n                        const ebmlVersion = ebmlReader.readUnsignedInt(size);\n                        if (ebmlVersion !== 1) {\n                            return false;\n                        }\n                    }\n                    ;\n                    break;\n                case EBMLId.EBMLReadVersion:\n                    {\n                        const ebmlReadVersion = ebmlReader.readUnsignedInt(size);\n                        if (ebmlReadVersion !== 1) {\n                            return false;\n                        }\n                    }\n                    ;\n                    break;\n                case EBMLId.DocType:\n                    {\n                        const docType = ebmlReader.readAsciiString(size);\n                        if (docType !== desiredDocType) {\n                            return false;\n                        }\n                    }\n                    ;\n                    break;\n                case EBMLId.DocTypeVersion:\n                    {\n                        const docTypeVersion = ebmlReader.readUnsignedInt(size);\n                        if (docTypeVersion > 4) { // Support up to Matroska v4\n                            return false;\n                        }\n                    }\n                    ;\n                    break;\n            }\n            ebmlReader.pos = dataStartPos + size;\n        }\n        return true;\n    }\n    /** @internal */\n    _canReadInput(input) {\n        return this.isSupportedEBMLOfDocType(input, 'matroska');\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new MatroskaDemuxer(input);\n    }\n    get name() {\n        return 'Matroska';\n    }\n    get mimeType() {\n        return 'video/x-matroska';\n    }\n}\n/**\n * WebM file format, based on Matroska.\n * @public\n */\nexport class WebMInputFormat extends MatroskaInputFormat {\n    /** @internal */\n    _canReadInput(input) {\n        return this.isSupportedEBMLOfDocType(input, 'webm');\n    }\n    get name() {\n        return 'WebM';\n    }\n    get mimeType() {\n        return 'video/webm';\n    }\n}\n/**\n * MP3 file format.\n * @public\n */\nexport class Mp3InputFormat extends InputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        const sourceSize = await input._mainReader.source.getSize();\n        if (sourceSize < 4) {\n            return false;\n        }\n        const mp3Reader = new Mp3Reader(input._mainReader);\n        mp3Reader.fileSize = sourceSize;\n        const id3Tag = mp3Reader.readId3();\n        if (id3Tag) {\n            mp3Reader.pos += id3Tag.size;\n        }\n        const framesStartPos = mp3Reader.pos;\n        await mp3Reader.reader.loadRange(mp3Reader.pos, mp3Reader.pos + 4096);\n        const firstHeader = mp3Reader.readNextFrameHeader(Math.min(framesStartPos + 4096, sourceSize));\n        if (!firstHeader) {\n            return false;\n        }\n        if (id3Tag) {\n            // If there was an ID3 tag at the start, we can be pretty sure this is MP3 by now\n            return true;\n        }\n        // Fine, we found one frame header, but we're still not entirely sure this is MP3. Let's check if we can find\n        // another header right after it:\n        mp3Reader.pos = firstHeader.startPos + firstHeader.totalSize;\n        await mp3Reader.reader.loadRange(mp3Reader.pos, mp3Reader.pos + FRAME_HEADER_SIZE);\n        const secondHeader = mp3Reader.readNextFrameHeader(mp3Reader.pos + FRAME_HEADER_SIZE);\n        if (!secondHeader) {\n            return false;\n        }\n        // In a well-formed MP3 file, we'd expect these two frames to share some similarities:\n        if (firstHeader.channel !== secondHeader.channel || firstHeader.sampleRate !== secondHeader.sampleRate) {\n            return false;\n        }\n        // We have found two matching consecutive MP3 frames, a strong indicator that this is an MP3 file\n        return true;\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new Mp3Demuxer(input);\n    }\n    get name() {\n        return 'MP3';\n    }\n    get mimeType() {\n        return 'audio/mpeg';\n    }\n}\n/**\n * WAVE file format, based on RIFF.\n * @public\n */\nexport class WaveInputFormat extends InputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        const sourceSize = await input._mainReader.source.getSize();\n        if (sourceSize < 12) {\n            return false;\n        }\n        const riffReader = new RiffReader(input._mainReader);\n        const riffType = riffReader.readAscii(4);\n        if (riffType !== 'RIFF' && riffType !== 'RIFX' && riffType !== 'RF64') {\n            return false;\n        }\n        riffReader.pos = 8;\n        const format = riffReader.readAscii(4);\n        return format === 'WAVE';\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new WaveDemuxer(input);\n    }\n    get name() {\n        return 'WAVE';\n    }\n    get mimeType() {\n        return 'audio/wav';\n    }\n}\n/**\n * Ogg file format.\n * @public\n */\nexport class OggInputFormat extends InputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        const sourceSize = await input._mainReader.source.getSize();\n        if (sourceSize < 4) {\n            return false;\n        }\n        const oggReader = new OggReader(input._mainReader);\n        return oggReader.readAscii(4) === 'OggS';\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new OggDemuxer(input);\n    }\n    get name() {\n        return 'Ogg';\n    }\n    get mimeType() {\n        return 'application/ogg';\n    }\n}\n/**\n * ADTS file format.\n * @public\n */\nexport class AdtsInputFormat extends InputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        const sourceSize = await input._mainReader.source.getSize();\n        if (sourceSize < MAX_FRAME_HEADER_SIZE) {\n            return false;\n        }\n        const adtsReader = new AdtsReader(input._mainReader);\n        const firstHeader = adtsReader.readFrameHeader();\n        if (!firstHeader) {\n            return false;\n        }\n        if (sourceSize < firstHeader.frameLength + MAX_FRAME_HEADER_SIZE) {\n            return false;\n        }\n        adtsReader.pos = firstHeader.frameLength;\n        await adtsReader.reader.loadRange(adtsReader.pos, adtsReader.pos + MAX_FRAME_HEADER_SIZE);\n        const secondHeader = adtsReader.readFrameHeader();\n        if (!secondHeader) {\n            return false;\n        }\n        return firstHeader.objectType === secondHeader.objectType\n            && firstHeader.samplingFrequencyIndex === secondHeader.samplingFrequencyIndex\n            && firstHeader.channelConfiguration === secondHeader.channelConfiguration;\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new AdtsDemuxer(input);\n    }\n    get name() {\n        return 'ADTS';\n    }\n    get mimeType() {\n        return 'audio/aac';\n    }\n}\n/**\n * MP4 input format singleton.\n * @public\n */\nexport const MP4 = new Mp4InputFormat();\n/**\n * QuickTime File Format input format singleton.\n * @public\n */\nexport const QTFF = new QuickTimeInputFormat();\n/**\n * Matroska input format singleton.\n * @public\n */\nexport const MATROSKA = new MatroskaInputFormat();\n/**\n * WebM input format singleton.\n * @public\n */\nexport const WEBM = new WebMInputFormat();\n/**\n * MP3 input format singleton.\n * @public\n */\nexport const MP3 = new Mp3InputFormat();\n/**\n * WAVE input format singleton.\n * @public\n */\nexport const WAVE = new WaveInputFormat();\n/**\n * Ogg input format singleton.\n * @public\n */\nexport const OGG = new OggInputFormat();\n/**\n * ADTS input format singleton.\n * @public\n */\nexport const ADTS = new AdtsInputFormat();\n/**\n * List of all input format singletons. If you don't need to support all input formats, you should specify the\n * formats individually for better tree shaking.\n * @public\n */\nexport const ALL_FORMATS = [MP4, QTFF, MATROSKA, WEBM, WAVE, OGG, MP3, ADTS];\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12779, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/source.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { mergeObjectsDeeply, retriedFetch } from './misc.js';\n/**\n * The source base class, representing a resource from which bytes can be read.\n * @public\n */\nexport class Source {\n    constructor() {\n        /** @internal */\n        this._sizePromise = null;\n        /** Called each time data is requested from the source. */\n        this.onread = null;\n    }\n    /**\n     * Resolves with the total size of the file in bytes. This function is memoized, meaning only the first call\n     * will retrieve the size.\n     */\n    getSize() {\n        return this._sizePromise ??= this._retrieveSize();\n    }\n}\n/**\n * A source backed by an ArrayBuffer or ArrayBufferView, with the entire file held in memory.\n * @public\n */\nexport class BufferSource extends Source {\n    constructor(buffer) {\n        if (!(buffer instanceof ArrayBuffer) && !(buffer instanceof Uint8Array)) {\n            throw new TypeError('buffer must be an ArrayBuffer or Uint8Array.');\n        }\n        super();\n        this._bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n    }\n    /** @internal */\n    async _read(start, end) {\n        return this._bytes.subarray(start, end);\n    }\n    /** @internal */\n    async _retrieveSize() {\n        return this._bytes.byteLength;\n    }\n}\n/**\n * A general-purpose, callback-driven source that can get its data from anywhere.\n * @public\n */\nexport class StreamSource extends Source {\n    constructor(options) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (typeof options.read !== 'function') {\n            throw new TypeError('options.read must be a function.');\n        }\n        if (typeof options.getSize !== 'function') {\n            throw new TypeError('options.getSize must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    async _read(start, end) {\n        return this._options.read(start, end);\n    }\n    /** @internal */\n    async _retrieveSize() {\n        return this._options.getSize();\n    }\n}\n/**\n * A source backed by a Blob. Since Files are also Blobs, this is the source to use when reading files off the disk.\n * @public\n */\nexport class BlobSource extends Source {\n    constructor(blob) {\n        if (!(blob instanceof Blob)) {\n            throw new TypeError('blob must be a Blob.');\n        }\n        super();\n        this._blob = blob;\n    }\n    /** @internal */\n    async _read(start, end) {\n        const slice = this._blob.slice(start, end);\n        const buffer = await slice.arrayBuffer();\n        return new Uint8Array(buffer);\n    }\n    /** @internal */\n    async _retrieveSize() {\n        return this._blob.size;\n    }\n}\n/**\n * A source backed by a URL. This is useful for reading data from the network. Be careful using this source however,\n * as it typically comes with increased latency.\n * @beta\n */\nexport class UrlSource extends Source {\n    constructor(url, options = {}) {\n        if (typeof url !== 'string' && !(url instanceof URL)) {\n            throw new TypeError('url must be a string or URL.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.requestInit !== undefined && (!options.requestInit || typeof options.requestInit !== 'object')) {\n            throw new TypeError('options.requestInit, when provided, must be an object.');\n        }\n        if (options.getRetryDelay !== undefined && typeof options.getRetryDelay !== 'function') {\n            throw new TypeError('options.getRetryDelay, when provided, must be a function.');\n        }\n        super();\n        /** @internal */\n        this._fullData = null;\n        /** @internal */\n        this._nextUrlVersion = null;\n        this._url = url instanceof URL ? url : new URL(url);\n        this._options = options;\n    }\n    /** @internal */\n    async _makeRequest(range) {\n        const headers = {};\n        if (range) {\n            headers['Range'] = `bytes=${range.start}-${range.end - 1}`;\n        }\n        if (this._nextUrlVersion !== null) {\n            this._url.searchParams.set('mediabunny_version', this._nextUrlVersion.toString());\n            this._nextUrlVersion++;\n        }\n        const response = await retriedFetch(this._url, mergeObjectsDeeply(this._options.requestInit ?? {}, {\n            method: 'GET',\n            headers,\n        }), this._options.getRetryDelay ?? (() => null));\n        if (!response.ok) {\n            throw new Error(`Error fetching ${this._url}: ${response.status} ${response.statusText}`);\n        }\n        const buffer = await response.arrayBuffer();\n        if (response.status === 206\n            && range\n            && buffer.byteLength !== range.end - range.start\n            && this._nextUrlVersion === null) {\n            // We did a range request but it resolved with the wrong range; in Chromium, this can be due to a caching\n            // bug (https://issues.chromium.org/issues/436025873). Let's circumvent the cache for the rest of the\n            // session by appending a version to the URL.\n            this._nextUrlVersion = 1;\n            return this._makeRequest(range);\n        }\n        if (response.status === 200) {\n            // The server didn't return 206 Partial Content, so it's not a range response\n            this._fullData = buffer;\n        }\n        return {\n            response: buffer,\n            statusCode: response.status,\n        };\n    }\n    /** @internal */\n    async _read(start, end) {\n        if (this._fullData) {\n            return new Uint8Array(this._fullData, start, end - start);\n        }\n        const { response, statusCode } = await this._makeRequest({ start, end });\n        // If server doesn't support range requests, it will return 200 instead of 206. In that case, let's manually\n        // slice the response.\n        if (statusCode === 200) {\n            const fullData = new Uint8Array(response);\n            return fullData.subarray(start, end);\n        }\n        return new Uint8Array(response);\n    }\n    /** @internal */\n    async _retrieveSize() {\n        if (this._fullData) {\n            return this._fullData.byteLength;\n        }\n        // First, try a HEAD request to get the size\n        try {\n            const headResponse = await retriedFetch(this._url, mergeObjectsDeeply(this._options.requestInit ?? {}, {\n                method: 'HEAD',\n            }), this._options.getRetryDelay ?? (() => null));\n            if (headResponse.ok) {\n                const contentLength = headResponse.headers.get('Content-Length');\n                if (contentLength) {\n                    return parseInt(contentLength);\n                }\n            }\n        }\n        catch {\n            // We tried\n        }\n        // Try a range request to get the Content-Range header\n        const rangeResponse = await retriedFetch(this._url, mergeObjectsDeeply(this._options.requestInit ?? {}, {\n            method: 'GET',\n            headers: { Range: 'bytes=0-0' },\n        }), this._options.getRetryDelay ?? (() => null));\n        if (rangeResponse.status === 206) {\n            const contentRange = rangeResponse.headers.get('Content-Range');\n            if (contentRange) {\n                const match = contentRange.match(/bytes \\d+-\\d+\\/(\\d+)/);\n                if (match && match[1]) {\n                    return parseInt(match[1]);\n                }\n            }\n        }\n        else if (rangeResponse.status === 200) {\n            // The server just returned the whole thing\n            this._fullData = await rangeResponse.arrayBuffer();\n            if (this._fullData.byteLength !== 1) {\n                return this._fullData.byteLength;\n            }\n            else {\n                // The server responded with 200, but returned only the requested range, so skip the response\n            }\n        }\n        // If the range request didn't provide the size, make a full GET request\n        const { response } = await this._makeRequest();\n        return response.byteLength;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12979, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/input.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { InputFormat } from './input-format.js';\nimport { assert } from './misc.js';\nimport { Reader } from './reader.js';\nimport { Source } from './source.js';\n/**\n * Represents an input media file. This is the root object from which all media read operations start.\n * @public\n */\nexport class Input {\n    constructor(options) {\n        /** @internal */\n        this._demuxerPromise = null;\n        /** @internal */\n        this._format = null;\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Array.isArray(options.formats) || options.formats.some(x => !(x instanceof InputFormat))) {\n            throw new TypeError('options.formats must be an array of InputFormat.');\n        }\n        if (!(options.source instanceof Source)) {\n            throw new TypeError('options.source must be a Source.');\n        }\n        this._formats = options.formats;\n        this._source = options.source;\n        this._mainReader = new Reader(options.source);\n    }\n    /** @internal */\n    _getDemuxer() {\n        return this._demuxerPromise ??= (async () => {\n            await this._mainReader.loadRange(0, 4096); // Load the first 4 kiB so we can determine the format\n            for (const format of this._formats) {\n                const canRead = await format._canReadInput(this);\n                if (canRead) {\n                    this._format = format;\n                    return format._createDemuxer(this);\n                }\n            }\n            throw new Error('Input has an unsupported or unrecognizable format.');\n        })();\n    }\n    /**\n     * Returns the source from which this input file reads its data. This is the same source that was passed to the\n     * constructor.\n     */\n    get source() {\n        return this._source;\n    }\n    /**\n     * Returns the format of the input file. You can compare this result directly to the InputFormat singletons or use\n     * `instanceof` checks for subset-aware logic (for example, `format instanceof MatroskaInputFormat` is true for\n     * both MKV and WebM).\n     */\n    async getFormat() {\n        await this._getDemuxer();\n        assert(this._format);\n        return this._format;\n    }\n    /**\n     * Computes the duration of the input file, in seconds. More precisely, returns the largest end timestamp among\n     * all tracks.\n     */\n    async computeDuration() {\n        const demuxer = await this._getDemuxer();\n        return demuxer.computeDuration();\n    }\n    /** Returns the list of all tracks of this input file. */\n    async getTracks() {\n        const demuxer = await this._getDemuxer();\n        return demuxer.getTracks();\n    }\n    /** Returns the list of all video tracks of this input file. */\n    async getVideoTracks() {\n        const tracks = await this.getTracks();\n        return tracks.filter(x => x.isVideoTrack());\n    }\n    /** Returns the primary video track of this input file, or null if there are no video tracks. */\n    async getPrimaryVideoTrack() {\n        const tracks = await this.getTracks();\n        return tracks.find(x => x.isVideoTrack()) ?? null;\n    }\n    /** Returns the list of all audio tracks of this input file. */\n    async getAudioTracks() {\n        const tracks = await this.getTracks();\n        return tracks.filter(x => x.isAudioTrack());\n    }\n    /** Returns the primary audio track of this input file, or null if there are no audio tracks. */\n    async getPrimaryAudioTrack() {\n        const tracks = await this.getTracks();\n        return tracks.find(x => x.isAudioTrack()) ?? null;\n    }\n    /** Returns the full MIME type of this input file, including track codecs. */\n    async getMimeType() {\n        const demuxer = await this._getDemuxer();\n        return demuxer.getMimeType();\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AACD;AACA;AACA;AACA;;;;;AAKO,MAAM;IACT,YAAY,OAAO,CAAE;QACjB,cAAc,GACd,IAAI,CAAC,eAAe,GAAG;QACvB,cAAc,GACd,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,WAAW,OAAO,YAAY,UAAU;YACzC,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,CAAC,MAAM,OAAO,CAAC,QAAQ,OAAO,KAAK,QAAQ,OAAO,CAAC,IAAI,CAAC,CAAA,IAAK,CAAC,CAAC,aAAa,6NAAA,CAAA,cAAW,IAAI;YAC3F,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,CAAC,CAAC,QAAQ,MAAM,YAAY,oNAAA,CAAA,SAAM,GAAG;YACrC,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,CAAC,QAAQ,GAAG,QAAQ,OAAO;QAC/B,IAAI,CAAC,OAAO,GAAG,QAAQ,MAAM;QAC7B,IAAI,CAAC,WAAW,GAAG,IAAI,oNAAA,CAAA,SAAM,CAAC,QAAQ,MAAM;IAChD;IACA,cAAc,GACd,cAAc;QACV,OAAO,IAAI,CAAC,eAAe,KAAK,CAAC;YAC7B,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,GAAG,OAAO,sDAAsD;YACjG,KAAK,MAAM,UAAU,IAAI,CAAC,QAAQ,CAAE;gBAChC,MAAM,UAAU,MAAM,OAAO,aAAa,CAAC,IAAI;gBAC/C,IAAI,SAAS;oBACT,IAAI,CAAC,OAAO,GAAG;oBACf,OAAO,OAAO,cAAc,CAAC,IAAI;gBACrC;YACJ;YACA,MAAM,IAAI,MAAM;QACpB,CAAC;IACL;IACA;;;KAGC,GACD,IAAI,SAAS;QACT,OAAO,IAAI,CAAC,OAAO;IACvB;IACA;;;;KAIC,GACD,MAAM,YAAY;QACd,MAAM,IAAI,CAAC,WAAW;QACtB,CAAA,GAAA,kNAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,OAAO;QACnB,OAAO,IAAI,CAAC,OAAO;IACvB;IACA;;;KAGC,GACD,MAAM,kBAAkB;QACpB,MAAM,UAAU,MAAM,IAAI,CAAC,WAAW;QACtC,OAAO,QAAQ,eAAe;IAClC;IACA,uDAAuD,GACvD,MAAM,YAAY;QACd,MAAM,UAAU,MAAM,IAAI,CAAC,WAAW;QACtC,OAAO,QAAQ,SAAS;IAC5B;IACA,6DAA6D,GAC7D,MAAM,iBAAiB;QACnB,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;QACnC,OAAO,OAAO,MAAM,CAAC,CAAA,IAAK,EAAE,YAAY;IAC5C;IACA,8FAA8F,GAC9F,MAAM,uBAAuB;QACzB,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;QACnC,OAAO,OAAO,IAAI,CAAC,CAAA,IAAK,EAAE,YAAY,OAAO;IACjD;IACA,6DAA6D,GAC7D,MAAM,iBAAiB;QACnB,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;QACnC,OAAO,OAAO,MAAM,CAAC,CAAA,IAAK,EAAE,YAAY;IAC5C;IACA,8FAA8F,GAC9F,MAAM,uBAAuB;QACzB,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;QACnC,OAAO,OAAO,IAAI,CAAC,CAAA,IAAK,EAAE,YAAY,OAAO;IACjD;IACA,2EAA2E,GAC3E,MAAM,cAAc;QAChB,MAAM,UAAU,MAAM,IAAI,CAAC,WAAW;QACtC,OAAO,QAAQ,WAAW;IAC9B;AACJ","ignoreList":[0],"debugId":null}}]
}