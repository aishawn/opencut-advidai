{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-drag-drop.ts"],"sourcesContent":["import { useState, useRef } from \"react\";\n\ninterface UseDragDropOptions {\n  onDrop?: (files: FileList) => void;\n}\n\n// Helper function to check if drag contains files from external sources (not internal app drags)\nconst containsFiles = (dataTransfer: DataTransfer): boolean => {\n  // Check if this is an internal app drag (media item)\n  if (dataTransfer.types.includes(\"application/x-media-item\")) {\n    return false;\n  }\n\n  // Only show overlay for external file drags\n  return dataTransfer.types.includes(\"Files\");\n};\n\nexport function useDragDrop(options: UseDragDropOptions = {}) {\n  const [isDragOver, setIsDragOver] = useState(false);\n  const dragCounterRef = useRef(0);\n\n  const handleDragEnter = (e: React.DragEvent) => {\n    e.preventDefault();\n\n    // Only handle external file drags, not internal app element drags\n    if (!containsFiles(e.dataTransfer)) {\n      return;\n    }\n\n    dragCounterRef.current += 1;\n    if (!isDragOver) {\n      setIsDragOver(true);\n    }\n  };\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault();\n\n    // Only handle file drags\n    if (!containsFiles(e.dataTransfer)) {\n      return;\n    }\n  };\n\n  const handleDragLeave = (e: React.DragEvent) => {\n    e.preventDefault();\n\n    // Only handle file drags\n    if (!containsFiles(e.dataTransfer)) {\n      return;\n    }\n\n    dragCounterRef.current -= 1;\n    if (dragCounterRef.current === 0) {\n      setIsDragOver(false);\n    }\n  };\n\n  const handleDrop = (e: React.DragEvent) => {\n    e.preventDefault();\n    setIsDragOver(false);\n    dragCounterRef.current = 0;\n\n    // Only handle file drops\n    if (\n      options.onDrop &&\n      e.dataTransfer.files &&\n      containsFiles(e.dataTransfer)\n    ) {\n      options.onDrop(e.dataTransfer.files);\n    }\n  };\n\n  const dragProps = {\n    onDragEnter: handleDragEnter,\n    onDragOver: handleDragOver,\n    onDragLeave: handleDragLeave,\n    onDrop: handleDrop,\n  };\n\n  return {\n    isDragOver,\n    dragProps,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAMA,iGAAiG;AACjG,MAAM,gBAAgB,CAAC;IACrB,qDAAqD;IACrD,IAAI,aAAa,KAAK,CAAC,QAAQ,CAAC,6BAA6B;QAC3D,OAAO;IACT;IAEA,4CAA4C;IAC5C,OAAO,aAAa,KAAK,CAAC,QAAQ,CAAC;AACrC;AAEO,SAAS,YAAY,UAA8B,CAAC,CAAC;IAC1D,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,0QAAA,CAAA,WAAQ,AAAD,EAAE;IAC7C,MAAM,iBAAiB,CAAA,GAAA,0QAAA,CAAA,SAAM,AAAD,EAAE;IAE9B,MAAM,kBAAkB,CAAC;QACvB,EAAE,cAAc;QAEhB,kEAAkE;QAClE,IAAI,CAAC,cAAc,EAAE,YAAY,GAAG;YAClC;QACF;QAEA,eAAe,OAAO,IAAI;QAC1B,IAAI,CAAC,YAAY;YACf,cAAc;QAChB;IACF;IAEA,MAAM,iBAAiB,CAAC;QACtB,EAAE,cAAc;QAEhB,yBAAyB;QACzB,IAAI,CAAC,cAAc,EAAE,YAAY,GAAG;YAClC;QACF;IACF;IAEA,MAAM,kBAAkB,CAAC;QACvB,EAAE,cAAc;QAEhB,yBAAyB;QACzB,IAAI,CAAC,cAAc,EAAE,YAAY,GAAG;YAClC;QACF;QAEA,eAAe,OAAO,IAAI;QAC1B,IAAI,eAAe,OAAO,KAAK,GAAG;YAChC,cAAc;QAChB;IACF;IAEA,MAAM,aAAa,CAAC;QAClB,EAAE,cAAc;QAChB,cAAc;QACd,eAAe,OAAO,GAAG;QAEzB,yBAAyB;QACzB,IACE,QAAQ,MAAM,IACd,EAAE,YAAY,CAAC,KAAK,IACpB,cAAc,EAAE,YAAY,GAC5B;YACA,QAAQ,MAAM,CAAC,EAAE,YAAY,CAAC,KAAK;QACrC;IACF;IAEA,MAAM,YAAY;QAChB,aAAa;QACb,YAAY;QACZ,aAAa;QACb,QAAQ;IACV;IAEA,OAAO;QACL;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-highlight-scroll.ts"],"sourcesContent":["import { useEffect, useState, useRef } from \"react\";\r\n\r\nexport function useHighlightScroll(\r\n  highlightId: string | null,\r\n  onClearHighlight: () => void,\r\n  highlightDuration = 1000\r\n) {\r\n  const [highlightedId, setHighlightedId] = useState<string | null>(null);\r\n  const elementRefs = useRef<Map<string, HTMLElement>>(new Map());\r\n\r\n  const registerElement = (id: string, element: HTMLElement | null) => {\r\n    if (element) {\r\n      elementRefs.current.set(id, element);\r\n    } else {\r\n      elementRefs.current.delete(id);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!highlightId) return;\r\n\r\n    setHighlightedId(highlightId);\r\n\r\n    const target = elementRefs.current.get(highlightId);\r\n    target?.scrollIntoView({ block: \"center\" });\r\n\r\n    const timeout = setTimeout(() => {\r\n      setHighlightedId(null);\r\n      onClearHighlight();\r\n    }, highlightDuration);\r\n\r\n    return () => clearTimeout(timeout);\r\n  }, [highlightId, onClearHighlight, highlightDuration]);\r\n\r\n  return { highlightedId, registerElement };\r\n}\r\n"],"names":[],"mappings":";;;AAAA;;AAEO,SAAS,mBACd,WAA0B,EAC1B,gBAA4B,EAC5B,oBAAoB,IAAI;IAExB,MAAM,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,0QAAA,CAAA,WAAQ,AAAD,EAAiB;IAClE,MAAM,cAAc,CAAA,GAAA,0QAAA,CAAA,SAAM,AAAD,EAA4B,IAAI;IAEzD,MAAM,kBAAkB,CAAC,IAAY;QACnC,IAAI,SAAS;YACX,YAAY,OAAO,CAAC,GAAG,CAAC,IAAI;QAC9B,OAAO;YACL,YAAY,OAAO,CAAC,MAAM,CAAC;QAC7B;IACF;IAEA,CAAA,GAAA,0QAAA,CAAA,YAAS,AAAD,EAAE;QACR,IAAI,CAAC,aAAa;QAElB,iBAAiB;QAEjB,MAAM,SAAS,YAAY,OAAO,CAAC,GAAG,CAAC;QACvC,QAAQ,eAAe;YAAE,OAAO;QAAS;QAEzC,MAAM,UAAU,WAAW;YACzB,iBAAiB;YACjB;QACF,GAAG;QAEH,OAAO,IAAM,aAAa;IAC5B,GAAG;QAAC;QAAa;QAAkB;KAAkB;IAErD,OAAO;QAAE;QAAe;IAAgB;AAC1C","debugId":null}},
    {"offset": {"line": 116, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-sound-search.ts"],"sourcesContent":["import { useEffect } from \"react\";\r\nimport { useSoundsStore } from \"@/stores/sounds-store\";\r\n\r\n/**\r\n * Custom hook for searching sound effects with race condition protection.\r\n * Uses global Zustand store to persist search state across tab switches.\r\n * - Debounced search (300ms)\r\n * - Race condition protection with cleanup\r\n * - Proper error handling\r\n */\r\n\r\nexport function useSoundSearch(query: string, commercialOnly: boolean) {\r\n  const {\r\n    searchResults,\r\n    isSearching,\r\n    searchError,\r\n    lastSearchQuery,\r\n    currentPage,\r\n    hasNextPage,\r\n    isLoadingMore,\r\n    totalCount,\r\n    setSearchResults,\r\n    setSearching,\r\n    setSearchError,\r\n    setLastSearchQuery,\r\n    setCurrentPage,\r\n    setHasNextPage,\r\n    setTotalCount,\r\n    setLoadingMore,\r\n    appendSearchResults,\r\n    appendTopSounds,\r\n    resetPagination,\r\n  } = useSoundsStore();\r\n\r\n  // Load more function for infinite scroll\r\n  const loadMore = async () => {\r\n    if (isLoadingMore || !hasNextPage) return;\r\n\r\n    try {\r\n      setLoadingMore(true);\r\n      const nextPage = currentPage + 1;\r\n\r\n      const searchParams = new URLSearchParams({\r\n        page: nextPage.toString(),\r\n        type: \"effects\",\r\n      });\r\n\r\n      if (query.trim()) {\r\n        searchParams.set(\"q\", query);\r\n      }\r\n\r\n      searchParams.set(\"commercial_only\", commercialOnly.toString());\r\n      const response = await fetch(\r\n        `/api/sounds/search?${searchParams.toString()}`\r\n      );\r\n\r\n      if (response.ok) {\r\n        const data = await response.json();\r\n\r\n        // Append to appropriate array based on whether we have a query\r\n        if (query.trim()) {\r\n          appendSearchResults(data.results);\r\n        } else {\r\n          appendTopSounds(data.results);\r\n        }\r\n\r\n        setCurrentPage(nextPage);\r\n        setHasNextPage(!!data.next);\r\n        setTotalCount(data.count);\r\n      } else {\r\n        setSearchError(`Load more failed: ${response.status}`);\r\n      }\r\n    } catch (err) {\r\n      setSearchError(err instanceof Error ? err.message : \"Load more failed\");\r\n    } finally {\r\n      setLoadingMore(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!query.trim()) {\r\n      setSearchResults([]);\r\n      setSearchError(null);\r\n      setLastSearchQuery(\"\");\r\n      // Don't reset pagination here - top sounds pagination is managed by prefetcher\r\n      return;\r\n    }\r\n\r\n    // If we already searched for this query and have results, don't search again\r\n    if (query === lastSearchQuery && searchResults.length > 0) {\r\n      return;\r\n    }\r\n\r\n    let ignore = false;\r\n\r\n    const timeoutId = setTimeout(async () => {\r\n      try {\r\n        setSearching(true);\r\n        setSearchError(null);\r\n        resetPagination();\r\n\r\n        const response = await fetch(\r\n          `/api/sounds/search?q=${encodeURIComponent(query)}&type=effects&page=1`\r\n        );\r\n\r\n        if (!ignore) {\r\n          if (response.ok) {\r\n            const data = await response.json();\r\n            setSearchResults(data.results);\r\n            setLastSearchQuery(query);\r\n            setHasNextPage(!!data.next);\r\n            setTotalCount(data.count);\r\n            setCurrentPage(1);\r\n          } else {\r\n            setSearchError(`Search failed: ${response.status}`);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        if (!ignore) {\r\n          setSearchError(err instanceof Error ? err.message : \"Search failed\");\r\n        }\r\n      } finally {\r\n        if (!ignore) {\r\n          setSearching(false);\r\n        }\r\n      }\r\n    }, 300);\r\n\r\n    return () => {\r\n      clearTimeout(timeoutId);\r\n      ignore = true;\r\n    };\r\n  }, [\r\n    query,\r\n    lastSearchQuery,\r\n    searchResults.length,\r\n    setSearchResults,\r\n    setSearching,\r\n    setSearchError,\r\n    setLastSearchQuery,\r\n    setCurrentPage,\r\n    setHasNextPage,\r\n    setTotalCount,\r\n    resetPagination,\r\n  ]);\r\n\r\n  return {\r\n    results: searchResults,\r\n    isLoading: isSearching,\r\n    error: searchError,\r\n    loadMore,\r\n    hasNextPage,\r\n    isLoadingMore,\r\n    totalCount,\r\n  };\r\n}\r\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAUO,SAAS,eAAe,KAAa,EAAE,cAAuB;IACnE,MAAM,EACJ,aAAa,EACb,WAAW,EACX,WAAW,EACX,eAAe,EACf,WAAW,EACX,WAAW,EACX,aAAa,EACb,UAAU,EACV,gBAAgB,EAChB,YAAY,EACZ,cAAc,EACd,kBAAkB,EAClB,cAAc,EACd,cAAc,EACd,aAAa,EACb,cAAc,EACd,mBAAmB,EACnB,eAAe,EACf,eAAe,EAChB,GAAG,CAAA,GAAA,+IAAA,CAAA,iBAAc,AAAD;IAEjB,yCAAyC;IACzC,MAAM,WAAW;QACf,IAAI,iBAAiB,CAAC,aAAa;QAEnC,IAAI;YACF,eAAe;YACf,MAAM,WAAW,cAAc;YAE/B,MAAM,eAAe,IAAI,gBAAgB;gBACvC,MAAM,SAAS,QAAQ;gBACvB,MAAM;YACR;YAEA,IAAI,MAAM,IAAI,IAAI;gBAChB,aAAa,GAAG,CAAC,KAAK;YACxB;YAEA,aAAa,GAAG,CAAC,mBAAmB,eAAe,QAAQ;YAC3D,MAAM,WAAW,MAAM,MACrB,CAAC,mBAAmB,EAAE,aAAa,QAAQ,IAAI;YAGjD,IAAI,SAAS,EAAE,EAAE;gBACf,MAAM,OAAO,MAAM,SAAS,IAAI;gBAEhC,+DAA+D;gBAC/D,IAAI,MAAM,IAAI,IAAI;oBAChB,oBAAoB,KAAK,OAAO;gBAClC,OAAO;oBACL,gBAAgB,KAAK,OAAO;gBAC9B;gBAEA,eAAe;gBACf,eAAe,CAAC,CAAC,KAAK,IAAI;gBAC1B,cAAc,KAAK,KAAK;YAC1B,OAAO;gBACL,eAAe,CAAC,kBAAkB,EAAE,SAAS,MAAM,EAAE;YACvD;QACF,EAAE,OAAO,KAAK;YACZ,eAAe,eAAe,QAAQ,IAAI,OAAO,GAAG;QACtD,SAAU;YACR,eAAe;QACjB;IACF;IAEA,CAAA,GAAA,0QAAA,CAAA,YAAS,AAAD,EAAE;QACR,IAAI,CAAC,MAAM,IAAI,IAAI;YACjB,iBAAiB,EAAE;YACnB,eAAe;YACf,mBAAmB;YACnB,+EAA+E;YAC/E;QACF;QAEA,6EAA6E;QAC7E,IAAI,UAAU,mBAAmB,cAAc,MAAM,GAAG,GAAG;YACzD;QACF;QAEA,IAAI,SAAS;QAEb,MAAM,YAAY,WAAW;YAC3B,IAAI;gBACF,aAAa;gBACb,eAAe;gBACf;gBAEA,MAAM,WAAW,MAAM,MACrB,CAAC,qBAAqB,EAAE,mBAAmB,OAAO,oBAAoB,CAAC;gBAGzE,IAAI,CAAC,QAAQ;oBACX,IAAI,SAAS,EAAE,EAAE;wBACf,MAAM,OAAO,MAAM,SAAS,IAAI;wBAChC,iBAAiB,KAAK,OAAO;wBAC7B,mBAAmB;wBACnB,eAAe,CAAC,CAAC,KAAK,IAAI;wBAC1B,cAAc,KAAK,KAAK;wBACxB,eAAe;oBACjB,OAAO;wBACL,eAAe,CAAC,eAAe,EAAE,SAAS,MAAM,EAAE;oBACpD;gBACF;YACF,EAAE,OAAO,KAAK;gBACZ,IAAI,CAAC,QAAQ;oBACX,eAAe,eAAe,QAAQ,IAAI,OAAO,GAAG;gBACtD;YACF,SAAU;gBACR,IAAI,CAAC,QAAQ;oBACX,aAAa;gBACf;YACF;QACF,GAAG;QAEH,OAAO;YACL,aAAa;YACb,SAAS;QACX;IACF,GAAG;QACD;QACA;QACA,cAAc,MAAM;QACpB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,OAAO;QACL,SAAS;QACT,WAAW;QACX,OAAO;QACP;QACA;QACA;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 232, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-infinite-scroll.ts"],"sourcesContent":["import { useRef, useCallback } from \"react\";\r\n\r\ninterface UseInfiniteScrollOptions {\r\n  onLoadMore: () => void;\r\n  hasMore: boolean;\r\n  isLoading: boolean;\r\n  threshold?: number;\r\n  enabled?: boolean;\r\n}\r\n\r\nexport function useInfiniteScroll({\r\n  onLoadMore,\r\n  hasMore,\r\n  isLoading,\r\n  threshold = 200,\r\n  enabled = true,\r\n}: UseInfiniteScrollOptions) {\r\n  const scrollAreaRef = useRef<HTMLDivElement>(null);\r\n\r\n  const handleScroll = useCallback(\r\n    (event: React.UIEvent<HTMLDivElement>) => {\r\n      if (!enabled) return;\r\n\r\n      const { scrollTop, scrollHeight, clientHeight } = event.currentTarget;\r\n      const nearBottom = scrollTop + clientHeight >= scrollHeight - threshold;\r\n\r\n      if (nearBottom && hasMore && !isLoading) {\r\n        onLoadMore();\r\n      }\r\n    },\r\n    [onLoadMore, hasMore, isLoading, threshold, enabled]\r\n  );\r\n\r\n  return { scrollAreaRef, handleScroll };\r\n}\r\n"],"names":[],"mappings":";;;AAAA;;AAUO,SAAS,kBAAkB,EAChC,UAAU,EACV,OAAO,EACP,SAAS,EACT,YAAY,GAAG,EACf,UAAU,IAAI,EACW;IACzB,MAAM,gBAAgB,CAAA,GAAA,0QAAA,CAAA,SAAM,AAAD,EAAkB;IAE7C,MAAM,eAAe,CAAA,GAAA,0QAAA,CAAA,cAAW,AAAD,EAC7B,CAAC;QACC,IAAI,CAAC,SAAS;QAEd,MAAM,EAAE,SAAS,EAAE,YAAY,EAAE,YAAY,EAAE,GAAG,MAAM,aAAa;QACrE,MAAM,aAAa,YAAY,gBAAgB,eAAe;QAE9D,IAAI,cAAc,WAAW,CAAC,WAAW;YACvC;QACF;IACF,GACA;QAAC;QAAY;QAAS;QAAW;QAAW;KAAQ;IAGtD,OAAO;QAAE;QAAe;IAAa;AACvC","debugId":null}},
    {"offset": {"line": 262, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-aspect-ratio.ts"],"sourcesContent":["import { useEditorStore } from \"@/stores/editor-store\";\nimport { useMediaStore, getMediaAspectRatio } from \"@/stores/media-store\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { DEFAULT_CANVAS_SIZE, useProjectStore } from \"@/stores/project-store\";\n\nexport function useAspectRatio() {\n  const { canvasPresets } = useEditorStore();\n  const { activeProject } = useProjectStore();\n  const { mediaFiles } = useMediaStore();\n  const { tracks } = useTimelineStore();\n\n  const canvasSize = activeProject?.canvasSize || DEFAULT_CANVAS_SIZE;\n  const canvasMode = activeProject?.canvasMode || \"preset\";\n\n  // Find the current preset based on canvas size\n  const currentPreset = canvasPresets.find(\n    (preset) =>\n      preset.width === canvasSize.width && preset.height === canvasSize.height\n  );\n\n  // Get the original aspect ratio from the first video/image in timeline\n  const getOriginalAspectRatio = (): number => {\n    // Find first video or image in timeline\n    for (const track of tracks) {\n      for (const element of track.elements) {\n        if (element.type === \"media\") {\n          const mediaFile = mediaFiles.find(\n            (file) => file.id === element.mediaId\n          );\n          if (\n            mediaFile &&\n            (mediaFile.type === \"video\" || mediaFile.type === \"image\")\n          ) {\n            return getMediaAspectRatio(mediaFile);\n          }\n        }\n      }\n    }\n    return 16 / 9; // Default aspect ratio\n  };\n\n  // Get current aspect ratio\n  const getCurrentAspectRatio = (): number => {\n    return canvasSize.width / canvasSize.height;\n  };\n\n  // Format aspect ratio as a readable string\n  const formatAspectRatio = (aspectRatio: number): string => {\n    // Check if it matches a common aspect ratio\n    const ratios = [\n      { ratio: 16 / 9, label: \"16:9\" },\n      { ratio: 9 / 16, label: \"9:16\" },\n      { ratio: 1, label: \"1:1\" },\n      { ratio: 4 / 3, label: \"4:3\" },\n      { ratio: 3 / 4, label: \"3:4\" },\n      { ratio: 21 / 9, label: \"21:9\" },\n    ];\n\n    for (const { ratio, label } of ratios) {\n      if (Math.abs(aspectRatio - ratio) < 0.01) {\n        return label;\n      }\n    }\n\n    // If not a common ratio, format as decimal\n    return aspectRatio.toFixed(2);\n  };\n\n  // Check if current mode is \"Original\"\n  const isOriginal = canvasMode === \"original\";\n\n  // Get display name for current aspect ratio\n  const getDisplayName = (): string => {\n    // If explicitly set to original mode, always show \"Original\"\n    if (canvasMode === \"original\") {\n      return \"Original\";\n    }\n\n    if (currentPreset) {\n      return currentPreset.name;\n    }\n\n    return formatAspectRatio(getCurrentAspectRatio());\n  };\n\n  return {\n    currentPreset,\n    canvasMode,\n    isOriginal,\n    getCurrentAspectRatio,\n    getOriginalAspectRatio,\n    formatAspectRatio,\n    getDisplayName,\n    canvasSize,\n    canvasPresets,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAEO,SAAS;IACd,MAAM,EAAE,aAAa,EAAE,GAAG,CAAA,GAAA,+IAAA,CAAA,iBAAc,AAAD;IACvC,MAAM,EAAE,aAAa,EAAE,GAAG,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD;IACxC,MAAM,EAAE,UAAU,EAAE,GAAG,CAAA,GAAA,8IAAA,CAAA,gBAAa,AAAD;IACnC,MAAM,EAAE,MAAM,EAAE,GAAG,CAAA,GAAA,iJAAA,CAAA,mBAAgB,AAAD;IAElC,MAAM,aAAa,eAAe,cAAc,gJAAA,CAAA,sBAAmB;IACnE,MAAM,aAAa,eAAe,cAAc;IAEhD,+CAA+C;IAC/C,MAAM,gBAAgB,cAAc,IAAI,CACtC,CAAC,SACC,OAAO,KAAK,KAAK,WAAW,KAAK,IAAI,OAAO,MAAM,KAAK,WAAW,MAAM;IAG5E,uEAAuE;IACvE,MAAM,yBAAyB;QAC7B,wCAAwC;QACxC,KAAK,MAAM,SAAS,OAAQ;YAC1B,KAAK,MAAM,WAAW,MAAM,QAAQ,CAAE;gBACpC,IAAI,QAAQ,IAAI,KAAK,SAAS;oBAC5B,MAAM,YAAY,WAAW,IAAI,CAC/B,CAAC,OAAS,KAAK,EAAE,KAAK,QAAQ,OAAO;oBAEvC,IACE,aACA,CAAC,UAAU,IAAI,KAAK,WAAW,UAAU,IAAI,KAAK,OAAO,GACzD;wBACA,OAAO,CAAA,GAAA,8IAAA,CAAA,sBAAmB,AAAD,EAAE;oBAC7B;gBACF;YACF;QACF;QACA,OAAO,KAAK,GAAG,uBAAuB;IACxC;IAEA,2BAA2B;IAC3B,MAAM,wBAAwB;QAC5B,OAAO,WAAW,KAAK,GAAG,WAAW,MAAM;IAC7C;IAEA,2CAA2C;IAC3C,MAAM,oBAAoB,CAAC;QACzB,4CAA4C;QAC5C,MAAM,SAAS;YACb;gBAAE,OAAO,KAAK;gBAAG,OAAO;YAAO;YAC/B;gBAAE,OAAO,IAAI;gBAAI,OAAO;YAAO;YAC/B;gBAAE,OAAO;gBAAG,OAAO;YAAM;YACzB;gBAAE,OAAO,IAAI;gBAAG,OAAO;YAAM;YAC7B;gBAAE,OAAO,IAAI;gBAAG,OAAO;YAAM;YAC7B;gBAAE,OAAO,KAAK;gBAAG,OAAO;YAAO;SAChC;QAED,KAAK,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,OAAQ;YACrC,IAAI,KAAK,GAAG,CAAC,cAAc,SAAS,MAAM;gBACxC,OAAO;YACT;QACF;QAEA,2CAA2C;QAC3C,OAAO,YAAY,OAAO,CAAC;IAC7B;IAEA,sCAAsC;IACtC,MAAM,aAAa,eAAe;IAElC,4CAA4C;IAC5C,MAAM,iBAAiB;QACrB,6DAA6D;QAC7D,IAAI,eAAe,YAAY;YAC7B,OAAO;QACT;QAEA,IAAI,eAAe;YACjB,OAAO,cAAc,IAAI;QAC3B;QAEA,OAAO,kBAAkB;IAC3B;IAEA,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 367, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-timeline-zoom.ts"],"sourcesContent":["import { useState, useCallback, useEffect, RefObject } from \"react\";\n\ninterface UseTimelineZoomProps {\n  containerRef: RefObject<HTMLDivElement>;\n  isInTimeline?: boolean;\n}\n\ninterface UseTimelineZoomReturn {\n  zoomLevel: number;\n  setZoomLevel: (zoomLevel: number | ((prev: number) => number)) => void;\n  handleWheel: (e: React.WheelEvent) => void;\n}\n\nexport function useTimelineZoom({\n  containerRef,\n  isInTimeline = false,\n}: UseTimelineZoomProps): UseTimelineZoomReturn {\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  const handleWheel = useCallback((e: React.WheelEvent) => {\n    // Only zoom if user is using pinch gesture (ctrlKey or metaKey is true)\n    if (e.ctrlKey || e.metaKey) {\n      e.preventDefault();\n      const delta = e.deltaY > 0 ? -0.15 : 0.15;\n      setZoomLevel((prev) => Math.max(0.1, Math.min(10, prev + delta)));\n    }\n    // For horizontal scrolling (when shift is held or horizontal wheel movement),\n    // let the event bubble up to allow ScrollArea to handle it\n    else if (e.shiftKey || Math.abs(e.deltaX) > Math.abs(e.deltaY)) {\n      // Don't prevent default - let ScrollArea handle horizontal scrolling\n      return;\n    }\n    // Otherwise, allow normal scrolling\n  }, []);\n\n  // Prevent browser zooming in/out when in timeline\n  useEffect(() => {\n    const preventZoom = (e: WheelEvent) => {\n      if (\n        isInTimeline &&\n        (e.ctrlKey || e.metaKey) &&\n        containerRef.current?.contains(e.target as Node)\n      ) {\n        e.preventDefault();\n      }\n    };\n\n    document.addEventListener(\"wheel\", preventZoom, { passive: false });\n\n    return () => {\n      document.removeEventListener(\"wheel\", preventZoom);\n    };\n  }, [isInTimeline, containerRef]);\n\n  return {\n    zoomLevel,\n    setZoomLevel,\n    handleWheel,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AAaO,SAAS,gBAAgB,EAC9B,YAAY,EACZ,eAAe,KAAK,EACC;IACrB,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,0QAAA,CAAA,WAAQ,AAAD,EAAE;IAE3C,MAAM,cAAc,CAAA,GAAA,0QAAA,CAAA,cAAW,AAAD,EAAE,CAAC;QAC/B,wEAAwE;QACxE,IAAI,EAAE,OAAO,IAAI,EAAE,OAAO,EAAE;YAC1B,EAAE,cAAc;YAChB,MAAM,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC,OAAO;YACrC,aAAa,CAAC,OAAS,KAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,IAAI,OAAO;QAC3D,OAGK,IAAI,EAAE,QAAQ,IAAI,KAAK,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,GAAG,CAAC,EAAE,MAAM,GAAG;YAC9D,qEAAqE;YACrE;QACF;IACA,oCAAoC;IACtC,GAAG,EAAE;IAEL,kDAAkD;IAClD,CAAA,GAAA,0QAAA,CAAA,YAAS,AAAD,EAAE;QACR,MAAM,cAAc,CAAC;YACnB,IACE,gBACA,CAAC,EAAE,OAAO,IAAI,EAAE,OAAO,KACvB,aAAa,OAAO,EAAE,SAAS,EAAE,MAAM,GACvC;gBACA,EAAE,cAAc;YAClB;QACF;QAEA,SAAS,gBAAgB,CAAC,SAAS,aAAa;YAAE,SAAS;QAAM;QAEjE,OAAO;YACL,SAAS,mBAAmB,CAAC,SAAS;QACxC;IACF,GAAG;QAAC;QAAc;KAAa;IAE/B,OAAO;QACL;QACA;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-timeline-element-resize.ts"],"sourcesContent":["import { useState, useEffect } from \"react\";\nimport { ResizeState, TimelineElement, TimelineTrack } from \"@/types/timeline\";\nimport { useMediaStore } from \"@/stores/media-store\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { DEFAULT_FPS, useProjectStore } from \"@/stores/project-store\";\nimport { snapTimeToFrame } from \"@/constants/timeline-constants\";\n\ninterface UseTimelineElementResizeProps {\n  element: TimelineElement;\n  track: TimelineTrack;\n  zoomLevel: number;\n}\n\nexport function useTimelineElementResize({\n  element,\n  track,\n  zoomLevel,\n}: UseTimelineElementResizeProps) {\n  const [resizing, setResizing] = useState<ResizeState | null>(null);\n  const { mediaFiles } = useMediaStore();\n  const {\n    updateElementStartTime,\n    updateElementTrim,\n    updateElementDuration,\n    pushHistory,\n  } = useTimelineStore();\n\n  // Set up document-level mouse listeners during resize (like proper drag behavior)\n  useEffect(() => {\n    if (!resizing) return;\n\n    const handleDocumentMouseMove = (e: MouseEvent) => {\n      updateTrimFromMouseMove({ clientX: e.clientX });\n    };\n\n    const handleDocumentMouseUp = () => {\n      handleResizeEnd();\n    };\n\n    // Add document-level listeners for proper drag behavior\n    document.addEventListener(\"mousemove\", handleDocumentMouseMove);\n    document.addEventListener(\"mouseup\", handleDocumentMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleDocumentMouseMove);\n      document.removeEventListener(\"mouseup\", handleDocumentMouseUp);\n    };\n  }, [resizing]); // Re-run when resizing state changes\n\n  const handleResizeStart = (\n    e: React.MouseEvent,\n    elementId: string,\n    side: \"left\" | \"right\"\n  ) => {\n    e.stopPropagation();\n    e.preventDefault();\n\n    // Push history once at the start of the resize operation\n    pushHistory();\n\n    setResizing({\n      elementId,\n      side,\n      startX: e.clientX,\n      initialTrimStart: element.trimStart,\n      initialTrimEnd: element.trimEnd,\n    });\n  };\n\n  const canExtendElementDuration = () => {\n    // Text elements can always be extended\n    if (element.type === \"text\") {\n      return true;\n    }\n\n    // Media elements - check the media type\n    if (element.type === \"media\") {\n      const mediaFile = mediaFiles.find((file) => file.id === element.mediaId);\n      if (!mediaFile) return false;\n\n      // Images can be extended (static content)\n      if (mediaFile.type === \"image\") {\n        return true;\n      }\n\n      // Videos and audio cannot be extended beyond their natural duration\n      // (no additional content exists)\n      return false;\n    }\n\n    return false;\n  };\n\n  const updateTrimFromMouseMove = (e: { clientX: number }) => {\n    if (!resizing) return;\n\n    const deltaX = e.clientX - resizing.startX;\n    // Reasonable sensitivity for resize operations - similar to timeline scale\n    const deltaTime = deltaX / (50 * zoomLevel);\n\n    // Get project FPS for frame snapping\n    const projectStore = useProjectStore.getState();\n    const projectFps = projectStore.activeProject?.fps || DEFAULT_FPS;\n\n    if (resizing.side === \"left\") {\n      // Left resize - different behavior for media vs text/image elements\n      const maxAllowed = element.duration - resizing.initialTrimEnd - 0.1;\n      const calculated = resizing.initialTrimStart + deltaTime;\n\n      if (calculated >= 0) {\n        // Normal trimming within available content\n        const newTrimStart = snapTimeToFrame(\n          Math.min(maxAllowed, calculated),\n          projectFps\n        );\n        const trimDelta = newTrimStart - resizing.initialTrimStart;\n        const newStartTime = snapTimeToFrame(\n          element.startTime + trimDelta,\n          projectFps\n        );\n\n        updateElementTrim(\n          track.id,\n          element.id,\n          newTrimStart,\n          resizing.initialTrimEnd,\n          false\n        );\n        updateElementStartTime(track.id, element.id, newStartTime, false);\n      } else {\n        // Trying to extend beyond trimStart = 0\n        if (canExtendElementDuration()) {\n          // Text/Image: extend element to the left by moving startTime and increasing duration\n          const extensionAmount = Math.abs(calculated);\n          const maxExtension = element.startTime;\n          const actualExtension = Math.min(extensionAmount, maxExtension);\n          const newStartTime = snapTimeToFrame(\n            element.startTime - actualExtension,\n            projectFps\n          );\n          const newDuration = snapTimeToFrame(\n            element.duration + actualExtension,\n            projectFps\n          );\n\n          // Keep trimStart at 0 and extend the element\n          updateElementTrim(\n            track.id,\n            element.id,\n            0,\n            resizing.initialTrimEnd,\n            false\n          );\n          updateElementDuration(track.id, element.id, newDuration, false);\n          updateElementStartTime(track.id, element.id, newStartTime, false);\n        } else {\n          // Video/Audio: can't extend beyond original content - limit to trimStart = 0\n          const newTrimStart = 0;\n          const trimDelta = newTrimStart - resizing.initialTrimStart;\n          const newStartTime = snapTimeToFrame(\n            element.startTime + trimDelta,\n            projectFps\n          );\n\n          updateElementTrim(\n            track.id,\n            element.id,\n            newTrimStart,\n            resizing.initialTrimEnd,\n            false\n          );\n          updateElementStartTime(track.id, element.id, newStartTime, false);\n        }\n      }\n    } else {\n      // Right resize - can extend duration for supported element types\n      const calculated = resizing.initialTrimEnd - deltaTime;\n\n      if (calculated < 0) {\n        // We're trying to extend beyond original duration\n        if (canExtendElementDuration()) {\n          // Extend the duration instead of reducing trimEnd further\n          const extensionNeeded = Math.abs(calculated);\n          const newDuration = snapTimeToFrame(\n            element.duration + extensionNeeded,\n            projectFps\n          );\n          const newTrimEnd = 0; // Reset trimEnd to 0 since we're extending\n\n          // Update duration first, then trim\n          updateElementDuration(track.id, element.id, newDuration, false);\n          updateElementTrim(\n            track.id,\n            element.id,\n            resizing.initialTrimStart,\n            newTrimEnd,\n            false\n          );\n        } else {\n          // Can't extend - just set trimEnd to 0 (maximum possible extension)\n          updateElementTrim(\n            track.id,\n            element.id,\n            resizing.initialTrimStart,\n            0,\n            false\n          );\n        }\n      } else {\n        // Normal trimming within original duration\n        // Calculate the desired end time based on mouse movement\n        const currentEndTime =\n          element.startTime +\n          element.duration -\n          element.trimStart -\n          element.trimEnd;\n        const desiredEndTime = currentEndTime + deltaTime;\n\n        // Snap the desired end time to frame\n        const snappedEndTime = snapTimeToFrame(desiredEndTime, projectFps);\n\n        // Calculate what trimEnd should be to achieve this snapped end time\n        const newTrimEnd = Math.max(\n          0,\n          element.duration -\n            element.trimStart -\n            (snappedEndTime - element.startTime)\n        );\n\n        // Ensure we don't trim more than available content (leave at least 0.1s visible)\n        const maxTrimEnd = element.duration - element.trimStart - 0.1;\n        const finalTrimEnd = Math.min(maxTrimEnd, newTrimEnd);\n\n        updateElementTrim(\n          track.id,\n          element.id,\n          element.trimStart,\n          finalTrimEnd,\n          false\n        );\n      }\n    }\n  };\n\n  const handleResizeEnd = () => {\n    setResizing(null);\n  };\n\n  return {\n    resizing,\n    isResizing: resizing !== null,\n    handleResizeStart,\n    // Return empty handlers since we use document listeners now\n    handleResizeMove: () => {}, // Not used anymore\n    handleResizeEnd: () => {}, // Not used anymore\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 573, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-timeline-snapping.ts"],"sourcesContent":["import { useCallback } from \"react\";\nimport { TimelineTrack } from \"@/types/timeline\";\nimport { TIMELINE_CONSTANTS } from \"@/constants/timeline-constants\";\n\nexport interface SnapPoint {\n  time: number;\n  type: \"element-start\" | \"element-end\" | \"playhead\";\n  elementId?: string;\n  trackId?: string;\n}\n\nexport interface SnapResult {\n  snappedTime: number;\n  snapPoint: SnapPoint | null;\n  snapDistance: number;\n}\n\nexport interface UseTimelineSnappingOptions {\n  snapThreshold?: number; // Distance in pixels to trigger snapping\n  enableElementSnapping?: boolean;\n  enablePlayheadSnapping?: boolean;\n}\n\nexport function useTimelineSnapping({\n  snapThreshold = 10,\n  enableElementSnapping = true,\n  enablePlayheadSnapping = true,\n}: UseTimelineSnappingOptions = {}) {\n  const findSnapPoints = useCallback(\n    (\n      tracks: TimelineTrack[],\n      currentTime: number,\n      playheadTime: number,\n      zoomLevel: number,\n      excludeElementId?: string\n    ): SnapPoint[] => {\n      const snapPoints: SnapPoint[] = [];\n\n      // Add element snap points\n      if (enableElementSnapping) {\n        tracks.forEach((track) => {\n          track.elements.forEach((element) => {\n            // Skip the element being dragged\n            if (element.id === excludeElementId) return;\n\n            const elementStart = element.startTime;\n            const elementEnd =\n              element.startTime +\n              (element.duration - element.trimStart - element.trimEnd);\n\n            snapPoints.push(\n              {\n                time: elementStart,\n                type: \"element-start\",\n                elementId: element.id,\n                trackId: track.id,\n              },\n              {\n                time: elementEnd,\n                type: \"element-end\",\n                elementId: element.id,\n                trackId: track.id,\n              }\n            );\n          });\n        });\n      }\n\n      // Add playhead snap point\n      if (enablePlayheadSnapping) {\n        snapPoints.push({\n          time: playheadTime,\n          type: \"playhead\",\n        });\n      }\n\n      return snapPoints;\n    },\n    [enableElementSnapping, enablePlayheadSnapping]\n  );\n\n  const snapToNearestPoint = useCallback(\n    (\n      targetTime: number,\n      snapPoints: SnapPoint[],\n      zoomLevel: number\n    ): SnapResult => {\n      const pixelsPerSecond = TIMELINE_CONSTANTS.PIXELS_PER_SECOND * zoomLevel;\n      const thresholdInSeconds = snapThreshold / pixelsPerSecond;\n\n      let closestSnapPoint: SnapPoint | null = null;\n      let closestDistance = Infinity;\n\n      snapPoints.forEach((snapPoint) => {\n        const distance = Math.abs(targetTime - snapPoint.time);\n        if (distance < thresholdInSeconds && distance < closestDistance) {\n          closestDistance = distance;\n          closestSnapPoint = snapPoint;\n        }\n      });\n\n      return {\n        snappedTime: closestSnapPoint\n          ? (closestSnapPoint as SnapPoint).time\n          : targetTime,\n        snapPoint: closestSnapPoint,\n        snapDistance: closestDistance,\n      };\n    },\n    [snapThreshold]\n  );\n\n  const snapElementPosition = useCallback(\n    (\n      targetTime: number,\n      tracks: TimelineTrack[],\n      playheadTime: number,\n      zoomLevel: number,\n      excludeElementId?: string\n    ): SnapResult => {\n      const snapPoints = findSnapPoints(\n        tracks,\n        targetTime,\n        playheadTime,\n        zoomLevel,\n        excludeElementId\n      );\n\n      return snapToNearestPoint(targetTime, snapPoints, zoomLevel);\n    },\n    [findSnapPoints, snapToNearestPoint]\n  );\n\n  const snapElementEdge = useCallback(\n    (\n      targetTime: number,\n      elementDuration: number,\n      tracks: TimelineTrack[],\n      playheadTime: number,\n      zoomLevel: number,\n      excludeElementId?: string,\n      snapToStart = true // true for start edge, false for end edge\n    ): SnapResult => {\n      const snapPoints = findSnapPoints(\n        tracks,\n        targetTime,\n        playheadTime,\n        zoomLevel,\n        excludeElementId\n      );\n\n      // For end edge snapping, we need to account for element duration\n      const effectiveTargetTime = snapToStart\n        ? targetTime\n        : targetTime + elementDuration;\n      const snapResult = snapToNearestPoint(\n        effectiveTargetTime,\n        snapPoints,\n        zoomLevel\n      );\n\n      // Adjust the snapped time back for end edge\n      if (!snapToStart && snapResult.snapPoint) {\n        snapResult.snappedTime = snapResult.snappedTime - elementDuration;\n      }\n\n      return snapResult;\n    },\n    [findSnapPoints, snapToNearestPoint]\n  );\n\n  return {\n    snapElementPosition,\n    snapElementEdge,\n    findSnapPoints,\n    snapToNearestPoint,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAqBO,SAAS,oBAAoB,EAClC,gBAAgB,EAAE,EAClB,wBAAwB,IAAI,EAC5B,yBAAyB,IAAI,EACF,GAAG,CAAC,CAAC;IAChC,MAAM,iBAAiB,CAAA,GAAA,0QAAA,CAAA,cAAW,AAAD,EAC/B,CACE,QACA,aACA,cACA,WACA;QAEA,MAAM,aAA0B,EAAE;QAElC,0BAA0B;QAC1B,IAAI,uBAAuB;YACzB,OAAO,OAAO,CAAC,CAAC;gBACd,MAAM,QAAQ,CAAC,OAAO,CAAC,CAAC;oBACtB,iCAAiC;oBACjC,IAAI,QAAQ,EAAE,KAAK,kBAAkB;oBAErC,MAAM,eAAe,QAAQ,SAAS;oBACtC,MAAM,aACJ,QAAQ,SAAS,GACjB,CAAC,QAAQ,QAAQ,GAAG,QAAQ,SAAS,GAAG,QAAQ,OAAO;oBAEzD,WAAW,IAAI,CACb;wBACE,MAAM;wBACN,MAAM;wBACN,WAAW,QAAQ,EAAE;wBACrB,SAAS,MAAM,EAAE;oBACnB,GACA;wBACE,MAAM;wBACN,MAAM;wBACN,WAAW,QAAQ,EAAE;wBACrB,SAAS,MAAM,EAAE;oBACnB;gBAEJ;YACF;QACF;QAEA,0BAA0B;QAC1B,IAAI,wBAAwB;YAC1B,WAAW,IAAI,CAAC;gBACd,MAAM;gBACN,MAAM;YACR;QACF;QAEA,OAAO;IACT,GACA;QAAC;QAAuB;KAAuB;IAGjD,MAAM,qBAAqB,CAAA,GAAA,0QAAA,CAAA,cAAW,AAAD,EACnC,CACE,YACA,YACA;QAEA,MAAM,kBAAkB,wJAAA,CAAA,qBAAkB,CAAC,iBAAiB,GAAG;QAC/D,MAAM,qBAAqB,gBAAgB;QAE3C,IAAI,mBAAqC;QACzC,IAAI,kBAAkB;QAEtB,WAAW,OAAO,CAAC,CAAC;YAClB,MAAM,WAAW,KAAK,GAAG,CAAC,aAAa,UAAU,IAAI;YACrD,IAAI,WAAW,sBAAsB,WAAW,iBAAiB;gBAC/D,kBAAkB;gBAClB,mBAAmB;YACrB;QACF;QAEA,OAAO;YACL,aAAa,mBACT,AAAC,iBAA+B,IAAI,GACpC;YACJ,WAAW;YACX,cAAc;QAChB;IACF,GACA;QAAC;KAAc;IAGjB,MAAM,sBAAsB,CAAA,GAAA,0QAAA,CAAA,cAAW,AAAD,EACpC,CACE,YACA,QACA,cACA,WACA;QAEA,MAAM,aAAa,eACjB,QACA,YACA,cACA,WACA;QAGF,OAAO,mBAAmB,YAAY,YAAY;IACpD,GACA;QAAC;QAAgB;KAAmB;IAGtC,MAAM,kBAAkB,CAAA,GAAA,0QAAA,CAAA,cAAW,AAAD,EAChC,CACE,YACA,iBACA,QACA,cACA,WACA,kBACA,cAAc,KAAK,0CAA0C;IAA3C;QAElB,MAAM,aAAa,eACjB,QACA,YACA,cACA,WACA;QAGF,iEAAiE;QACjE,MAAM,sBAAsB,cACxB,aACA,aAAa;QACjB,MAAM,aAAa,mBACjB,qBACA,YACA;QAGF,4CAA4C;QAC5C,IAAI,CAAC,eAAe,WAAW,SAAS,EAAE;YACxC,WAAW,WAAW,GAAG,WAAW,WAAW,GAAG;QACpD;QAEA,OAAO;IACT,GACA;QAAC;QAAgB;KAAmB;IAGtC,OAAO;QACL;QACA;QACA;QACA;IACF;AACF","debugId":null}},
    {"offset": {"line": 670, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-edge-auto-scroll.ts"],"sourcesContent":["import { useEffect, useRef } from \"react\";\r\n\r\ninterface UseEdgeAutoScrollParams {\r\n  isActive: boolean;\r\n  getMouseClientX: () => number;\r\n  rulerScrollRef: React.RefObject<HTMLDivElement>;\r\n  tracksScrollRef: React.RefObject<HTMLDivElement>;\r\n  contentWidth: number;\r\n  edgeThreshold?: number;\r\n  maxScrollSpeed?: number;\r\n}\r\n\r\n// Provides smooth edge auto-scrolling for horizontal timeline interactions.\r\nexport function useEdgeAutoScroll({\r\n  isActive,\r\n  getMouseClientX,\r\n  rulerScrollRef,\r\n  tracksScrollRef,\r\n  contentWidth,\r\n  edgeThreshold = 100,\r\n  maxScrollSpeed = 15,\r\n}: UseEdgeAutoScrollParams): void {\r\n  const rafRef = useRef<number | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (!isActive) {\r\n      if (rafRef.current) {\r\n        cancelAnimationFrame(rafRef.current);\r\n        rafRef.current = null;\r\n      }\r\n      return;\r\n    }\r\n\r\n    const step = () => {\r\n      const rulerViewport = rulerScrollRef.current;\r\n      const tracksViewport = tracksScrollRef.current;\r\n      if (!rulerViewport || !tracksViewport) {\r\n        rafRef.current = requestAnimationFrame(step);\r\n        return;\r\n      }\r\n\r\n      const viewportRect = rulerViewport.getBoundingClientRect();\r\n      const mouseX = getMouseClientX();\r\n      const mouseXRelative = mouseX - viewportRect.left;\r\n\r\n      const viewportWidth = rulerViewport.clientWidth;\r\n      const intrinsicContentWidth = rulerViewport.scrollWidth;\r\n      const effectiveContentWidth = Math.max(\r\n        contentWidth,\r\n        intrinsicContentWidth\r\n      );\r\n      const scrollMax = Math.max(0, effectiveContentWidth - viewportWidth);\r\n\r\n      let scrollSpeed = 0;\r\n\r\n      if (mouseXRelative < edgeThreshold && rulerViewport.scrollLeft > 0) {\r\n        const edgeDistance = Math.max(0, mouseXRelative);\r\n        const intensity = 1 - edgeDistance / edgeThreshold;\r\n        scrollSpeed = -maxScrollSpeed * intensity;\r\n      } else if (\r\n        mouseXRelative > viewportWidth - edgeThreshold &&\r\n        rulerViewport.scrollLeft < scrollMax\r\n      ) {\r\n        const edgeDistance = Math.max(\r\n          0,\r\n          viewportWidth - edgeThreshold - mouseXRelative\r\n        );\r\n        const intensity = 1 - edgeDistance / edgeThreshold;\r\n        scrollSpeed = maxScrollSpeed * intensity;\r\n      }\r\n\r\n      if (scrollSpeed !== 0) {\r\n        const newScrollLeft = Math.max(\r\n          0,\r\n          Math.min(scrollMax, rulerViewport.scrollLeft + scrollSpeed)\r\n        );\r\n        rulerViewport.scrollLeft = newScrollLeft;\r\n        tracksViewport.scrollLeft = newScrollLeft;\r\n      }\r\n\r\n      rafRef.current = requestAnimationFrame(step);\r\n    };\r\n\r\n    rafRef.current = requestAnimationFrame(step);\r\n\r\n    return () => {\r\n      if (rafRef.current) {\r\n        cancelAnimationFrame(rafRef.current);\r\n        rafRef.current = null;\r\n      }\r\n    };\r\n  }, [\r\n    isActive,\r\n    getMouseClientX,\r\n    rulerScrollRef,\r\n    tracksScrollRef,\r\n    contentWidth,\r\n    edgeThreshold,\r\n    maxScrollSpeed,\r\n  ]);\r\n}\r\n"],"names":[],"mappings":";;;AAAA;;AAaO,SAAS,kBAAkB,EAChC,QAAQ,EACR,eAAe,EACf,cAAc,EACd,eAAe,EACf,YAAY,EACZ,gBAAgB,GAAG,EACnB,iBAAiB,EAAE,EACK;IACxB,MAAM,SAAS,CAAA,GAAA,0QAAA,CAAA,SAAM,AAAD,EAAiB;IAErC,CAAA,GAAA,0QAAA,CAAA,YAAS,AAAD,EAAE;QACR,IAAI,CAAC,UAAU;YACb,IAAI,OAAO,OAAO,EAAE;gBAClB,qBAAqB,OAAO,OAAO;gBACnC,OAAO,OAAO,GAAG;YACnB;YACA;QACF;QAEA,MAAM,OAAO;YACX,MAAM,gBAAgB,eAAe,OAAO;YAC5C,MAAM,iBAAiB,gBAAgB,OAAO;YAC9C,IAAI,CAAC,iBAAiB,CAAC,gBAAgB;gBACrC,OAAO,OAAO,GAAG,sBAAsB;gBACvC;YACF;YAEA,MAAM,eAAe,cAAc,qBAAqB;YACxD,MAAM,SAAS;YACf,MAAM,iBAAiB,SAAS,aAAa,IAAI;YAEjD,MAAM,gBAAgB,cAAc,WAAW;YAC/C,MAAM,wBAAwB,cAAc,WAAW;YACvD,MAAM,wBAAwB,KAAK,GAAG,CACpC,cACA;YAEF,MAAM,YAAY,KAAK,GAAG,CAAC,GAAG,wBAAwB;YAEtD,IAAI,cAAc;YAElB,IAAI,iBAAiB,iBAAiB,cAAc,UAAU,GAAG,GAAG;gBAClE,MAAM,eAAe,KAAK,GAAG,CAAC,GAAG;gBACjC,MAAM,YAAY,IAAI,eAAe;gBACrC,cAAc,CAAC,iBAAiB;YAClC,OAAO,IACL,iBAAiB,gBAAgB,iBACjC,cAAc,UAAU,GAAG,WAC3B;gBACA,MAAM,eAAe,KAAK,GAAG,CAC3B,GACA,gBAAgB,gBAAgB;gBAElC,MAAM,YAAY,IAAI,eAAe;gBACrC,cAAc,iBAAiB;YACjC;YAEA,IAAI,gBAAgB,GAAG;gBACrB,MAAM,gBAAgB,KAAK,GAAG,CAC5B,GACA,KAAK,GAAG,CAAC,WAAW,cAAc,UAAU,GAAG;gBAEjD,cAAc,UAAU,GAAG;gBAC3B,eAAe,UAAU,GAAG;YAC9B;YAEA,OAAO,OAAO,GAAG,sBAAsB;QACzC;QAEA,OAAO,OAAO,GAAG,sBAAsB;QAEvC,OAAO;YACL,IAAI,OAAO,OAAO,EAAE;gBAClB,qBAAqB,OAAO,OAAO;gBACnC,OAAO,OAAO,GAAG;YACnB;QACF;IACF,GAAG;QACD;QACA;QACA;QACA;QACA;QACA;QACA;KACD;AACH","debugId":null}},
    {"offset": {"line": 737, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-timeline-playhead.ts"],"sourcesContent":["import { snapTimeToFrame } from \"@/constants/timeline-constants\";\nimport { DEFAULT_FPS, useProjectStore } from \"@/stores/project-store\";\nimport { usePlaybackStore } from \"@/stores/playback-store\";\nimport { useState, useEffect, useCallback, useRef } from \"react\";\nimport { useEdgeAutoScroll } from \"@/hooks/use-edge-auto-scroll\";\n\ninterface UseTimelinePlayheadProps {\n  currentTime: number;\n  duration: number;\n  zoomLevel: number;\n  seek: (time: number) => void;\n  rulerRef: React.RefObject<HTMLDivElement>;\n  rulerScrollRef: React.RefObject<HTMLDivElement>;\n  tracksScrollRef: React.RefObject<HTMLDivElement>;\n  playheadRef?: React.RefObject<HTMLDivElement>;\n}\n\nexport function useTimelinePlayhead({\n  currentTime,\n  duration,\n  zoomLevel,\n  seek,\n  rulerRef,\n  rulerScrollRef,\n  tracksScrollRef,\n  playheadRef,\n}: UseTimelinePlayheadProps) {\n  // Playhead scrubbing state\n  const [isScrubbing, setIsScrubbing] = useState(false);\n  const [scrubTime, setScrubTime] = useState<number | null>(null);\n\n  // Ruler drag detection state\n  const [isDraggingRuler, setIsDraggingRuler] = useState(false);\n  const [hasDraggedRuler, setHasDraggedRuler] = useState(false);\n  const lastMouseXRef = useRef<number>(0);\n\n  const playheadPosition =\n    isScrubbing && scrubTime !== null ? scrubTime : currentTime;\n\n  // --- Playhead Scrubbing Handlers ---\n  const handlePlayheadMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      e.preventDefault();\n      e.stopPropagation(); // Prevent ruler drag from triggering\n      setIsScrubbing(true);\n      handleScrub(e);\n    },\n    [duration, zoomLevel]\n  );\n\n  // Ruler mouse down handler\n  const handleRulerMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      // Only handle left mouse button\n      if (e.button !== 0) return;\n\n      // Don't interfere if clicking on the playhead itself\n      if (playheadRef?.current?.contains(e.target as Node)) return;\n\n      e.preventDefault();\n      setIsDraggingRuler(true);\n      setHasDraggedRuler(false);\n\n      // Start scrubbing immediately\n      setIsScrubbing(true);\n      handleScrub(e);\n    },\n    [duration, zoomLevel]\n  );\n\n  const handleScrub = useCallback(\n    (e: MouseEvent | React.MouseEvent) => {\n      const ruler = rulerRef.current;\n      if (!ruler) return;\n      const rect = ruler.getBoundingClientRect();\n      const rawX = e.clientX - rect.left;\n\n      // Get the timeline content width based on duration and zoom\n      const timelineContentWidth = duration * 50 * zoomLevel; // TIMELINE_CONSTANTS.PIXELS_PER_SECOND = 50\n\n      // Constrain x to be within the timeline content bounds\n      const x = Math.max(0, Math.min(timelineContentWidth, rawX));\n\n      const rawTime = Math.max(0, Math.min(duration, x / (50 * zoomLevel)));\n      // Use frame snapping for playhead scrubbing\n      const projectStore = useProjectStore.getState();\n      const projectFps = projectStore.activeProject?.fps || DEFAULT_FPS;\n      const time = snapTimeToFrame(rawTime, projectFps);\n\n      // Debug logging\n      if (rawX < 0 || x !== rawX) {\n        console.log(\n          \"PLAYHEAD DEBUG:\",\n          JSON.stringify({\n            mouseX: e.clientX,\n            rulerLeft: rect.left,\n            rawX,\n            constrainedX: x,\n            timelineContentWidth,\n            rawTime,\n            finalTime: time,\n            duration,\n            zoomLevel,\n            playheadPx: time * 50 * zoomLevel,\n          })\n        );\n      }\n\n      setScrubTime(time);\n      seek(time); // update video preview in real time\n\n      // Store mouse position for auto-scrolling\n      lastMouseXRef.current = e.clientX;\n    },\n    [duration, zoomLevel, seek, rulerRef]\n  );\n\n  useEdgeAutoScroll({\n    isActive: isScrubbing,\n    getMouseClientX: () => lastMouseXRef.current,\n    rulerScrollRef,\n    tracksScrollRef,\n    contentWidth: duration * 50 * zoomLevel,\n  });\n\n  // Mouse move/up event handlers\n  useEffect(() => {\n    if (!isScrubbing) return;\n\n    const onMouseMove = (e: MouseEvent) => {\n      handleScrub(e);\n      // Mark that we've dragged if ruler drag is active\n      if (isDraggingRuler) {\n        setHasDraggedRuler(true);\n      }\n    };\n\n    const onMouseUp = (e: MouseEvent) => {\n      setIsScrubbing(false);\n      if (scrubTime !== null) seek(scrubTime); // finalize seek\n      setScrubTime(null);\n\n      // Handle ruler click vs drag\n      if (isDraggingRuler) {\n        setIsDraggingRuler(false);\n        // If we didn't drag, treat it as a click-to-seek\n        if (!hasDraggedRuler) {\n          handleScrub(e);\n        }\n        setHasDraggedRuler(false);\n      }\n    };\n\n    window.addEventListener(\"mousemove\", onMouseMove);\n    window.addEventListener(\"mouseup\", onMouseUp);\n\n    // Edge auto-scroll is handled by useEdgeAutoScroll\n\n    return () => {\n      window.removeEventListener(\"mousemove\", onMouseMove);\n      window.removeEventListener(\"mouseup\", onMouseUp);\n      // nothing to cleanup for edge auto scroll\n    };\n  }, [\n    isScrubbing,\n    scrubTime,\n    seek,\n    handleScrub,\n    isDraggingRuler,\n    hasDraggedRuler,\n    // edge auto scroll hook is independent\n  ]);\n\n  // --- Playhead auto-scroll effect (only during playback) ---\n  useEffect(() => {\n    const { isPlaying } = usePlaybackStore.getState();\n\n    // Only auto-scroll during playback, not during manual interactions\n    if (!isPlaying || isScrubbing) return;\n\n    const rulerViewport = rulerScrollRef.current;\n    const tracksViewport = tracksScrollRef.current;\n    if (!rulerViewport || !tracksViewport) return;\n\n    const playheadPx = playheadPosition * 50 * zoomLevel; // TIMELINE_CONSTANTS.PIXELS_PER_SECOND = 50\n    const viewportWidth = rulerViewport.clientWidth;\n    const scrollMin = 0;\n    const scrollMax = rulerViewport.scrollWidth - viewportWidth;\n\n    // Only auto-scroll if playhead is completely out of view (no buffer)\n    const needsScroll =\n      playheadPx < rulerViewport.scrollLeft ||\n      playheadPx > rulerViewport.scrollLeft + viewportWidth;\n\n    if (needsScroll) {\n      // Center the playhead in the viewport\n      const desiredScroll = Math.max(\n        scrollMin,\n        Math.min(scrollMax, playheadPx - viewportWidth / 2)\n      );\n      rulerViewport.scrollLeft = tracksViewport.scrollLeft = desiredScroll;\n    }\n  }, [\n    playheadPosition,\n    duration,\n    zoomLevel,\n    rulerScrollRef,\n    tracksScrollRef,\n    isScrubbing,\n  ]);\n\n  return {\n    playheadPosition,\n    handlePlayheadMouseDown,\n    handleRulerMouseDown,\n    isDraggingRuler,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 909, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-selection-box.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from \"react\";\n\ninterface UseSelectionBoxProps {\n  containerRef: React.RefObject<HTMLElement>;\n  playheadRef?: React.RefObject<HTMLElement>;\n  onSelectionComplete: (\n    elements: { trackId: string; elementId: string }[]\n  ) => void;\n  isEnabled?: boolean;\n}\n\ninterface SelectionBoxState {\n  startPos: { x: number; y: number };\n  currentPos: { x: number; y: number };\n  isActive: boolean;\n}\n\nexport function useSelectionBox({\n  containerRef,\n  playheadRef,\n  onSelectionComplete,\n  isEnabled = true,\n}: UseSelectionBoxProps) {\n  const [selectionBox, setSelectionBox] = useState<SelectionBoxState | null>(\n    null\n  );\n  const [justFinishedSelecting, setJustFinishedSelecting] = useState(false);\n\n  // Mouse down handler to start selection\n  const handleMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      if (!isEnabled) return;\n\n      // Only start selection on empty space clicks\n      if ((e.target as HTMLElement).closest(\".timeline-element\")) {\n        return;\n      }\n      if (playheadRef?.current?.contains(e.target as Node)) {\n        return;\n      }\n      if ((e.target as HTMLElement).closest(\"[data-track-labels]\")) {\n        return;\n      }\n      // Don't start selection when clicking in the ruler area - this interferes with playhead dragging\n      if ((e.target as HTMLElement).closest(\"[data-ruler-area]\")) {\n        return;\n      }\n\n      setSelectionBox({\n        startPos: { x: e.clientX, y: e.clientY },\n        currentPos: { x: e.clientX, y: e.clientY },\n        isActive: false, // Will become active when mouse moves\n      });\n    },\n    [isEnabled, playheadRef]\n  );\n\n  // Function to select elements within the selection box\n  const selectElementsInBox = useCallback(\n    (startPos: { x: number; y: number }, endPos: { x: number; y: number }) => {\n      if (!containerRef.current) return;\n\n      const container = containerRef.current;\n      const containerRect = container.getBoundingClientRect();\n\n      // Calculate selection rectangle in container coordinates\n      const startX = startPos.x - containerRect.left;\n      const startY = startPos.y - containerRect.top;\n      const endX = endPos.x - containerRect.left;\n      const endY = endPos.y - containerRect.top;\n\n      const selectionRect = {\n        left: Math.min(startX, endX),\n        top: Math.min(startY, endY),\n        right: Math.max(startX, endX),\n        bottom: Math.max(startY, endY),\n      };\n\n      // Find all timeline elements within the selection rectangle\n      const timelineElements = container.querySelectorAll(\".timeline-element\");\n\n      const selectedElements: { trackId: string; elementId: string }[] = [];\n\n      timelineElements.forEach((element) => {\n        const elementRect = element.getBoundingClientRect();\n        // Use absolute coordinates for more accurate intersection detection\n        const elementAbsolute = {\n          left: elementRect.left,\n          top: elementRect.top,\n          right: elementRect.right,\n          bottom: elementRect.bottom,\n        };\n\n        const selectionAbsolute = {\n          left: startPos.x,\n          top: startPos.y,\n          right: endPos.x,\n          bottom: endPos.y,\n        };\n\n        // Normalize selection rectangle (handle dragging in any direction)\n        const normalizedSelection = {\n          left: Math.min(selectionAbsolute.left, selectionAbsolute.right),\n          top: Math.min(selectionAbsolute.top, selectionAbsolute.bottom),\n          right: Math.max(selectionAbsolute.left, selectionAbsolute.right),\n          bottom: Math.max(selectionAbsolute.top, selectionAbsolute.bottom),\n        };\n\n        const elementId = element.getAttribute(\"data-element-id\");\n        const trackId = element.getAttribute(\"data-track-id\");\n\n        // Check if element intersects with selection rectangle (any overlap)\n        // Using absolute coordinates for more precise detection\n        const intersects = !(\n          elementAbsolute.right < normalizedSelection.left ||\n          elementAbsolute.left > normalizedSelection.right ||\n          elementAbsolute.bottom < normalizedSelection.top ||\n          elementAbsolute.top > normalizedSelection.bottom\n        );\n\n        if (intersects && elementId && trackId) {\n          selectedElements.push({ trackId, elementId });\n        }\n      });\n\n      // Always call the callback - with elements or empty array to clear selection\n      console.log(\n        JSON.stringify({ selectElementsInBox: selectedElements.length })\n      );\n      onSelectionComplete(selectedElements);\n    },\n    [containerRef, onSelectionComplete]\n  );\n\n  // Effect to track selection box movement\n  useEffect(() => {\n    if (!selectionBox) return;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const deltaX = Math.abs(e.clientX - selectionBox.startPos.x);\n      const deltaY = Math.abs(e.clientY - selectionBox.startPos.y);\n\n      // Start selection if mouse moved more than 5px\n      const shouldActivate = deltaX > 5 || deltaY > 5;\n\n      const newSelectionBox = {\n        ...selectionBox,\n        currentPos: { x: e.clientX, y: e.clientY },\n        isActive: shouldActivate || selectionBox.isActive,\n      };\n\n      setSelectionBox(newSelectionBox);\n\n      // Real-time visual feedback: update selection as we drag\n      if (newSelectionBox.isActive) {\n        selectElementsInBox(\n          newSelectionBox.startPos,\n          newSelectionBox.currentPos\n        );\n      }\n    };\n\n    const handleMouseUp = () => {\n      console.log(\n        JSON.stringify({ mouseUp: { wasActive: selectionBox?.isActive } })\n      );\n\n      // If we had an active selection, mark that we just finished selecting\n      if (selectionBox?.isActive) {\n        console.log(JSON.stringify({ settingJustFinishedSelecting: true }));\n        setJustFinishedSelecting(true);\n        // Clear the flag after a short delay to allow click events to check it\n        setTimeout(() => {\n          console.log(JSON.stringify({ clearingJustFinishedSelecting: true }));\n          setJustFinishedSelecting(false);\n        }, 50);\n      }\n\n      // Don't call selectElementsInBox again - real-time selection already handled it\n      // Just clean up the selection box visual\n      setSelectionBox(null);\n    };\n\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    window.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      window.removeEventListener(\"mousemove\", handleMouseMove);\n      window.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [selectionBox, selectElementsInBox]);\n\n  useEffect(() => {\n    if (!selectionBox?.isActive) return;\n\n    const previousBodyUserSelect = document.body.style.userSelect;\n    const container = containerRef.current;\n    const previousContainerUserSelect = container?.style.userSelect ?? \"\";\n\n    document.body.style.userSelect = \"none\";\n    if (container) container.style.userSelect = \"none\";\n\n    return () => {\n      document.body.style.userSelect = previousBodyUserSelect;\n      if (container) container.style.userSelect = previousContainerUserSelect;\n    };\n  }, [selectionBox?.isActive, containerRef]);\n\n  return {\n    selectionBox,\n    handleMouseDown,\n    isSelecting: selectionBox?.isActive || false,\n    justFinishedSelecting,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1093, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-frame-cache.ts"],"sourcesContent":["import { useRef, useCallback } from \"react\";\nimport {\n  TimelineTrack,\n  TimelineElement,\n  MediaElement,\n  TextElement,\n} from \"@/types/timeline\";\nimport { MediaFile } from \"@/types/media\";\nimport { TProject } from \"@/types/project\";\n\ninterface CachedFrame {\n  imageData: ImageData;\n  timelineHash: string;\n  timestamp: number;\n}\n\ninterface FrameCacheOptions {\n  maxCacheSize?: number; // Maximum number of cached frames\n  cacheResolution?: number; // Frames per second to cache at\n}\n\n// Shared singleton cache across hook instances (HMR-safe)\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst __frameCacheGlobal: any = globalThis as any;\nconst __sharedFrameCache: Map<number, CachedFrame> =\n  __frameCacheGlobal.__sharedFrameCache ?? new Map<number, CachedFrame>();\n__frameCacheGlobal.__sharedFrameCache = __sharedFrameCache;\n\nexport function useFrameCache(options: FrameCacheOptions = {}) {\n  const { maxCacheSize = 300, cacheResolution = 30 } = options; // 10 seconds at 30fps\n\n  const frameCacheRef = useRef(__sharedFrameCache);\n\n  // Generate a hash of the timeline state that affects rendering\n  const getTimelineHash = useCallback(\n    (\n      time: number,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      sceneId?: string\n    ): string => {\n      // Get elements that are active at this time\n      const activeElements: Array<{\n        id: string;\n        type: string;\n        startTime: number;\n        duration: number;\n        trimStart: number;\n        trimEnd: number;\n        mediaId?: string;\n        // Text-specific properties\n        content?: string;\n        fontSize?: number;\n        fontFamily?: string;\n        color?: string;\n        backgroundColor?: string;\n        x?: number;\n        y?: number;\n        rotation?: number;\n        opacity?: number;\n      }> = [];\n\n      for (const track of tracks) {\n        if (track.muted) continue;\n\n        for (const element of track.elements) {\n          // Check if element has hidden property (some elements might not have it)\n          const isHidden = \"hidden\" in element ? element.hidden : false;\n          if (isHidden) continue;\n\n          const elementStart = element.startTime;\n          const elementEnd =\n            element.startTime +\n            (element.duration - element.trimStart - element.trimEnd);\n\n          if (time >= elementStart && time < elementEnd) {\n            if (element.type === \"media\") {\n              const mediaElement = element as MediaElement;\n              activeElements.push({\n                id: element.id,\n                type: element.type,\n                startTime: element.startTime,\n                duration: element.duration,\n                trimStart: element.trimStart,\n                trimEnd: element.trimEnd,\n                mediaId: mediaElement.mediaId,\n              });\n            } else if (element.type === \"text\") {\n              const textElement = element as TextElement;\n              activeElements.push({\n                id: element.id,\n                type: element.type,\n                startTime: element.startTime,\n                duration: element.duration,\n                trimStart: element.trimStart,\n                trimEnd: element.trimEnd,\n                content: textElement.content,\n                fontSize: textElement.fontSize,\n                fontFamily: textElement.fontFamily,\n                color: textElement.color,\n                backgroundColor: textElement.backgroundColor,\n                x: textElement.x,\n                y: textElement.y,\n                rotation: textElement.rotation,\n                opacity: textElement.opacity,\n              });\n            }\n          }\n        }\n      }\n\n      // Include project settings that affect rendering\n      const projectState = {\n        backgroundColor: activeProject?.backgroundColor,\n        backgroundType: activeProject?.backgroundType,\n        blurIntensity: activeProject?.blurIntensity,\n        canvasSize: activeProject?.canvasSize,\n      };\n\n      const hash = {\n        activeElements,\n        projectState,\n        sceneId,\n        time: Math.floor(time * cacheResolution) / cacheResolution,\n      };\n      return JSON.stringify(hash);\n    },\n    [cacheResolution]\n  );\n\n  // Check if a frame is cached and valid\n  const isFrameCached = useCallback(\n    (\n      time: number,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      sceneId?: string\n    ): boolean => {\n      const frameKey = Math.floor(time * cacheResolution);\n      const cached = frameCacheRef.current.get(frameKey);\n\n      if (!cached) return false;\n\n      const currentHash = getTimelineHash(\n        time,\n        tracks,\n        mediaFiles,\n        activeProject,\n        sceneId\n      );\n      return cached.timelineHash === currentHash;\n    },\n    [getTimelineHash, cacheResolution]\n  );\n\n  // Get cached frame if available and valid\n  const getCachedFrame = useCallback(\n    (\n      time: number,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      sceneId?: string\n    ): ImageData | null => {\n      const frameKey = Math.floor(time * cacheResolution);\n      const cached = frameCacheRef.current.get(frameKey);\n\n      if (!cached) {\n        return null;\n      }\n\n      const currentHash = getTimelineHash(\n        time,\n        tracks,\n        mediaFiles,\n        activeProject,\n        sceneId\n      );\n      console.log(cached.timelineHash === currentHash);\n      if (cached.timelineHash !== currentHash) {\n        // Cache is stale, remove it\n        console.log(\n          \"Cache miss - hash mismatch:\",\n          JSON.stringify({\n            cachedHash: cached.timelineHash.slice(0, 100),\n            currentHash: currentHash.slice(0, 100),\n          })\n        );\n        frameCacheRef.current.delete(frameKey);\n        return null;\n      }\n\n      return cached.imageData;\n    },\n    [getTimelineHash, cacheResolution]\n  );\n\n  // Cache a rendered frame\n  const cacheFrame = useCallback(\n    (\n      time: number,\n      imageData: ImageData,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      sceneId?: string\n    ): void => {\n      const frameKey = Math.floor(time * cacheResolution);\n      const timelineHash = getTimelineHash(\n        time,\n        tracks,\n        mediaFiles,\n        activeProject,\n        sceneId\n      );\n\n      // Enforce cache size limit (LRU eviction)\n      if (frameCacheRef.current.size >= maxCacheSize) {\n        // Remove oldest entries\n        const entries = Array.from(frameCacheRef.current.entries());\n        entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n\n        // Remove oldest 20% of entries\n        const toRemove = Math.floor(entries.length * 0.2);\n        for (let i = 0; i < toRemove; i++) {\n          frameCacheRef.current.delete(entries[i][0]);\n        }\n      }\n\n      frameCacheRef.current.set(frameKey, {\n        imageData,\n        timelineHash,\n        timestamp: Date.now(),\n      });\n    },\n    [getTimelineHash, cacheResolution, maxCacheSize]\n  );\n\n  // Clear cache when timeline changes significantly\n  const invalidateCache = useCallback(() => {\n    frameCacheRef.current.clear();\n  }, []);\n\n  // Get render status for timeline indicator\n  const getRenderStatus = useCallback(\n    (\n      time: number,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      sceneId?: string\n    ): \"cached\" | \"not-cached\" => {\n      return isFrameCached(time, tracks, mediaFiles, activeProject, sceneId)\n        ? \"cached\"\n        : \"not-cached\";\n    },\n    [isFrameCached]\n  );\n\n  // Pre-render frames around current time\n  const preRenderNearbyFrames = useCallback(\n    async (\n      currentTime: number,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      renderFunction: (time: number) => Promise<ImageData>,\n      sceneId?: string,\n      range: number = 3 // seconds\n    ) => {\n      const framesToPreRender: number[] = [];\n\n      // Calculate frames to pre-render (around current time)\n      for (\n        let offset = -range;\n        offset <= range;\n        offset += 1 / cacheResolution\n      ) {\n        const time = currentTime + offset;\n        if (time < 0) continue;\n\n        if (!isFrameCached(time, tracks, mediaFiles, activeProject, sceneId)) {\n          framesToPreRender.push(time);\n        }\n      }\n\n      // Expand to full 1-second buckets to avoid fragmented tiny cache regions\n      const secondsToPreRender = new Set<number>();\n      for (const t of framesToPreRender) {\n        secondsToPreRender.add(Math.floor(t));\n      }\n\n      const expandedTimes: number[] = [];\n      for (const s of secondsToPreRender) {\n        for (let k = 0; k < cacheResolution; k++) {\n          const t = s + k / cacheResolution;\n          if (t < 0) continue;\n          if (!isFrameCached(t, tracks, mediaFiles, activeProject, sceneId)) {\n            expandedTimes.push(t);\n          }\n        }\n      }\n\n      // Sort forward-first near currentTime to improve perceived responsiveness\n      expandedTimes.sort((a, b) => {\n        const da = a >= currentTime ? a - currentTime : currentTime - a + 1e6;\n        const db = b >= currentTime ? b - currentTime : currentTime - b + 1e6;\n        return da - db;\n      });\n\n      // Cap total scheduled renders to avoid jank (e.g., up to 90 frames)\n      const CAP = Math.max(30, Math.min(90, cacheResolution * 3));\n      const toSchedule = expandedTimes.slice(0, CAP);\n\n      // Pre-render during idle time\n      for (const time of toSchedule) {\n        requestIdleCallback(async () => {\n          try {\n            const imageData = await renderFunction(time);\n            cacheFrame(\n              time,\n              imageData,\n              tracks,\n              mediaFiles,\n              activeProject,\n              sceneId\n            );\n          } catch (error) {\n            console.warn(`Pre-render failed for time ${time}:`, error);\n          }\n        });\n      }\n    },\n    [isFrameCached, cacheFrame, cacheResolution]\n  );\n\n  return {\n    isFrameCached,\n    getCachedFrame,\n    cacheFrame,\n    invalidateCache,\n    getRenderStatus,\n    preRenderNearbyFrames,\n    cacheSize: frameCacheRef.current.size,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1305, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-keyboard-shortcuts-help.ts"],"sourcesContent":["\"use client\";\n\nimport { useMemo } from \"react\";\nimport { useKeybindingsStore } from \"@/stores/keybindings-store\";\nimport { Action } from \"@/constants/actions\";\nimport { getPlatformAlternateKey, getPlatformSpecialKey } from \"@/lib/utils\";\n\nexport interface KeyboardShortcut {\n  id: string;\n  keys: string[];\n  description: string;\n  category: string;\n  action: Action;\n  icon?: React.ReactNode;\n}\n\n// Map actions to their descriptions and categories\nconst actionDescriptions: Record<\n  Action,\n  { description: string; category: string }\n> = {\n  \"toggle-play\": { description: \"Play/Pause\", category: \"Playback\" },\n  \"stop-playback\": { description: \"Stop playback\", category: \"Playback\" },\n  \"seek-forward\": {\n    description: \"Seek forward 1 second\",\n    category: \"Playback\",\n  },\n  \"seek-backward\": {\n    description: \"Seek backward 1 second\",\n    category: \"Playback\",\n  },\n  \"frame-step-forward\": {\n    description: \"Frame step forward\",\n    category: \"Navigation\",\n  },\n  \"frame-step-backward\": {\n    description: \"Frame step backward\",\n    category: \"Navigation\",\n  },\n  \"jump-forward\": {\n    description: \"Jump forward 5 seconds\",\n    category: \"Navigation\",\n  },\n  \"jump-backward\": {\n    description: \"Jump backward 5 seconds\",\n    category: \"Navigation\",\n  },\n  \"goto-start\": { description: \"Go to timeline start\", category: \"Navigation\" },\n  \"goto-end\": { description: \"Go to timeline end\", category: \"Navigation\" },\n  \"split-element\": {\n    description: \"Split element at playhead\",\n    category: \"Editing\",\n  },\n  \"delete-selected\": {\n    description: \"Delete selected elements\",\n    category: \"Editing\",\n  },\n  \"select-all\": { description: \"Select all elements\", category: \"Selection\" },\n  \"duplicate-selected\": {\n    description: \"Duplicate selected element\",\n    category: \"Selection\",\n  },\n  \"toggle-snapping\": { description: \"Toggle snapping\", category: \"Editing\" },\n  undo: { description: \"Undo\", category: \"History\" },\n  redo: { description: \"Redo\", category: \"History\" },\n  \"copy-selected\": {\n    description: \"Copy selected elements\",\n    category: \"Editing\",\n  },\n  \"paste-selected\": {\n    description: \"Paste elements at playhead\",\n    category: \"Editing\",\n  },\n};\n\n// Convert key binding format to display format\nconst formatKey = (key: string): string => {\n  return key\n    .replace(\"ctrl\", getPlatformSpecialKey())\n    .replace(\"alt\", getPlatformAlternateKey())\n    .replace(\"shift\", \"Shift\")\n    .replace(\"left\", \"←\")\n    .replace(\"right\", \"→\")\n    .replace(\"up\", \"↑\")\n    .replace(\"down\", \"↓\")\n    .replace(\"space\", \"Space\")\n    .replace(\"home\", \"Home\")\n    .replace(\"enter\", \"Enter\")\n    .replace(\"end\", \"End\")\n    .replace(\"delete\", \"Delete\")\n    .replace(\"backspace\", \"Backspace\")\n    .replace(\"-\", \"+\");\n};\n\nexport const useKeyboardShortcutsHelp = () => {\n  const { keybindings } = useKeybindingsStore();\n\n  const shortcuts = useMemo(() => {\n    const result: KeyboardShortcut[] = [];\n\n    // Group keybindings by action\n    const actionToKeys: Record<Action, string[]> = {} as any;\n\n    Object.entries(keybindings).forEach(([key, action]) => {\n      if (action) {\n        if (!actionToKeys[action]) {\n          actionToKeys[action] = [];\n        }\n        actionToKeys[action].push(formatKey(key));\n      }\n    });\n\n    // Convert to shortcuts format\n    Object.entries(actionToKeys).forEach(([action, keys]) => {\n      const actionInfo = actionDescriptions[action as Action];\n      if (actionInfo) {\n        result.push({\n          id: action,\n          keys,\n          description: actionInfo.description,\n          category: actionInfo.category,\n          action: action as Action,\n        });\n      }\n    });\n\n    // Sort shortcuts by category first, then by description to ensure consistent ordering\n    return result.sort((a, b) => {\n      if (a.category !== b.category) {\n        return a.category.localeCompare(b.category);\n      }\n      return a.description.localeCompare(b.description);\n    });\n  }, [keybindings]);\n\n  return {\n    shortcuts,\n  };\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1443, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-keybindings.ts"],"sourcesContent":["import { useEffect } from \"react\";\nimport { invokeAction } from \"../constants/actions\";\nimport { useKeybindingsStore } from \"@/stores/keybindings-store\";\n\n/**\n * A composable that hooks to the caller component's\n * lifecycle and hooks to the keyboard events to fire\n * the appropriate actions based on keybindings\n */\nexport function useKeybindingsListener() {\n  const { keybindings, getKeybindingString, keybindingsEnabled, isRecording } =\n    useKeybindingsStore();\n\n  useEffect(() => {\n    const handleKeyDown = (ev: KeyboardEvent) => {\n      // Do not check keybinds if the mode is disabled\n      if (!keybindingsEnabled) return;\n      // ignore key events if user is changing keybindings\n      if (isRecording) return;\n\n      const binding = getKeybindingString(ev);\n      if (!binding) return;\n\n      const boundAction = keybindings[binding];\n      if (!boundAction) return;\n\n      const activeElement = document.activeElement;\n      const isTextInput =\n        activeElement &&\n        (activeElement.tagName === \"INPUT\" ||\n          activeElement.tagName === \"TEXTAREA\" ||\n          (activeElement as HTMLElement).isContentEditable);\n\n      if (isTextInput) return;\n\n      ev.preventDefault();\n\n      // Handle actions with default arguments\n      let actionArgs: any;\n\n      if (boundAction === \"seek-forward\") {\n        actionArgs = { seconds: 1 };\n      } else if (boundAction === \"seek-backward\") {\n        actionArgs = { seconds: 1 };\n      } else if (boundAction === \"jump-forward\") {\n        actionArgs = { seconds: 5 };\n      } else if (boundAction === \"jump-backward\") {\n        actionArgs = { seconds: 5 };\n      }\n\n      invokeAction(boundAction, actionArgs, \"keypress\");\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, [keybindings, getKeybindingString, keybindingsEnabled, isRecording]);\n}\n\n/**\n * This composable allows for the UI component to be disabled if the component in question is mounted\n */\nexport function useKeybindingDisabler() {\n  const { disableKeybindings, enableKeybindings } = useKeybindingsStore();\n\n  return {\n    disableKeybindings,\n    enableKeybindings,\n  };\n}\n\n// Export the bindings for backward compatibility\nexport const bindings = {};\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;AAOO,SAAS;IACd,MAAM,EAAE,WAAW,EAAE,mBAAmB,EAAE,kBAAkB,EAAE,WAAW,EAAE,GACzE,CAAA,GAAA,oJAAA,CAAA,sBAAmB,AAAD;IAEpB,CAAA,GAAA,0QAAA,CAAA,YAAS,AAAD,EAAE;QACR,MAAM,gBAAgB,CAAC;YACrB,gDAAgD;YAChD,IAAI,CAAC,oBAAoB;YACzB,oDAAoD;YACpD,IAAI,aAAa;YAEjB,MAAM,UAAU,oBAAoB;YACpC,IAAI,CAAC,SAAS;YAEd,MAAM,cAAc,WAAW,CAAC,QAAQ;YACxC,IAAI,CAAC,aAAa;YAElB,MAAM,gBAAgB,SAAS,aAAa;YAC5C,MAAM,cACJ,iBACA,CAAC,cAAc,OAAO,KAAK,WACzB,cAAc,OAAO,KAAK,cAC1B,AAAC,cAA8B,iBAAiB;YAEpD,IAAI,aAAa;YAEjB,GAAG,cAAc;YAEjB,wCAAwC;YACxC,IAAI;YAEJ,IAAI,gBAAgB,gBAAgB;gBAClC,aAAa;oBAAE,SAAS;gBAAE;YAC5B,OAAO,IAAI,gBAAgB,iBAAiB;gBAC1C,aAAa;oBAAE,SAAS;gBAAE;YAC5B,OAAO,IAAI,gBAAgB,gBAAgB;gBACzC,aAAa;oBAAE,SAAS;gBAAE;YAC5B,OAAO,IAAI,gBAAgB,iBAAiB;gBAC1C,aAAa;oBAAE,SAAS;gBAAE;YAC5B;YAEA,CAAA,GAAA,0IAAA,CAAA,eAAY,AAAD,EAAE,aAAa,YAAY;QACxC;QAEA,SAAS,gBAAgB,CAAC,WAAW;QAErC,OAAO;YACL,SAAS,mBAAmB,CAAC,WAAW;QAC1C;IACF,GAAG;QAAC;QAAa;QAAqB;QAAoB;KAAY;AACxE;AAKO,SAAS;IACd,MAAM,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,GAAG,CAAA,GAAA,oJAAA,CAAA,sBAAmB,AAAD;IAEpE,OAAO;QACL;QACA;IACF;AACF;AAGO,MAAM,WAAW,CAAC","debugId":null}},
    {"offset": {"line": 1514, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-editor-actions.ts"],"sourcesContent":["\"use client\";\n\nimport { useEffect } from \"react\";\nimport { useActionHandler } from \"@/constants/actions\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { usePlaybackStore } from \"@/stores/playback-store\";\nimport { DEFAULT_FPS, useProjectStore } from \"@/stores/project-store\";\nimport { toast } from \"sonner\";\n\nexport function useEditorActions() {\n  const {\n    tracks,\n    selectedElements,\n    clearSelectedElements,\n    setSelectedElements,\n    deleteSelected,\n    splitSelected,\n    addElementToTrack,\n    snappingEnabled,\n    toggleSnapping,\n    undo,\n    redo,\n  } = useTimelineStore();\n\n  const { currentTime, duration, isPlaying, toggle, seek } = usePlaybackStore();\n  const { activeProject } = useProjectStore();\n\n  // Playback actions\n  useActionHandler(\n    \"toggle-play\",\n    () => {\n      toggle();\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"stop-playback\",\n    () => {\n      if (isPlaying) {\n        toggle();\n      }\n      seek(0);\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"seek-forward\",\n    (args) => {\n      const seconds = args?.seconds ?? 1;\n      seek(Math.min(duration, currentTime + seconds));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"seek-backward\",\n    (args) => {\n      const seconds = args?.seconds ?? 1;\n      seek(Math.max(0, currentTime - seconds));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"frame-step-forward\",\n    () => {\n      const projectFps = activeProject?.fps || DEFAULT_FPS;\n      seek(Math.min(duration, currentTime + 1 / projectFps));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"frame-step-backward\",\n    () => {\n      const projectFps = activeProject?.fps || DEFAULT_FPS;\n      seek(Math.max(0, currentTime - 1 / projectFps));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"jump-forward\",\n    (args) => {\n      const seconds = args?.seconds ?? 5;\n      seek(Math.min(duration, currentTime + seconds));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"jump-backward\",\n    (args) => {\n      const seconds = args?.seconds ?? 5;\n      seek(Math.max(0, currentTime - seconds));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"goto-start\",\n    () => {\n      seek(0);\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"goto-end\",\n    () => {\n      seek(duration);\n    },\n    undefined\n  );\n\n  // Timeline editing actions\n  useActionHandler(\n    \"split-element\",\n    () => {\n      if (selectedElements.length !== 1) {\n        toast.error(\"Select exactly one element to split\");\n        return;\n      }\n\n      const { trackId, elementId } = selectedElements[0];\n      const track = tracks.find((t: any) => t.id === trackId);\n      const element = track?.elements.find((el: any) => el.id === elementId);\n\n      if (element) {\n        const effectiveStart = element.startTime;\n        const effectiveEnd =\n          element.startTime +\n          (element.duration - element.trimStart - element.trimEnd);\n\n        if (currentTime > effectiveStart && currentTime < effectiveEnd) {\n          splitSelected(currentTime, trackId, elementId);\n        } else {\n          toast.error(\"Playhead must be within selected element\");\n        }\n      }\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"delete-selected\",\n    () => {\n      if (selectedElements.length === 0) {\n        return;\n      }\n      deleteSelected();\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"select-all\",\n    () => {\n      const allElements = tracks.flatMap((track: any) =>\n        track.elements.map((element: any) => ({\n          trackId: track.id,\n          elementId: element.id,\n        }))\n      );\n      setSelectedElements(allElements);\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"duplicate-selected\",\n    () => {\n      if (selectedElements.length !== 1) {\n        toast.error(\"Select exactly one element to duplicate\");\n        return;\n      }\n\n      const { trackId, elementId } = selectedElements[0];\n      const track = tracks.find((t: any) => t.id === trackId);\n      const element = track?.elements.find((el: any) => el.id === elementId);\n\n      if (element) {\n        const newStartTime =\n          element.startTime +\n          (element.duration - element.trimStart - element.trimEnd) +\n          0.1;\n        const { id, ...elementWithoutId } = element;\n\n        addElementToTrack(trackId, {\n          ...elementWithoutId,\n          startTime: newStartTime,\n        });\n      }\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"copy-selected\",\n    () => {\n      if (selectedElements.length === 0) return;\n      useTimelineStore.getState().copySelected();\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"paste-selected\",\n    () => {\n      useTimelineStore.getState().pasteAtTime(currentTime);\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"toggle-snapping\",\n    () => {\n      toggleSnapping();\n    },\n    undefined\n  );\n\n  // History actions\n  useActionHandler(\n    \"undo\",\n    () => {\n      undo();\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"redo\",\n    () => {\n      redo();\n    },\n    undefined\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1643, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-playback-controls.ts"],"sourcesContent":["import { useEffect, useCallback } from \"react\";\nimport { usePlaybackStore } from \"@/stores/playback-store\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { toast } from \"sonner\";\n\nexport const usePlaybackControls = () => {\n  const { isPlaying, currentTime, play, pause, seek } = usePlaybackStore();\n\n  const {\n    selectedElements,\n    tracks,\n    splitSelected,\n    splitAndKeepLeft,\n    splitAndKeepRight,\n    separateAudio,\n  } = useTimelineStore();\n\n  const handleSplitSelectedElement = useCallback(() => {\n    if (selectedElements.length !== 1) {\n      toast.error(\"Select exactly one element to split\");\n      return;\n    }\n\n    const { trackId, elementId } = selectedElements[0];\n    const track = tracks.find((t) => t.id === trackId);\n    const element = track?.elements.find((e) => e.id === elementId);\n\n    if (!element) return;\n\n    const effectiveStart = element.startTime;\n    const effectiveEnd =\n      element.startTime +\n      (element.duration - element.trimStart - element.trimEnd);\n\n    if (currentTime <= effectiveStart || currentTime >= effectiveEnd) {\n      toast.error(\"Playhead must be within selected element\");\n      return;\n    }\n\n    splitSelected(currentTime, trackId, elementId);\n  }, [selectedElements, tracks, currentTime, splitSelected]);\n\n  const handleSplitAndKeepLeftCallback = useCallback(() => {\n    if (selectedElements.length !== 1) {\n      toast.error(\"Select exactly one element\");\n      return;\n    }\n\n    const { trackId, elementId } = selectedElements[0];\n    const track = tracks.find((t) => t.id === trackId);\n    const element = track?.elements.find((e) => e.id === elementId);\n\n    if (!element) return;\n\n    const effectiveStart = element.startTime;\n    const effectiveEnd =\n      element.startTime +\n      (element.duration - element.trimStart - element.trimEnd);\n\n    if (currentTime <= effectiveStart || currentTime >= effectiveEnd) {\n      toast.error(\"Playhead must be within selected element\");\n      return;\n    }\n\n    splitAndKeepLeft(trackId, elementId, currentTime);\n  }, [selectedElements, tracks, currentTime, splitAndKeepLeft]);\n\n  const handleSplitAndKeepRightCallback = useCallback(() => {\n    if (selectedElements.length !== 1) {\n      toast.error(\"Select exactly one element\");\n      return;\n    }\n\n    const { trackId, elementId } = selectedElements[0];\n    const track = tracks.find((t) => t.id === trackId);\n    const element = track?.elements.find((e) => e.id === elementId);\n\n    if (!element) return;\n\n    const effectiveStart = element.startTime;\n    const effectiveEnd =\n      element.startTime +\n      (element.duration - element.trimStart - element.trimEnd);\n\n    if (currentTime <= effectiveStart || currentTime >= effectiveEnd) {\n      toast.error(\"Playhead must be within selected element\");\n      return;\n    }\n\n    splitAndKeepRight(trackId, elementId, currentTime);\n  }, [selectedElements, tracks, currentTime, splitAndKeepRight]);\n\n  const handleSeparateAudioCallback = useCallback(() => {\n    if (selectedElements.length !== 1) {\n      toast.error(\"Select exactly one media element to separate audio\");\n      return;\n    }\n\n    const { trackId, elementId } = selectedElements[0];\n    const track = tracks.find((t) => t.id === trackId);\n\n    if (!track || track.type !== \"media\") {\n      toast.error(\"Select a media element to separate audio\");\n      return;\n    }\n\n    separateAudio(trackId, elementId);\n  }, [selectedElements, tracks, separateAudio]);\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1745, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/mediabunny-utils.ts"],"sourcesContent":["import { FFmpeg } from \"@ffmpeg/ffmpeg\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { useMediaStore } from \"@/stores/media-store\";\nimport { Input, ALL_FORMATS, BlobSource, VideoSampleSink } from \"mediabunny\";\n\nlet ffmpeg: FFmpeg | null = null;\n\nexport const initFFmpeg = async (): Promise<FFmpeg> => {\n  if (ffmpeg) return ffmpeg;\n\n  ffmpeg = new FFmpeg();\n  await ffmpeg.load(); // Use default config\n\n  return ffmpeg;\n};\n\nexport async function generateThumbnail({\n  videoFile,\n  timeInSeconds,\n}: {\n  videoFile: File;\n  timeInSeconds: number;\n}): Promise<string> {\n  const input = new Input({\n    source: new BlobSource(videoFile),\n    formats: ALL_FORMATS,\n  });\n\n  const videoTrack = await input.getPrimaryVideoTrack();\n  if (!videoTrack) {\n    throw new Error(\"No video track found in the file\");\n  }\n\n  // Check if we can decode this video\n  const canDecode = await videoTrack.canDecode();\n  if (!canDecode) {\n    throw new Error(\"Video codec not supported for decoding\");\n  }\n\n  const sink = new VideoSampleSink(videoTrack);\n\n  const frame = await sink.getSample(timeInSeconds);\n\n  if (!frame) {\n    throw new Error(\"Could not get frame at specified time\");\n  }\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 320;\n  canvas.height = 240;\n  const ctx = canvas.getContext(\"2d\");\n\n  if (!ctx) {\n    throw new Error(\"Could not get canvas context\");\n  }\n\n  frame.draw(ctx, 0, 0, 320, 240);\n\n  return new Promise((resolve, reject) => {\n    canvas.toBlob(\n      (blob) => {\n        if (blob) {\n          resolve(URL.createObjectURL(blob));\n        } else {\n          reject(new Error(\"Failed to create thumbnail blob\"));\n        }\n      },\n      \"image/jpeg\",\n      0.8\n    );\n  });\n}\n\nexport async function getVideoInfo({\n  videoFile,\n}: {\n  videoFile: File;\n}): Promise<{\n  duration: number;\n  width: number;\n  height: number;\n  fps: number;\n}> {\n  const input = new Input({\n    source: new BlobSource(videoFile),\n    formats: ALL_FORMATS,\n  });\n\n  const duration = await input.computeDuration();\n  const videoTrack = await input.getPrimaryVideoTrack();\n\n  if (!videoTrack) {\n    throw new Error(\"No video track found in the file\");\n  }\n\n  // Get frame rate from packet statistics\n  const packetStats = await videoTrack.computePacketStats(100);\n  const fps = packetStats.averagePacketRate;\n\n  return {\n    duration,\n    width: videoTrack.displayWidth,\n    height: videoTrack.displayHeight,\n    fps,\n  };\n}\n\n// Audio mixing for timeline - keeping FFmpeg for now due to complexity\n// TODO: Replace with Mediabunny audio processing when implementing canvas preview\nexport const extractTimelineAudio = async (\n  onProgress?: (progress: number) => void\n): Promise<Blob> => {\n  // Create fresh FFmpeg instance for this operation\n  const ffmpeg = new FFmpeg();\n\n  try {\n    await ffmpeg.load();\n  } catch (error) {\n    console.error(\"Failed to load fresh FFmpeg instance:\", error);\n    throw new Error(\"Unable to initialize audio processing. Please try again.\");\n  }\n\n  const timeline = useTimelineStore.getState();\n  const mediaStore = useMediaStore.getState();\n\n  const tracks = timeline.tracks;\n  const totalDuration = timeline.getTotalDuration();\n\n  if (totalDuration === 0) {\n    const emptyAudioData = new ArrayBuffer(44);\n    return new Blob([emptyAudioData], { type: \"audio/wav\" });\n  }\n\n  if (onProgress) {\n    ffmpeg.on(\"progress\", ({ progress }) => {\n      onProgress(progress * 100);\n    });\n  }\n\n  const audioElements: Array<{\n    file: File;\n    startTime: number;\n    duration: number;\n    trimStart: number;\n    trimEnd: number;\n    trackMuted: boolean;\n  }> = [];\n\n  for (const track of tracks) {\n    if (track.muted) continue;\n\n    for (const element of track.elements) {\n      if (element.type === \"media\") {\n        const mediaFile = mediaStore.mediaFiles.find(\n          (m) => m.id === element.mediaId\n        );\n        if (!mediaFile) continue;\n\n        if (mediaFile.type === \"video\" || mediaFile.type === \"audio\") {\n          audioElements.push({\n            file: mediaFile.file,\n            startTime: element.startTime,\n            duration: element.duration,\n            trimStart: element.trimStart,\n            trimEnd: element.trimEnd,\n            trackMuted: track.muted || false,\n          });\n        }\n      }\n    }\n  }\n\n  if (audioElements.length === 0) {\n    // Return silent audio if no audio elements\n    const silentDuration = Math.max(1, totalDuration); // At least 1 second\n    try {\n      const silentAudio = await generateSilentAudio(silentDuration);\n      return silentAudio;\n    } catch (error) {\n      console.error(\"Failed to generate silent audio:\", error);\n      throw new Error(\"Unable to generate audio for empty timeline.\");\n    }\n  }\n\n  // Create a complex filter to mix all audio sources\n  const inputFiles: string[] = [];\n  const filterInputs: string[] = [];\n\n  try {\n    for (let i = 0; i < audioElements.length; i++) {\n      const element = audioElements[i];\n      const inputName = `input_${i}.${element.file.name.split(\".\").pop()}`;\n      inputFiles.push(inputName);\n\n      try {\n        await ffmpeg.writeFile(\n          inputName,\n          new Uint8Array(await element.file.arrayBuffer())\n        );\n      } catch (error) {\n        console.error(`Failed to write file ${element.file.name}:`, error);\n        throw new Error(\n          `Unable to process file: ${element.file.name}. The file may be corrupted or in an unsupported format.`\n        );\n      }\n\n      const actualStart = element.trimStart;\n      const actualDuration =\n        element.duration - element.trimStart - element.trimEnd;\n\n      const filterName = `audio_${i}`;\n      filterInputs.push(\n        `[${i}:a]atrim=start=${actualStart}:duration=${actualDuration},asetpts=PTS-STARTPTS,adelay=${element.startTime * 1000}|${element.startTime * 1000}[${filterName}]`\n      );\n    }\n\n    const mixFilter =\n      audioElements.length === 1\n        ? `[audio_0]aresample=44100,aformat=sample_fmts=s16:channel_layouts=stereo[out]`\n        : `${filterInputs.map((_, i) => `[audio_${i}]`).join(\"\")}amix=inputs=${audioElements.length}:duration=longest:dropout_transition=2,aresample=44100,aformat=sample_fmts=s16:channel_layouts=stereo[out]`;\n\n    const complexFilter = [...filterInputs, mixFilter].join(\";\");\n    const outputName = \"timeline_audio.wav\";\n\n    const ffmpegArgs = [\n      ...inputFiles.flatMap((name) => [\"-i\", name]),\n      \"-filter_complex\",\n      complexFilter,\n      \"-map\",\n      \"[out]\",\n      \"-t\",\n      totalDuration.toString(),\n      \"-c:a\",\n      \"pcm_s16le\",\n      \"-ar\",\n      \"44100\",\n      outputName,\n    ];\n\n    try {\n      await ffmpeg.exec(ffmpegArgs);\n    } catch (error) {\n      console.error(\"FFmpeg execution failed:\", error);\n      throw new Error(\n        \"Audio processing failed. Some audio files may be corrupted or incompatible.\"\n      );\n    }\n\n    const data = await ffmpeg.readFile(outputName);\n    const blob = new Blob([data], { type: \"audio/wav\" });\n\n    return blob;\n  } catch (error) {\n    for (const inputFile of inputFiles) {\n      try {\n        await ffmpeg.deleteFile(inputFile);\n      } catch (cleanupError) {\n        console.warn(`Failed to cleanup file ${inputFile}:`, cleanupError);\n      }\n    }\n    try {\n      await ffmpeg.deleteFile(\"timeline_audio.wav\");\n    } catch (cleanupError) {\n      console.warn(\"Failed to cleanup output file:\", cleanupError);\n    }\n\n    throw error;\n  } finally {\n    for (const inputFile of inputFiles) {\n      try {\n        await ffmpeg.deleteFile(inputFile);\n      } catch (cleanupError) {}\n    }\n    try {\n      await ffmpeg.deleteFile(\"timeline_audio.wav\");\n    } catch (cleanupError) {}\n  }\n};\n\nconst generateSilentAudio = async (durationSeconds: number): Promise<Blob> => {\n  const ffmpeg = await initFFmpeg();\n  const outputName = \"silent.wav\";\n\n  try {\n    await ffmpeg.exec([\n      \"-f\",\n      \"lavfi\",\n      \"-i\",\n      `anullsrc=channel_layout=stereo:sample_rate=44100`,\n      \"-t\",\n      durationSeconds.toString(),\n      \"-c:a\",\n      \"pcm_s16le\",\n      outputName,\n    ]);\n\n    const data = await ffmpeg.readFile(outputName);\n    const blob = new Blob([data], { type: \"audio/wav\" });\n\n    return blob;\n  } catch (error) {\n    console.error(\"Failed to generate silent audio:\", error);\n    throw error;\n  } finally {\n    try {\n      await ffmpeg.deleteFile(outputName);\n    } catch (cleanupError) {\n      // Silent cleanup\n    }\n  }\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2000, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/media-processing.ts"],"sourcesContent":["import { toast } from \"sonner\";\nimport {\n  getFileType,\n  getMediaDuration,\n  getImageDimensions,\n} from \"@/stores/media-store\";\nimport { MediaFile } from \"@/types/media\";\nimport { generateThumbnail, getVideoInfo } from \"./mediabunny-utils\";\n\nexport interface ProcessedMediaItem extends Omit<MediaFile, \"id\"> {}\n\nexport async function processMediaFiles(\n  files: FileList | File[],\n  onProgress?: (progress: number) => void\n): Promise<ProcessedMediaItem[]> {\n  const fileArray = Array.from(files);\n  const processedItems: ProcessedMediaItem[] = [];\n\n  const total = fileArray.length;\n  let completed = 0;\n\n  for (const file of fileArray) {\n    const fileType = getFileType(file);\n\n    if (!fileType) {\n      toast.error(`Unsupported file type: ${file.name}`);\n      continue;\n    }\n\n    const url = URL.createObjectURL(file);\n    let thumbnailUrl: string | undefined;\n    let duration: number | undefined;\n    let width: number | undefined;\n    let height: number | undefined;\n    let fps: number | undefined;\n\n    try {\n      if (fileType === \"image\") {\n        const dimensions = await getImageDimensions(file);\n        width = dimensions.width;\n        height = dimensions.height;\n      } else if (fileType === \"video\") {\n        try {\n          const videoInfo = await getVideoInfo({ videoFile: file });\n          duration = videoInfo.duration;\n          width = videoInfo.width;\n          height = videoInfo.height;\n          fps = videoInfo.fps;\n\n          thumbnailUrl = await generateThumbnail({\n            videoFile: file,\n            timeInSeconds: 1,\n          });\n        } catch (error) {\n          console.warn(\"Video processing failed\", error);\n        }\n      } else if (fileType === \"audio\") {\n        // For audio, we don't set width/height/fps (they'll be undefined)\n        duration = await getMediaDuration(file);\n      }\n\n      processedItems.push({\n        name: file.name,\n        type: fileType,\n        file,\n        url,\n        thumbnailUrl,\n        duration,\n        width,\n        height,\n        fps,\n      });\n\n      await new Promise((resolve) => setTimeout(resolve, 0));\n\n      completed += 1;\n      if (onProgress) {\n        const percent = Math.round((completed / total) * 100);\n        onProgress(percent);\n      }\n    } catch (error) {\n      console.error(\"Error processing file:\", file.name, error);\n      toast.error(`Failed to process ${file.name}`);\n      URL.revokeObjectURL(url); // Clean up on error\n    }\n  }\n\n  return processedItems;\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AAMA;;;;AAIO,eAAe,kBACpB,KAAwB,EACxB,UAAuC;IAEvC,MAAM,YAAY,MAAM,IAAI,CAAC;IAC7B,MAAM,iBAAuC,EAAE;IAE/C,MAAM,QAAQ,UAAU,MAAM;IAC9B,IAAI,YAAY;IAEhB,KAAK,MAAM,QAAQ,UAAW;QAC5B,MAAM,WAAW,CAAA,GAAA,8IAAA,CAAA,cAAW,AAAD,EAAE;QAE7B,IAAI,CAAC,UAAU;YACb,8MAAA,CAAA,QAAK,CAAC,KAAK,CAAC,CAAC,uBAAuB,EAAE,KAAK,IAAI,EAAE;YACjD;QACF;QAEA,MAAM,MAAM,IAAI,eAAe,CAAC;QAChC,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QAEJ,IAAI;YACF,IAAI,aAAa,SAAS;gBACxB,MAAM,aAAa,MAAM,CAAA,GAAA,8IAAA,CAAA,qBAAkB,AAAD,EAAE;gBAC5C,QAAQ,WAAW,KAAK;gBACxB,SAAS,WAAW,MAAM;YAC5B,OAAO,IAAI,aAAa,SAAS;gBAC/B,IAAI;oBACF,MAAM,YAAY,MAAM,CAAA,GAAA,gJAAA,CAAA,eAAY,AAAD,EAAE;wBAAE,WAAW;oBAAK;oBACvD,WAAW,UAAU,QAAQ;oBAC7B,QAAQ,UAAU,KAAK;oBACvB,SAAS,UAAU,MAAM;oBACzB,MAAM,UAAU,GAAG;oBAEnB,eAAe,MAAM,CAAA,GAAA,gJAAA,CAAA,oBAAiB,AAAD,EAAE;wBACrC,WAAW;wBACX,eAAe;oBACjB;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,IAAI,CAAC,2BAA2B;gBAC1C;YACF,OAAO,IAAI,aAAa,SAAS;gBAC/B,kEAAkE;gBAClE,WAAW,MAAM,CAAA,GAAA,8IAAA,CAAA,mBAAgB,AAAD,EAAE;YACpC;YAEA,eAAe,IAAI,CAAC;gBAClB,MAAM,KAAK,IAAI;gBACf,MAAM;gBACN;gBACA;gBACA;gBACA;gBACA;gBACA;gBACA;YACF;YAEA,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS;YAEnD,aAAa;YACb,IAAI,YAAY;gBACd,MAAM,UAAU,KAAK,KAAK,CAAC,AAAC,YAAY,QAAS;gBACjD,WAAW;YACb;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,0BAA0B,KAAK,IAAI,EAAE;YACnD,8MAAA,CAAA,QAAK,CAAC,KAAK,CAAC,CAAC,kBAAkB,EAAE,KAAK,IAAI,EAAE;YAC5C,IAAI,eAAe,CAAC,MAAM,oBAAoB;QAChD;IACF;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 2080, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/iconify-api.ts"],"sourcesContent":["\nexport const ICONIFY_HOSTS = [\n  \"https://api.iconify.design\",\n  \"https://api.simplesvg.com\",\n  \"https://api.unisvg.com\",\n];\n\nlet currentHost = ICONIFY_HOSTS[0];\n\nasync function fetchWithFallback(path: string): Promise<Response> {\n  for (const host of ICONIFY_HOSTS) {\n    try {\n      const response = await fetch(`${host}${path}`, {\n        signal: AbortSignal.timeout(2000),\n      });\n      if (response.ok) {\n        currentHost = host;\n        return response;\n      }\n    } catch (error) {\n      console.warn(`Failed to fetch from ${host}:`, error);\n    }\n  }\n  throw new Error(\"All API hosts failed\");\n}\n\nexport interface IconSet {\n  prefix: string;\n  name: string;\n  total: number;\n  author?: {\n    name: string;\n    url?: string;\n  };\n  license?: {\n    title: string;\n    spdx?: string;\n    url?: string;\n  };\n  samples?: string[];\n  category?: string;\n  palette?: boolean;\n}\n\nexport interface IconSearchResult {\n  icons: string[];\n  total: number;\n  limit: number;\n  start: number;\n  collections: Record<string, IconSet>;\n}\n\nexport interface CollectionInfo {\n  prefix: string;\n  total: number;\n  title?: string;\n  uncategorized?: string[];\n  categories?: Record<string, string[]>;\n  hidden?: string[];\n  aliases?: Record<string, string>;\n}\n\nexport async function getCollections(\n  category?: string\n): Promise<Record<string, IconSet>> {\n  try {\n    const response = await fetchWithFallback(\"/collections?pretty=1\");\n    const data = (await response.json()) as Record<string, IconSet>;\n\n    if (category) {\n      const filtered = Object.fromEntries(\n        Object.entries(data).filter(\n          ([_key, info]) => info.category === category\n        )\n      ) as Record<string, IconSet>;\n      return filtered;\n    }\n\n    return data;\n  } catch (error) {\n    console.error(\"Failed to fetch collections:\", error);\n    return {};\n  }\n}\n\nexport async function getCollection(\n  prefix: string\n): Promise<CollectionInfo | null> {\n  try {\n    const response = await fetchWithFallback(\n      `/collection?prefix=${prefix}&pretty=1`\n    );\n    return await response.json();\n  } catch (error) {\n    console.error(`Failed to fetch collection ${prefix}:`, error);\n    return null;\n  }\n}\n\nexport async function searchIcons(\n  query: string,\n  limit: number = 64,\n  prefixes?: string[],\n  category?: string\n): Promise<IconSearchResult> {\n  const params = new URLSearchParams({\n    query,\n    limit: limit.toString(),\n    pretty: \"1\",\n  });\n\n  if (prefixes?.length) {\n    params.append(\"prefixes\", prefixes.join(\",\"));\n  }\n\n  if (category) {\n    params.append(\"category\", category);\n  }\n\n  try {\n    const response = await fetchWithFallback(`/search?${params}`);\n    return await response.json();\n  } catch (error) {\n    console.error(\"Failed to search icons:\", error);\n    return {\n      icons: [],\n      total: 0,\n      limit,\n      start: 0,\n      collections: {},\n    };\n  }\n}\n\nexport function buildIconSvgUrl(\n  host: string,\n  iconName: string,\n  params?: {\n    color?: string;\n    width?: number;\n    height?: number;\n    flip?: \"horizontal\" | \"vertical\" | \"horizontal,vertical\";\n    rotate?: number | string;\n  }\n): string {\n  const [prefix, name] = iconName.includes(\":\")\n    ? iconName.split(\":\")\n    : [\"\", iconName];\n\n  if (!prefix || !name) {\n    throw new Error('Invalid icon name format. Expected \"prefix:name\"');\n  }\n\n  const urlParams = new URLSearchParams();\n\n  if (params?.color) {\n    urlParams.append(\"color\", params.color.replace(\"#\", \"%23\"));\n  }\n\n  if (params?.width) {\n    urlParams.append(\"width\", params.width.toString());\n  }\n\n  if (params?.height) {\n    urlParams.append(\"height\", params.height.toString());\n  }\n\n  if (params?.flip) {\n    urlParams.append(\"flip\", params.flip);\n  }\n\n  if (params?.rotate) {\n    urlParams.append(\"rotate\", params.rotate.toString());\n  }\n\n  const queryString = urlParams.toString();\n  return `${host}/${prefix}/${name}.svg${queryString ? \"?\" + queryString : \"\"}`;\n}\n\nexport function getIconSvgUrl(\n  iconName: string,\n  params?: Parameters<typeof buildIconSvgUrl>[2]\n): string {\n  return buildIconSvgUrl(currentHost, iconName, params);\n}\n\nexport async function downloadSvgAsText(\n  iconName: string,\n  params?: Parameters<typeof getIconSvgUrl>[1]\n): Promise<string> {\n  const url = getIconSvgUrl(iconName, params);\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`Failed to download SVG: ${response.statusText}`);\n  }\n  return await response.text();\n}\n\nexport function svgToFile(svgText: string, fileName: string): File {\n  const blob = new Blob([svgText], { type: \"image/svg+xml\" });\n  return new File([blob], fileName, { type: \"image/svg+xml\" });\n}\n\nexport const POPULAR_COLLECTIONS = {\n  general: [\n    { prefix: \"mdi\", name: \"Material Design Icons\" },\n    { prefix: \"ic\", name: \"Google Material Icons\" },\n    { prefix: \"ph\", name: \"Phosphor\" },\n    { prefix: \"heroicons\", name: \"Heroicons\" },\n    { prefix: \"lucide\", name: \"Lucide\" },\n    { prefix: \"tabler\", name: \"Tabler Icons\" },\n    { prefix: \"fe\", name: \"Feather Icons\" },\n    { prefix: \"bi\", name: \"Bootstrap Icons\" },\n  ],\n  brands: [\n    { prefix: \"simple-icons\", name: \"Simple Icons\" },\n    { prefix: \"logos\", name: \"SVG Logos\" },\n    { prefix: \"skill-icons\", name: \"Skill Icons\" },\n    { prefix: \"devicon\", name: \"Devicon\" },\n    { prefix: \"fa-brands\", name: \"Font Awesome Brands\" },\n  ],\n  emoji: [\n    { prefix: \"noto\", name: \"Noto Emoji\" },\n    { prefix: \"twemoji\", name: \"Twemoji\" },\n    { prefix: \"fluent-emoji\", name: \"Fluent Emoji\" },\n    { prefix: \"fluent-emoji-flat\", name: \"Fluent Emoji Flat\" },\n    { prefix: \"emojione\", name: \"EmojiOne\" },\n    { prefix: \"openmoji\", name: \"OpenMoji\" },\n  ],\n};\n\nexport function getCategoriesFromCollections(\n  collections: Record<string, IconSet>\n): string[] {\n  const categories = new Set<string>();\n  Object.values(collections).forEach((collection) => {\n    if (collection.category) {\n      categories.add(collection.category);\n    }\n  });\n  return Array.from(categories).sort();\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2310, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/zk-encryption.ts"],"sourcesContent":["/**\r\n * True zero-knowledge encryption utilities\r\n * Keys are generated randomly in the browser and never derived from server secrets\r\n */\r\n\r\nexport interface ZeroKnowledgeEncryptionResult {\r\n  encryptedData: ArrayBuffer;\r\n  key: ArrayBuffer;\r\n  iv: ArrayBuffer;\r\n}\r\n\r\n/**\r\n * Encrypt data with a randomly generated key (true zero-knowledge)\r\n */\r\nexport async function encryptWithRandomKey(\r\n  data: ArrayBuffer\r\n): Promise<ZeroKnowledgeEncryptionResult> {\r\n  // Generate a truly random 256-bit key\r\n  const key = crypto.getRandomValues(new Uint8Array(32));\r\n\r\n  // Generate random IV\r\n  const iv = crypto.getRandomValues(new Uint8Array(12));\r\n\r\n  // Import the key for encryption\r\n  const cryptoKey = await crypto.subtle.importKey(\r\n    \"raw\",\r\n    key,\r\n    { name: \"AES-GCM\" },\r\n    false,\r\n    [\"encrypt\"]\r\n  );\r\n\r\n  // Encrypt the data\r\n  const encryptedResult = await crypto.subtle.encrypt(\r\n    { name: \"AES-GCM\", iv },\r\n    cryptoKey,\r\n    data\r\n  );\r\n\r\n  // For AES-GCM, we need to append the authentication tag\r\n  // The encrypted result contains both ciphertext and tag\r\n  return {\r\n    encryptedData: encryptedResult,\r\n    key: key.buffer,\r\n    iv: iv.buffer,\r\n  };\r\n}\r\n\r\n/**\r\n * Convert ArrayBuffer to base64 string for transmission\r\n */\r\nexport function arrayBufferToBase64(buffer: ArrayBuffer): string {\r\n  const bytes = new Uint8Array(buffer);\r\n  let binary = \"\";\r\n  for (let i = 0; i < bytes.byteLength; i++) {\r\n    binary += String.fromCharCode(bytes[i]);\r\n  }\r\n  return btoa(binary);\r\n}\r\n\r\n/**\r\n * Convert base64 string back to ArrayBuffer\r\n */\r\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\r\n  const binary = atob(base64);\r\n  const bytes = new Uint8Array(binary.length);\r\n  for (let i = 0; i < binary.length; i++) {\r\n    bytes[i] = binary.charCodeAt(i);\r\n  }\r\n  return bytes.buffer;\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;AAWM,eAAe,qBACpB,IAAiB;IAEjB,sCAAsC;IACtC,MAAM,MAAM,OAAO,eAAe,CAAC,IAAI,WAAW;IAElD,qBAAqB;IACrB,MAAM,KAAK,OAAO,eAAe,CAAC,IAAI,WAAW;IAEjD,gCAAgC;IAChC,MAAM,YAAY,MAAM,OAAO,MAAM,CAAC,SAAS,CAC7C,OACA,KACA;QAAE,MAAM;IAAU,GAClB,OACA;QAAC;KAAU;IAGb,mBAAmB;IACnB,MAAM,kBAAkB,MAAM,OAAO,MAAM,CAAC,OAAO,CACjD;QAAE,MAAM;QAAW;IAAG,GACtB,WACA;IAGF,wDAAwD;IACxD,wDAAwD;IACxD,OAAO;QACL,eAAe;QACf,KAAK,IAAI,MAAM;QACf,IAAI,GAAG,MAAM;IACf;AACF;AAKO,SAAS,oBAAoB,MAAmB;IACrD,MAAM,QAAQ,IAAI,WAAW;IAC7B,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,UAAU,EAAE,IAAK;QACzC,UAAU,OAAO,YAAY,CAAC,KAAK,CAAC,EAAE;IACxC;IACA,OAAO,KAAK;AACd;AAKO,SAAS,oBAAoB,MAAc;IAChD,MAAM,SAAS,KAAK;IACpB,MAAM,QAAQ,IAAI,WAAW,OAAO,MAAM;IAC1C,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAK;QACtC,KAAK,CAAC,EAAE,GAAG,OAAO,UAAU,CAAC;IAC/B;IACA,OAAO,MAAM,MAAM;AACrB","debugId":null}},
    {"offset": {"line": 2362, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/time.ts"],"sourcesContent":["// Time-related utility functions\n\nimport { DEFAULT_FPS } from \"@/stores/project-store\";\n\nexport type TimeCode = \"MM:SS\" | \"HH:MM:SS\" | \"HH:MM:SS:CS\" | \"HH:MM:SS:FF\";\n\n// Helper function to format time in various formats (MM:SS, HH:MM:SS, HH:MM:SS:CS, HH:MM:SS:FF)\nexport const formatTimeCode = (\n  timeInSeconds: number,\n  format: TimeCode = \"HH:MM:SS:CS\",\n  fps = DEFAULT_FPS\n): string => {\n  const hours = Math.floor(timeInSeconds / 3600);\n  const minutes = Math.floor((timeInSeconds % 3600) / 60);\n  const seconds = Math.floor(timeInSeconds % 60);\n  const centiseconds = Math.floor((timeInSeconds % 1) * 100);\n  const frames = Math.floor((timeInSeconds % 1) * fps);\n\n  switch (format) {\n    case \"MM:SS\":\n      return `${minutes.toString().padStart(2, \"0\")}:${seconds.toString().padStart(2, \"0\")}`;\n    case \"HH:MM:SS\":\n      return `${hours.toString().padStart(2, \"0\")}:${minutes.toString().padStart(2, \"0\")}:${seconds.toString().padStart(2, \"0\")}`;\n    case \"HH:MM:SS:CS\":\n      return `${hours.toString().padStart(2, \"0\")}:${minutes.toString().padStart(2, \"0\")}:${seconds.toString().padStart(2, \"0\")}:${centiseconds.toString().padStart(2, \"0\")}`;\n    case \"HH:MM:SS:FF\":\n      return `${hours.toString().padStart(2, \"0\")}:${minutes.toString().padStart(2, \"0\")}:${seconds.toString().padStart(2, \"0\")}:${frames.toString().padStart(2, \"0\")}`;\n  }\n};\n\nexport const parseTimeCode = (\n  timeCode: string,\n  format: TimeCode = \"HH:MM:SS:CS\",\n  fps = DEFAULT_FPS\n): number | null => {\n  if (!timeCode || typeof timeCode !== \"string\") return null;\n\n  // Remove any extra whitespace\n  const cleanTimeCode = timeCode.trim();\n\n  try {\n    switch (format) {\n      case \"MM:SS\": {\n        const parts = cleanTimeCode.split(\":\");\n        if (parts.length !== 2) return null;\n        const [minutes, seconds] = parts.map((part) => parseInt(part, 10));\n        if (isNaN(minutes) || isNaN(seconds)) return null;\n        if (minutes < 0 || seconds < 0 || seconds >= 60) return null;\n        return minutes * 60 + seconds;\n      }\n\n      case \"HH:MM:SS\": {\n        const parts = cleanTimeCode.split(\":\");\n        if (parts.length !== 3) return null;\n        const [hours, minutes, seconds] = parts.map((part) =>\n          parseInt(part, 10)\n        );\n        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return null;\n        if (\n          hours < 0 ||\n          minutes < 0 ||\n          seconds < 0 ||\n          minutes >= 60 ||\n          seconds >= 60\n        )\n          return null;\n        return hours * 3600 + minutes * 60 + seconds;\n      }\n\n      case \"HH:MM:SS:CS\": {\n        const parts = cleanTimeCode.split(\":\");\n        if (parts.length !== 4) return null;\n        const [hours, minutes, seconds, centiseconds] = parts.map((part) =>\n          parseInt(part, 10)\n        );\n        if (\n          isNaN(hours) ||\n          isNaN(minutes) ||\n          isNaN(seconds) ||\n          isNaN(centiseconds)\n        )\n          return null;\n        if (\n          hours < 0 ||\n          minutes < 0 ||\n          seconds < 0 ||\n          centiseconds < 0 ||\n          minutes >= 60 ||\n          seconds >= 60 ||\n          centiseconds >= 100\n        )\n          return null;\n        return hours * 3600 + minutes * 60 + seconds + centiseconds / 100;\n      }\n\n      case \"HH:MM:SS:FF\": {\n        const parts = cleanTimeCode.split(\":\");\n        if (parts.length !== 4) return null;\n        const [hours, minutes, seconds, frames] = parts.map((part) =>\n          parseInt(part, 10)\n        );\n        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds) || isNaN(frames))\n          return null;\n        if (\n          hours < 0 ||\n          minutes < 0 ||\n          seconds < 0 ||\n          frames < 0 ||\n          minutes >= 60 ||\n          seconds >= 60 ||\n          frames >= fps\n        )\n          return null;\n        return hours * 3600 + minutes * 60 + seconds + frames / fps;\n      }\n    }\n  } catch {\n    return null;\n  }\n\n  return null;\n};\n\nexport const guessTimeCodeFormat = (timeCode: string): TimeCode | null => {\n  if (!timeCode || typeof timeCode !== \"string\") return null;\n\n  const numbers = timeCode.split(\":\");\n\n  if (!numbers.every((n) => !isNaN(Number(n)))) return null;\n\n  if (numbers.length === 2) return \"MM:SS\";\n  if (numbers.length === 3) return \"HH:MM:SS\";\n  // todo: how to tell frames apart from cs?\n  if (numbers.length === 4) return \"HH:MM:SS:FF\";\n\n  return null;\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2449, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/canvas-gradients.ts"],"sourcesContent":["function splitBackgroundLayers(input: string): string[] {\n  const layers: string[] = [];\n  let depth = 0;\n  let start = 0;\n  for (let i = 0; i < input.length; i += 1) {\n    const ch = input[i] as string;\n    if (ch === \"(\") depth += 1;\n    else if (ch === \")\") depth -= 1;\n    else if (ch === \",\" && depth === 0) {\n      layers.push(input.slice(start, i).trim());\n      start = i + 1;\n    }\n  }\n  layers.push(input.slice(start).trim());\n  return layers;\n}\n\nfunction parseColorStop(stop: string): { color: string; position?: number } {\n  const s = stop.trim();\n\n  // Handle functional colors like rgba(), rgb(), hsla(), hsl()\n  const colorFunctions = [\"rgba(\", \"rgb(\", \"hsla(\", \"hsl(\"];\n  let color = \"\";\n  let remaining = \"\";\n\n  for (const fn of colorFunctions) {\n    if (s.startsWith(fn)) {\n      let depth = 0;\n      for (let i = 0; i < s.length; i += 1) {\n        const ch = s[i] as string;\n        if (ch === \"(\") depth += 1;\n        else if (ch === \")\") {\n          depth -= 1;\n          if (depth === 0) {\n            color = s.slice(0, i + 1);\n            remaining = s.slice(i + 1).trim();\n            break;\n          }\n        }\n      }\n      break;\n    }\n  }\n\n  if (!color) {\n    const parts = s.split(/\\s+/);\n    color = parts[0] as string;\n    remaining = parts.slice(1).join(\" \");\n  }\n\n  // Convert transparent to transparent white for better blending\n  if (color === \"transparent\") {\n    color = \"rgba(255, 255, 255, 0)\";\n  }\n\n  // Parse position if present\n  let position: number | undefined;\n  if (remaining) {\n    const posMatch = remaining.match(/(\\d+(?:\\.\\d+)?)%/);\n    if (posMatch) {\n      position = parseFloat(posMatch[1] as string) / 100;\n    }\n  }\n\n  return { color, position };\n}\n\nfunction parseLinearGradient(layer: string, width: number, height: number) {\n  const inside = layer.slice(layer.indexOf(\"(\") + 1, layer.lastIndexOf(\")\"));\n  const parts = splitBackgroundLayers(inside);\n  const dir = (parts.shift() || \"\").trim();\n\n  let x0 = 0,\n    y0 = 0,\n    x1 = width,\n    y1 = 0; // default: to right\n\n  if (dir.endsWith(\"deg\")) {\n    const deg = parseFloat(dir);\n    const rad = (deg * Math.PI) / 180;\n    const cx = width / 2;\n    const cy = height / 2;\n    const r = Math.hypot(width, height) / 2;\n    x0 = cx - Math.cos(rad) * r;\n    y0 = cy - Math.sin(rad) * r;\n    x1 = cx + Math.cos(rad) * r;\n    y1 = cy + Math.sin(rad) * r;\n  } else if (dir.startsWith(\"to \")) {\n    const d = dir.slice(3).trim();\n    if (d === \"right\") {\n      x0 = 0;\n      y0 = 0;\n      x1 = width;\n      y1 = 0;\n    } else if (d === \"left\") {\n      x0 = width;\n      y0 = 0;\n      x1 = 0;\n      y1 = 0;\n    } else if (d === \"bottom\") {\n      x0 = 0;\n      y0 = 0;\n      x1 = 0;\n      y1 = height;\n    } else if (d === \"top\") {\n      x0 = 0;\n      y0 = height;\n      x1 = 0;\n      y1 = 0;\n    }\n  } else {\n    // No direction specified, treat as first color\n    parts.unshift(dir);\n  }\n\n  return { x0, y0, x1, y1, colors: parts };\n}\n\nfunction parseRadialGradient(layer: string, width: number, height: number) {\n  const inside = layer.slice(layer.indexOf(\"(\") + 1, layer.lastIndexOf(\")\"));\n  const parts = splitBackgroundLayers(inside);\n  const first = (parts.shift() || \"\").trim();\n\n  let cx = width / 2;\n  let cy = height / 2;\n\n  if (first.startsWith(\"circle at\")) {\n    const pos = first.replace(\"circle at\", \"\").trim();\n    const coords = pos.split(/\\s+/);\n\n    for (let i = 0; i < coords.length; i += 1) {\n      const coord = coords[i] as string;\n      if (coord.endsWith(\"%\")) {\n        const val = parseFloat(coord) / 100;\n        if (i === 0) cx = val * width;\n        else if (i === 1) cy = val * height;\n      } else if (coord === \"left\") cx = 0;\n      else if (coord === \"right\") cx = width;\n      else if (coord === \"top\") cy = 0;\n      else if (coord === \"bottom\") cy = height;\n      else if (coord === \"center\") {\n        if (i === 0) cx = width / 2;\n        else if (i === 1) cy = height / 2;\n      }\n    }\n  } else {\n    parts.unshift(first);\n  }\n\n  // Use farthest-corner for radius\n  const r = Math.max(\n    Math.hypot(cx, cy),\n    Math.hypot(width - cx, cy),\n    Math.hypot(cx, height - cy),\n    Math.hypot(width - cx, height - cy)\n  );\n\n  return { cx, cy, r, colors: parts };\n}\n\nexport function drawCssBackground(\n  ctx: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n  css: string\n): void {\n  const layers = splitBackgroundLayers(css).filter(Boolean);\n\n  // Draw layers from last to first (CSS background order)\n  for (let i = layers.length - 1; i >= 0; i -= 1) {\n    const layer = layers[i] as string;\n\n    if (layer.startsWith(\"linear-gradient(\")) {\n      const { x0, y0, x1, y1, colors } = parseLinearGradient(\n        layer,\n        width,\n        height\n      );\n      const grad = ctx.createLinearGradient(x0, y0, x1, y1);\n      const colorStops = colors.map((c) => parseColorStop(c as string));\n\n      // Handle positions properly\n      for (let j = 0; j < colorStops.length; j += 1) {\n        const stop = colorStops[j] as { color: string; position?: number };\n        const pos = stop.position ?? j / Math.max(1, colorStops.length - 1);\n        grad.addColorStop(Math.max(0, Math.min(1, pos)), stop.color);\n      }\n\n      ctx.fillStyle = grad;\n      ctx.fillRect(0, 0, width, height);\n    } else if (layer.startsWith(\"radial-gradient(\")) {\n      const { cx, cy, r, colors } = parseRadialGradient(layer, width, height);\n      const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);\n      const colorStops = colors.map((c) => parseColorStop(c as string));\n\n      // Handle positions properly\n      for (let j = 0; j < colorStops.length; j += 1) {\n        const stop = colorStops[j] as { color: string; position?: number };\n        const pos = stop.position ?? j / Math.max(1, colorStops.length - 1);\n        grad.addColorStop(Math.max(0, Math.min(1, pos)), stop.color);\n      }\n\n      ctx.fillStyle = grad;\n      ctx.fillRect(0, 0, width, height);\n    } else if (\n      layer.startsWith(\"#\") ||\n      layer.startsWith(\"rgb\") ||\n      layer.startsWith(\"hsl\") ||\n      layer === \"transparent\" ||\n      layer === \"white\" ||\n      layer === \"black\"\n    ) {\n      if (layer !== \"transparent\") {\n        ctx.fillStyle = layer;\n        ctx.fillRect(0, 0, width, height);\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2646, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/timeline-renderer.ts"],"sourcesContent":["import type { TimelineTrack } from \"@/types/timeline\";\nimport type { MediaFile } from \"@/types/media\";\nimport type { BlurIntensity } from \"@/types/project\";\nimport { videoCache } from \"./video-cache\";\nimport { drawCssBackground } from \"./canvas-gradients\";\n\nexport interface RenderContext {\n  ctx: CanvasRenderingContext2D;\n  time: number;\n  canvasWidth: number;\n  canvasHeight: number;\n  tracks: TimelineTrack[];\n  mediaFiles: MediaFile[];\n  backgroundColor?: string;\n  backgroundType?: \"color\" | \"blur\";\n  blurIntensity?: BlurIntensity;\n  projectCanvasSize?: { width: number; height: number };\n}\n\nconst imageElementCache = new Map<string, HTMLImageElement>();\n\nasync function getImageElement(\n  mediaItem: MediaFile\n): Promise<HTMLImageElement> {\n  const cacheKey = mediaItem.id;\n  const cached = imageElementCache.get(cacheKey);\n  if (cached) return cached;\n  const img = new Image();\n  await new Promise<void>((resolve, reject) => {\n    img.onload = () => resolve();\n    img.onerror = () => reject(new Error(\"Image load failed\"));\n    img.src = mediaItem.url || URL.createObjectURL(mediaItem.file);\n  });\n  imageElementCache.set(cacheKey, img);\n  return img;\n}\n\nexport async function renderTimelineFrame({\n  ctx,\n  time,\n  canvasWidth,\n  canvasHeight,\n  tracks,\n  mediaFiles,\n  backgroundColor,\n  backgroundType,\n  blurIntensity,\n  projectCanvasSize,\n}: RenderContext): Promise<void> {\n  // Background\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n  if (\n    backgroundColor &&\n    backgroundColor !== \"transparent\" &&\n    !backgroundColor.includes(\"gradient\")\n  ) {\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n  }\n\n  // If backgroundColor is a CSS gradient string, draw it\n  if (backgroundColor && backgroundColor.includes(\"gradient\")) {\n    drawCssBackground(ctx, canvasWidth, canvasHeight, backgroundColor);\n  }\n\n  const scaleX = projectCanvasSize ? canvasWidth / projectCanvasSize.width : 1;\n  const scaleY = projectCanvasSize\n    ? canvasHeight / projectCanvasSize.height\n    : 1;\n  const idToMedia = new Map(mediaFiles.map((m) => [m.id, m] as const));\n  const active: Array<{\n    track: TimelineTrack;\n    element: TimelineTrack[\"elements\"][number];\n    mediaItem: MediaFile | null;\n  }> = [];\n\n  for (let t = tracks.length - 1; t >= 0; t -= 1) {\n    const track = tracks[t];\n    for (const element of track.elements) {\n      if (element.hidden) continue;\n      const elementStart = element.startTime;\n      const elementEnd =\n        element.startTime +\n        (element.duration - element.trimStart - element.trimEnd);\n      if (time >= elementStart && time < elementEnd) {\n        let mediaItem: MediaFile | null = null;\n        if (element.type === \"media\") {\n          mediaItem =\n            element.mediaId === \"test\"\n              ? null\n              : idToMedia.get(element.mediaId) || null;\n        }\n        active.push({ track, element, mediaItem });\n      }\n    }\n  }\n\n  // If background is set to blur, draw the active media as a blurred cover layer first\n  if (backgroundType === \"blur\") {\n    const blurPx = Math.max(0, blurIntensity ?? 8);\n    // Find a suitable media element (video/image) among active elements\n    const bgCandidate = active.find(({ element, mediaItem }) => {\n      return (\n        element.type === \"media\" &&\n        mediaItem !== null &&\n        (mediaItem.type === \"video\" || mediaItem.type === \"image\")\n      );\n    });\n    if (bgCandidate && bgCandidate.mediaItem) {\n      const { element, mediaItem } = bgCandidate;\n      try {\n        if (mediaItem.type === \"video\") {\n          const localTime = time - element.startTime + element.trimStart;\n          const frame = await videoCache.getFrameAt(\n            mediaItem.id,\n            mediaItem.file,\n            Math.max(0, localTime)\n          );\n          if (frame) {\n            const mediaW = Math.max(1, mediaItem.width || canvasWidth);\n            const mediaH = Math.max(1, mediaItem.height || canvasHeight);\n            const coverScale = Math.max(\n              canvasWidth / mediaW,\n              canvasHeight / mediaH\n            );\n            const drawW = mediaW * coverScale;\n            const drawH = mediaH * coverScale;\n            const drawX = (canvasWidth - drawW) / 2;\n            const drawY = (canvasHeight - drawH) / 2;\n            ctx.save();\n            ctx.filter = `blur(${blurPx}px)`;\n            ctx.drawImage(frame.canvas, drawX, drawY, drawW, drawH);\n            ctx.restore();\n          }\n        } else if (mediaItem.type === \"image\") {\n          const img = await getImageElement(mediaItem);\n          const mediaW = Math.max(\n            1,\n            mediaItem.width || img.naturalWidth || canvasWidth\n          );\n          const mediaH = Math.max(\n            1,\n            mediaItem.height || img.naturalHeight || canvasHeight\n          );\n          const coverScale = Math.max(\n            canvasWidth / mediaW,\n            canvasHeight / mediaH\n          );\n          const drawW = mediaW * coverScale;\n          const drawH = mediaH * coverScale;\n          const drawX = (canvasWidth - drawW) / 2;\n          const drawY = (canvasHeight - drawH) / 2;\n          ctx.save();\n          ctx.filter = `blur(${blurPx}px)`;\n          ctx.drawImage(img, drawX, drawY, drawW, drawH);\n          ctx.restore();\n        }\n      } catch {\n        // Ignore background blur failures; foreground will still render\n      }\n    }\n  }\n\n  for (const { element, mediaItem } of active) {\n    if (element.type === \"media\" && mediaItem) {\n      if (mediaItem.type === \"video\") {\n        try {\n          const localTime = time - element.startTime + element.trimStart;\n\n          const frame = await videoCache.getFrameAt(\n            mediaItem.id,\n            mediaItem.file,\n            localTime\n          );\n          if (!frame) continue;\n\n          const mediaW = Math.max(1, mediaItem.width || canvasWidth);\n          const mediaH = Math.max(1, mediaItem.height || canvasHeight);\n          const containScale = Math.min(\n            canvasWidth / mediaW,\n            canvasHeight / mediaH\n          );\n          const drawW = mediaW * containScale;\n          const drawH = mediaH * containScale;\n          const drawX = (canvasWidth - drawW) / 2;\n          const drawY = (canvasHeight - drawH) / 2;\n\n          ctx.drawImage(frame.canvas, drawX, drawY, drawW, drawH);\n        } catch (error) {\n          console.warn(\n            `Failed to render video frame for ${mediaItem.name}:`,\n            error\n          );\n        }\n      }\n      if (mediaItem.type === \"image\") {\n        const img = new Image();\n        await new Promise<void>((resolve, reject) => {\n          img.onload = () => resolve();\n          img.onerror = () => reject(new Error(\"Image load failed\"));\n          img.src = mediaItem.url || URL.createObjectURL(mediaItem.file);\n        });\n        const mediaW = Math.max(\n          1,\n          mediaItem.width || img.naturalWidth || canvasWidth\n        );\n        const mediaH = Math.max(\n          1,\n          mediaItem.height || img.naturalHeight || canvasHeight\n        );\n        const containScale = Math.min(\n          canvasWidth / mediaW,\n          canvasHeight / mediaH\n        );\n        const drawW = mediaW * containScale;\n        const drawH = mediaH * containScale;\n        const drawX = (canvasWidth - drawW) / 2;\n        const drawY = (canvasHeight - drawH) / 2;\n        ctx.drawImage(img, drawX, drawY, drawW, drawH);\n      }\n    }\n    if (element.type === \"text\") {\n      const text = element;\n      const posX = canvasWidth / 2 + text.x * scaleX;\n      const posY = canvasHeight / 2 + text.y * scaleY;\n      ctx.save();\n      ctx.translate(posX, posY);\n      ctx.rotate((text.rotation * Math.PI) / 180);\n      ctx.globalAlpha = Math.max(0, Math.min(1, text.opacity));\n      const px = text.fontSize * scaleX;\n      const weight = text.fontWeight === \"bold\" ? \"bold \" : \"\";\n      const style = text.fontStyle === \"italic\" ? \"italic \" : \"\";\n      ctx.font = `${style}${weight}${px}px ${text.fontFamily}`;\n      ctx.fillStyle = text.color;\n      ctx.textAlign = text.textAlign as CanvasTextAlign;\n      ctx.textBaseline = \"middle\";\n      const metrics = ctx.measureText(text.content);\n      const hasBoxMetrics =\n        \"actualBoundingBoxAscent\" in metrics &&\n        \"actualBoundingBoxDescent\" in metrics;\n      const ascent = hasBoxMetrics\n        ? (\n            metrics as TextMetrics & {\n              actualBoundingBoxAscent: number;\n              actualBoundingBoxDescent: number;\n            }\n          ).actualBoundingBoxAscent\n        : px * 0.8;\n      const descent = hasBoxMetrics\n        ? (\n            metrics as TextMetrics & {\n              actualBoundingBoxAscent: number;\n              actualBoundingBoxDescent: number;\n            }\n          ).actualBoundingBoxDescent\n        : px * 0.2;\n      const textW = metrics.width;\n      const textH = ascent + descent;\n      const padX = 8 * scaleX;\n      const padY = 4 * scaleX;\n      if (text.backgroundColor) {\n        ctx.save();\n        ctx.fillStyle = text.backgroundColor;\n        let bgLeft = -textW / 2;\n        if (ctx.textAlign === \"left\") bgLeft = 0;\n        if (ctx.textAlign === \"right\") bgLeft = -textW;\n        ctx.fillRect(\n          bgLeft - padX,\n          -textH / 2 - padY,\n          textW + padX * 2,\n          textH + padY * 2\n        );\n        ctx.restore();\n      }\n      ctx.fillText(text.content, 0, 0);\n      ctx.restore();\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAGA;AACA;;;AAeA,MAAM,oBAAoB,IAAI;AAE9B,eAAe,gBACb,SAAoB;IAEpB,MAAM,WAAW,UAAU,EAAE;IAC7B,MAAM,SAAS,kBAAkB,GAAG,CAAC;IACrC,IAAI,QAAQ,OAAO;IACnB,MAAM,MAAM,IAAI;IAChB,MAAM,IAAI,QAAc,CAAC,SAAS;QAChC,IAAI,MAAM,GAAG,IAAM;QACnB,IAAI,OAAO,GAAG,IAAM,OAAO,IAAI,MAAM;QACrC,IAAI,GAAG,GAAG,UAAU,GAAG,IAAI,IAAI,eAAe,CAAC,UAAU,IAAI;IAC/D;IACA,kBAAkB,GAAG,CAAC,UAAU;IAChC,OAAO;AACT;AAEO,eAAe,oBAAoB,EACxC,GAAG,EACH,IAAI,EACJ,WAAW,EACX,YAAY,EACZ,MAAM,EACN,UAAU,EACV,eAAe,EACf,cAAc,EACd,aAAa,EACb,iBAAiB,EACH;IACd,aAAa;IACb,IAAI,SAAS,CAAC,GAAG,GAAG,aAAa;IACjC,IACE,mBACA,oBAAoB,iBACpB,CAAC,gBAAgB,QAAQ,CAAC,aAC1B;QACA,IAAI,SAAS,GAAG;QAChB,IAAI,QAAQ,CAAC,GAAG,GAAG,aAAa;IAClC;IAEA,uDAAuD;IACvD,IAAI,mBAAmB,gBAAgB,QAAQ,CAAC,aAAa;QAC3D,CAAA,GAAA,gJAAA,CAAA,oBAAiB,AAAD,EAAE,KAAK,aAAa,cAAc;IACpD;IAEA,MAAM,SAAS,oBAAoB,cAAc,kBAAkB,KAAK,GAAG;IAC3E,MAAM,SAAS,oBACX,eAAe,kBAAkB,MAAM,GACvC;IACJ,MAAM,YAAY,IAAI,IAAI,WAAW,GAAG,CAAC,CAAC,IAAM;YAAC,EAAE,EAAE;YAAE;SAAE;IACzD,MAAM,SAID,EAAE;IAEP,IAAK,IAAI,IAAI,OAAO,MAAM,GAAG,GAAG,KAAK,GAAG,KAAK,EAAG;QAC9C,MAAM,QAAQ,MAAM,CAAC,EAAE;QACvB,KAAK,MAAM,WAAW,MAAM,QAAQ,CAAE;YACpC,IAAI,QAAQ,MAAM,EAAE;YACpB,MAAM,eAAe,QAAQ,SAAS;YACtC,MAAM,aACJ,QAAQ,SAAS,GACjB,CAAC,QAAQ,QAAQ,GAAG,QAAQ,SAAS,GAAG,QAAQ,OAAO;YACzD,IAAI,QAAQ,gBAAgB,OAAO,YAAY;gBAC7C,IAAI,YAA8B;gBAClC,IAAI,QAAQ,IAAI,KAAK,SAAS;oBAC5B,YACE,QAAQ,OAAO,KAAK,SAChB,OACA,UAAU,GAAG,CAAC,QAAQ,OAAO,KAAK;gBAC1C;gBACA,OAAO,IAAI,CAAC;oBAAE;oBAAO;oBAAS;gBAAU;YAC1C;QACF;IACF;IAEA,qFAAqF;IACrF,IAAI,mBAAmB,QAAQ;QAC7B,MAAM,SAAS,KAAK,GAAG,CAAC,GAAG,iBAAiB;QAC5C,oEAAoE;QACpE,MAAM,cAAc,OAAO,IAAI,CAAC,CAAC,EAAE,OAAO,EAAE,SAAS,EAAE;YACrD,OACE,QAAQ,IAAI,KAAK,WACjB,cAAc,QACd,CAAC,UAAU,IAAI,KAAK,WAAW,UAAU,IAAI,KAAK,OAAO;QAE7D;QACA,IAAI,eAAe,YAAY,SAAS,EAAE;YACxC,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG;YAC/B,IAAI;gBACF,IAAI,UAAU,IAAI,KAAK,SAAS;oBAC9B,MAAM,YAAY,OAAO,QAAQ,SAAS,GAAG,QAAQ,SAAS;oBAC9D,MAAM,QAAQ,MAAM,2IAAA,CAAA,aAAU,CAAC,UAAU,CACvC,UAAU,EAAE,EACZ,UAAU,IAAI,EACd,KAAK,GAAG,CAAC,GAAG;oBAEd,IAAI,OAAO;wBACT,MAAM,SAAS,KAAK,GAAG,CAAC,GAAG,UAAU,KAAK,IAAI;wBAC9C,MAAM,SAAS,KAAK,GAAG,CAAC,GAAG,UAAU,MAAM,IAAI;wBAC/C,MAAM,aAAa,KAAK,GAAG,CACzB,cAAc,QACd,eAAe;wBAEjB,MAAM,QAAQ,SAAS;wBACvB,MAAM,QAAQ,SAAS;wBACvB,MAAM,QAAQ,CAAC,cAAc,KAAK,IAAI;wBACtC,MAAM,QAAQ,CAAC,eAAe,KAAK,IAAI;wBACvC,IAAI,IAAI;wBACR,IAAI,MAAM,GAAG,CAAC,KAAK,EAAE,OAAO,GAAG,CAAC;wBAChC,IAAI,SAAS,CAAC,MAAM,MAAM,EAAE,OAAO,OAAO,OAAO;wBACjD,IAAI,OAAO;oBACb;gBACF,OAAO,IAAI,UAAU,IAAI,KAAK,SAAS;oBACrC,MAAM,MAAM,MAAM,gBAAgB;oBAClC,MAAM,SAAS,KAAK,GAAG,CACrB,GACA,UAAU,KAAK,IAAI,IAAI,YAAY,IAAI;oBAEzC,MAAM,SAAS,KAAK,GAAG,CACrB,GACA,UAAU,MAAM,IAAI,IAAI,aAAa,IAAI;oBAE3C,MAAM,aAAa,KAAK,GAAG,CACzB,cAAc,QACd,eAAe;oBAEjB,MAAM,QAAQ,SAAS;oBACvB,MAAM,QAAQ,SAAS;oBACvB,MAAM,QAAQ,CAAC,cAAc,KAAK,IAAI;oBACtC,MAAM,QAAQ,CAAC,eAAe,KAAK,IAAI;oBACvC,IAAI,IAAI;oBACR,IAAI,MAAM,GAAG,CAAC,KAAK,EAAE,OAAO,GAAG,CAAC;oBAChC,IAAI,SAAS,CAAC,KAAK,OAAO,OAAO,OAAO;oBACxC,IAAI,OAAO;gBACb;YACF,EAAE,OAAM;YACN,gEAAgE;YAClE;QACF;IACF;IAEA,KAAK,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,IAAI,OAAQ;QAC3C,IAAI,QAAQ,IAAI,KAAK,WAAW,WAAW;YACzC,IAAI,UAAU,IAAI,KAAK,SAAS;gBAC9B,IAAI;oBACF,MAAM,YAAY,OAAO,QAAQ,SAAS,GAAG,QAAQ,SAAS;oBAE9D,MAAM,QAAQ,MAAM,2IAAA,CAAA,aAAU,CAAC,UAAU,CACvC,UAAU,EAAE,EACZ,UAAU,IAAI,EACd;oBAEF,IAAI,CAAC,OAAO;oBAEZ,MAAM,SAAS,KAAK,GAAG,CAAC,GAAG,UAAU,KAAK,IAAI;oBAC9C,MAAM,SAAS,KAAK,GAAG,CAAC,GAAG,UAAU,MAAM,IAAI;oBAC/C,MAAM,eAAe,KAAK,GAAG,CAC3B,cAAc,QACd,eAAe;oBAEjB,MAAM,QAAQ,SAAS;oBACvB,MAAM,QAAQ,SAAS;oBACvB,MAAM,QAAQ,CAAC,cAAc,KAAK,IAAI;oBACtC,MAAM,QAAQ,CAAC,eAAe,KAAK,IAAI;oBAEvC,IAAI,SAAS,CAAC,MAAM,MAAM,EAAE,OAAO,OAAO,OAAO;gBACnD,EAAE,OAAO,OAAO;oBACd,QAAQ,IAAI,CACV,CAAC,iCAAiC,EAAE,UAAU,IAAI,CAAC,CAAC,CAAC,EACrD;gBAEJ;YACF;YACA,IAAI,UAAU,IAAI,KAAK,SAAS;gBAC9B,MAAM,MAAM,IAAI;gBAChB,MAAM,IAAI,QAAc,CAAC,SAAS;oBAChC,IAAI,MAAM,GAAG,IAAM;oBACnB,IAAI,OAAO,GAAG,IAAM,OAAO,IAAI,MAAM;oBACrC,IAAI,GAAG,GAAG,UAAU,GAAG,IAAI,IAAI,eAAe,CAAC,UAAU,IAAI;gBAC/D;gBACA,MAAM,SAAS,KAAK,GAAG,CACrB,GACA,UAAU,KAAK,IAAI,IAAI,YAAY,IAAI;gBAEzC,MAAM,SAAS,KAAK,GAAG,CACrB,GACA,UAAU,MAAM,IAAI,IAAI,aAAa,IAAI;gBAE3C,MAAM,eAAe,KAAK,GAAG,CAC3B,cAAc,QACd,eAAe;gBAEjB,MAAM,QAAQ,SAAS;gBACvB,MAAM,QAAQ,SAAS;gBACvB,MAAM,QAAQ,CAAC,cAAc,KAAK,IAAI;gBACtC,MAAM,QAAQ,CAAC,eAAe,KAAK,IAAI;gBACvC,IAAI,SAAS,CAAC,KAAK,OAAO,OAAO,OAAO;YAC1C;QACF;QACA,IAAI,QAAQ,IAAI,KAAK,QAAQ;YAC3B,MAAM,OAAO;YACb,MAAM,OAAO,cAAc,IAAI,KAAK,CAAC,GAAG;YACxC,MAAM,OAAO,eAAe,IAAI,KAAK,CAAC,GAAG;YACzC,IAAI,IAAI;YACR,IAAI,SAAS,CAAC,MAAM;YACpB,IAAI,MAAM,CAAC,AAAC,KAAK,QAAQ,GAAG,KAAK,EAAE,GAAI;YACvC,IAAI,WAAW,GAAG,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,KAAK,OAAO;YACtD,MAAM,KAAK,KAAK,QAAQ,GAAG;YAC3B,MAAM,SAAS,KAAK,UAAU,KAAK,SAAS,UAAU;YACtD,MAAM,QAAQ,KAAK,SAAS,KAAK,WAAW,YAAY;YACxD,IAAI,IAAI,GAAG,GAAG,QAAQ,SAAS,GAAG,GAAG,EAAE,KAAK,UAAU,EAAE;YACxD,IAAI,SAAS,GAAG,KAAK,KAAK;YAC1B,IAAI,SAAS,GAAG,KAAK,SAAS;YAC9B,IAAI,YAAY,GAAG;YACnB,MAAM,UAAU,IAAI,WAAW,CAAC,KAAK,OAAO;YAC5C,MAAM,gBACJ,6BAA6B,WAC7B,8BAA8B;YAChC,MAAM,SAAS,gBACX,AACE,QAIA,uBAAuB,GACzB,KAAK;YACT,MAAM,UAAU,gBACZ,AACE,QAIA,wBAAwB,GAC1B,KAAK;YACT,MAAM,QAAQ,QAAQ,KAAK;YAC3B,MAAM,QAAQ,SAAS;YACvB,MAAM,OAAO,IAAI;YACjB,MAAM,OAAO,IAAI;YACjB,IAAI,KAAK,eAAe,EAAE;gBACxB,IAAI,IAAI;gBACR,IAAI,SAAS,GAAG,KAAK,eAAe;gBACpC,IAAI,SAAS,CAAC,QAAQ;gBACtB,IAAI,IAAI,SAAS,KAAK,QAAQ,SAAS;gBACvC,IAAI,IAAI,SAAS,KAAK,SAAS,SAAS,CAAC;gBACzC,IAAI,QAAQ,CACV,SAAS,MACT,CAAC,QAAQ,IAAI,MACb,QAAQ,OAAO,GACf,QAAQ,OAAO;gBAEjB,IAAI,OAAO;YACb;YACA,IAAI,QAAQ,CAAC,KAAK,OAAO,EAAE,GAAG;YAC9B,IAAI,OAAO;QACb;IACF;AACF","debugId":null}},
    {"offset": {"line": 2826, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/export.ts"],"sourcesContent":["import {\n  Output,\n  Mp4OutputFormat,\n  WebMOutputFormat,\n  BufferTarget,\n  CanvasSource,\n  AudioBufferSource,\n  QUALITY_LOW,\n  QUALITY_MEDIUM,\n  QUALITY_HIGH,\n  QUALITY_VERY_HIGH,\n} from \"mediabunny\";\nimport { renderTimelineFrame } from \"./timeline-renderer\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { useMediaStore } from \"@/stores/media-store\";\nimport { useProjectStore } from \"@/stores/project-store\";\nimport { DEFAULT_FPS, DEFAULT_CANVAS_SIZE } from \"@/stores/project-store\";\nimport { ExportOptions, ExportResult } from \"@/types/export\";\nimport { TimelineTrack } from \"@/types/timeline\";\nimport { MediaFile } from \"@/types/media\";\n\nexport const DEFAULT_EXPORT_OPTIONS: ExportOptions = {\n  format: \"mp4\",\n  quality: \"high\",\n  includeAudio: true,\n};\n\nconst qualityMap = {\n  low: QUALITY_LOW,\n  medium: QUALITY_MEDIUM,\n  high: QUALITY_HIGH,\n  very_high: QUALITY_VERY_HIGH,\n};\n\ninterface AudioElement {\n  buffer: AudioBuffer;\n  startTime: number;\n  duration: number;\n  trimStart: number;\n  trimEnd: number;\n  muted: boolean;\n}\n\nasync function createTimelineAudioBuffer(\n  tracks: TimelineTrack[],\n  mediaFiles: MediaFile[],\n  duration: number,\n  sampleRate: number = 44100\n): Promise<AudioBuffer | null> {\n  // Get Web Audio context\n  const audioContext = new (window.AudioContext ||\n    (window as any).webkitAudioContext)();\n\n  // Collect all audio elements from timeline\n  const audioElements: AudioElement[] = [];\n  const mediaMap = new Map<string, MediaFile>(mediaFiles.map((m) => [m.id, m]));\n\n  for (const track of tracks) {\n    if (track.muted) continue;\n\n    for (const element of track.elements) {\n      if (element.type !== \"media\") continue;\n\n      const mediaElement = element;\n      const mediaItem = mediaMap.get(mediaElement.mediaId);\n      if (!mediaItem || mediaItem.type !== \"audio\") continue;\n\n      const visibleDuration =\n        mediaElement.duration - mediaElement.trimStart - mediaElement.trimEnd;\n      if (visibleDuration <= 0) continue;\n\n      try {\n        // Decode audio file\n        const arrayBuffer = await mediaItem.file.arrayBuffer();\n        const audioBuffer = await audioContext.decodeAudioData(\n          arrayBuffer.slice(0)\n        );\n\n        audioElements.push({\n          buffer: audioBuffer,\n          startTime: mediaElement.startTime,\n          duration: mediaElement.duration,\n          trimStart: mediaElement.trimStart,\n          trimEnd: mediaElement.trimEnd,\n          muted: mediaElement.muted || track.muted || false,\n        });\n      } catch (error) {\n        console.warn(`Failed to decode audio file ${mediaItem.name}:`, error);\n      }\n    }\n  }\n\n  if (audioElements.length === 0) {\n    return null; // No audio to mix\n  }\n\n  // Create output buffer\n  const outputChannels = 2; // Stereo\n  const outputLength = Math.ceil(duration * sampleRate);\n  const outputBuffer = audioContext.createBuffer(\n    outputChannels,\n    outputLength,\n    sampleRate\n  );\n\n  // Mix all audio elements\n  for (const element of audioElements) {\n    if (element.muted) continue;\n\n    const {\n      buffer,\n      startTime,\n      trimStart,\n      trimEnd,\n      duration: elementDuration,\n    } = element;\n\n    // Calculate timing\n    const sourceStartSample = Math.floor(trimStart * buffer.sampleRate);\n    const sourceDuration = elementDuration - trimStart - trimEnd;\n    const sourceLengthSamples = Math.floor(sourceDuration * buffer.sampleRate);\n    const outputStartSample = Math.floor(startTime * sampleRate);\n\n    // Resample if needed (simple approach)\n    const resampleRatio = sampleRate / buffer.sampleRate;\n    const resampledLength = Math.floor(sourceLengthSamples * resampleRatio);\n\n    // Mix each channel\n    for (let channel = 0; channel < outputChannels; channel++) {\n      const outputData = outputBuffer.getChannelData(channel);\n      const sourceChannel = Math.min(channel, buffer.numberOfChannels - 1);\n      const sourceData = buffer.getChannelData(sourceChannel);\n\n      for (let i = 0; i < resampledLength; i++) {\n        const outputIndex = outputStartSample + i;\n        if (outputIndex >= outputLength) break;\n\n        // Simple resampling (could be improved with proper interpolation)\n        const sourceIndex = sourceStartSample + Math.floor(i / resampleRatio);\n        if (sourceIndex >= sourceData.length) break;\n\n        outputData[outputIndex] += sourceData[sourceIndex];\n      }\n    }\n  }\n\n  return outputBuffer;\n}\n\nexport async function exportProject(\n  options: ExportOptions\n): Promise<ExportResult> {\n  const { format, quality, fps, includeAudio, onProgress, onCancel } = options;\n\n  try {\n    const timelineStore = useTimelineStore.getState();\n    const mediaStore = useMediaStore.getState();\n    const projectStore = useProjectStore.getState();\n\n    const { tracks, getTotalDuration } = timelineStore;\n    const { mediaFiles } = mediaStore;\n    const { activeProject } = projectStore;\n\n    if (!activeProject) {\n      return { success: false, error: \"No active project\" };\n    }\n\n    const duration = getTotalDuration();\n    if (duration === 0) {\n      return { success: false, error: \"Project is empty\" };\n    }\n\n    const exportFps = fps || activeProject.fps || DEFAULT_FPS;\n    const canvasSize = activeProject.canvasSize || DEFAULT_CANVAS_SIZE;\n\n    const outputFormat =\n      format === \"webm\" ? new WebMOutputFormat() : new Mp4OutputFormat();\n\n    // BufferTarget for smaller files, StreamTarget for larger ones\n    // TODO: Implement StreamTarget\n    const output = new Output({\n      format: outputFormat,\n      target: new BufferTarget(),\n    });\n\n    // Canvas for rendering\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = canvasSize.width;\n    canvas.height = canvasSize.height;\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) {\n      return { success: false, error: \"Failed to create canvas context\" };\n    }\n\n    const videoSource = new CanvasSource(canvas, {\n      codec: format === \"webm\" ? \"vp9\" : \"avc\", // VP9 for WebM, H.264 for MP4\n      bitrate: qualityMap[quality],\n    });\n\n    output.addVideoTrack(videoSource, { frameRate: exportFps });\n\n    // Add audio track if requested (but don't add data yet)\n    let audioSource: AudioBufferSource | null = null;\n    let audioBuffer: AudioBuffer | null = null;\n\n    if (includeAudio) {\n      onProgress?.(0.05); // 5% for audio processing\n\n      audioBuffer = await createTimelineAudioBuffer(\n        tracks,\n        mediaFiles,\n        duration\n      );\n\n      if (audioBuffer) {\n        audioSource = new AudioBufferSource({\n          codec: format === \"webm\" ? \"opus\" : \"aac\", // Opus for WebM, AAC for MP4\n          bitrate: qualityMap[quality], // Use same quality for audio\n        });\n\n        output.addAudioTrack(audioSource);\n      }\n    }\n\n    // Start the output (after all tracks are added)\n    await output.start();\n\n    // Now add audio data after starting\n    if (audioSource && audioBuffer) {\n      await audioSource.add(audioBuffer);\n      audioSource.close();\n    }\n\n    const totalFrames = Math.ceil(duration * exportFps);\n    let cancelled = false;\n\n    // Render each frame\n    for (let frameIndex = 0; frameIndex < totalFrames; frameIndex++) {\n      // Check for cancellation\n      if (onCancel?.()) {\n        cancelled = true;\n        break;\n      }\n\n      const time = frameIndex / exportFps;\n\n      await renderTimelineFrame({\n        ctx,\n        time,\n        canvasWidth: canvas.width,\n        canvasHeight: canvas.height,\n        tracks,\n        mediaFiles,\n        backgroundType: activeProject.backgroundType,\n        blurIntensity: activeProject.blurIntensity,\n        backgroundColor:\n          activeProject.backgroundType === \"blur\"\n            ? undefined\n            : activeProject.backgroundColor || \"#000000\",\n        projectCanvasSize: canvasSize,\n      });\n\n      const frameDuration = 1 / exportFps;\n      await videoSource.add(time, frameDuration);\n\n      // Adjust progress to account for audio processing (5% at start)\n      const videoProgress = includeAudio\n        ? 0.05 + (frameIndex / totalFrames) * 0.95\n        : frameIndex / totalFrames;\n      onProgress?.(videoProgress);\n    }\n\n    if (cancelled) {\n      await output.cancel();\n      return { success: false, cancelled: true };\n    }\n    videoSource.close();\n    await output.finalize();\n    onProgress?.(1);\n\n    return {\n      success: true,\n      buffer: output.target.buffer || undefined,\n    };\n  } catch (error) {\n    console.error(\"Export failed:\", error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : \"Unknown export error\",\n    };\n  }\n}\n\nexport function getExportMimeType(format: \"mp4\" | \"webm\"): string {\n  return format === \"webm\" ? \"video/webm\" : \"video/mp4\";\n}\n\nexport function getExportFileExtension(format: \"mp4\" | \"webm\"): string {\n  return `.${format}`;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3059, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/stores/panel-store.ts"],"sourcesContent":["import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\n\nexport type PanelPreset =\n  | \"default\"\n  | \"media\"\n  | \"inspector\"\n  | \"vertical-preview\";\n\ninterface PanelSizes {\n  toolsPanel: number;\n  previewPanel: number;\n  propertiesPanel: number;\n  mainContent: number;\n  timeline: number;\n}\n\nexport const PRESET_CONFIGS: Record<PanelPreset, PanelSizes> = {\n  default: {\n    toolsPanel: 25,\n    previewPanel: 50,\n    propertiesPanel: 25,\n    mainContent: 70,\n    timeline: 30,\n  },\n  media: {\n    toolsPanel: 30,\n    previewPanel: 45,\n    propertiesPanel: 25,\n    mainContent: 100,\n    timeline: 25,\n  },\n  inspector: {\n    toolsPanel: 30,\n    previewPanel: 70,\n    propertiesPanel: 30,\n    mainContent: 75,\n    timeline: 25,\n  },\n  \"vertical-preview\": {\n    toolsPanel: 30,\n    previewPanel: 40,\n    propertiesPanel: 30,\n    mainContent: 75,\n    timeline: 25,\n  },\n};\n\ninterface PanelState extends PanelSizes {\n  activePreset: PanelPreset;\n  presetCustomSizes: Record<PanelPreset, Partial<PanelSizes>>;\n  resetCounter: number;\n\n  mediaViewMode: \"grid\" | \"list\";\n\n  setToolsPanel: (size: number) => void;\n  setPreviewPanel: (size: number) => void;\n  setPropertiesPanel: (size: number) => void;\n  setMainContent: (size: number) => void;\n  setTimeline: (size: number) => void;\n  setMediaViewMode: (mode: \"grid\" | \"list\") => void;\n\n  setActivePreset: (preset: PanelPreset) => void;\n  resetPreset: (preset: PanelPreset) => void;\n  getCurrentPresetSizes: () => PanelSizes;\n}\n\nexport const usePanelStore = create<PanelState>()(\n  persist(\n    (set, get) => ({\n      ...PRESET_CONFIGS.default,\n      activePreset: \"default\" as PanelPreset,\n      presetCustomSizes: {\n        default: {},\n        media: {},\n        inspector: {},\n        \"vertical-preview\": {},\n      },\n      resetCounter: 0,\n\n      mediaViewMode: \"grid\" as const,\n\n      setToolsPanel: (size) => {\n        const { activePreset, presetCustomSizes } = get();\n        set({\n          toolsPanel: size,\n          presetCustomSizes: {\n            ...presetCustomSizes,\n            [activePreset]: {\n              ...presetCustomSizes[activePreset],\n              toolsPanel: size,\n            },\n          },\n        });\n      },\n      setPreviewPanel: (size) => {\n        const { activePreset, presetCustomSizes } = get();\n        set({\n          previewPanel: size,\n          presetCustomSizes: {\n            ...presetCustomSizes,\n            [activePreset]: {\n              ...presetCustomSizes[activePreset],\n              previewPanel: size,\n            },\n          },\n        });\n      },\n      setPropertiesPanel: (size) => {\n        const { activePreset, presetCustomSizes } = get();\n        set({\n          propertiesPanel: size,\n          presetCustomSizes: {\n            ...presetCustomSizes,\n            [activePreset]: {\n              ...presetCustomSizes[activePreset],\n              propertiesPanel: size,\n            },\n          },\n        });\n      },\n      setMainContent: (size) => {\n        const { activePreset, presetCustomSizes } = get();\n        set({\n          mainContent: size,\n          presetCustomSizes: {\n            ...presetCustomSizes,\n            [activePreset]: {\n              ...presetCustomSizes[activePreset],\n              mainContent: size,\n            },\n          },\n        });\n      },\n      setTimeline: (size) => {\n        const { activePreset, presetCustomSizes } = get();\n        set({\n          timeline: size,\n          presetCustomSizes: {\n            ...presetCustomSizes,\n            [activePreset]: {\n              ...presetCustomSizes[activePreset],\n              timeline: size,\n            },\n          },\n        });\n      },\n      setMediaViewMode: (mode) => set({ mediaViewMode: mode }),\n\n      setActivePreset: (preset) => {\n        const {\n          activePreset: currentPreset,\n          presetCustomSizes,\n          toolsPanel,\n          previewPanel,\n          propertiesPanel,\n          mainContent,\n          timeline,\n        } = get();\n\n        const updatedPresetCustomSizes = {\n          ...presetCustomSizes,\n          [currentPreset]: {\n            toolsPanel,\n            previewPanel,\n            propertiesPanel,\n            mainContent,\n            timeline,\n          },\n        };\n\n        const defaultSizes = PRESET_CONFIGS[preset];\n        const customSizes = updatedPresetCustomSizes[preset] || {};\n        const finalSizes = { ...defaultSizes, ...customSizes } as PanelSizes;\n\n        set({\n          activePreset: preset,\n          presetCustomSizes: updatedPresetCustomSizes,\n          ...finalSizes,\n        });\n      },\n\n      resetPreset: (preset) => {\n        const { presetCustomSizes, activePreset, resetCounter } = get();\n        const defaultSizes = PRESET_CONFIGS[preset];\n\n        const newPresetCustomSizes = {\n          ...presetCustomSizes,\n          [preset]: {},\n        };\n\n        const updates: Partial<PanelState> = {\n          presetCustomSizes: newPresetCustomSizes,\n          resetCounter: resetCounter + 1,\n        };\n\n        if (preset === activePreset) {\n          Object.assign(updates, defaultSizes);\n        }\n\n        set(updates);\n      },\n\n      getCurrentPresetSizes: () => {\n        const {\n          toolsPanel,\n          previewPanel,\n          propertiesPanel,\n          mainContent,\n          timeline,\n        } = get();\n        return {\n          toolsPanel,\n          previewPanel,\n          propertiesPanel,\n          mainContent,\n          timeline,\n        };\n      },\n    }),\n    {\n      name: \"panel-sizes\",\n    }\n  )\n);\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAgBO,MAAM,iBAAkD;IAC7D,SAAS;QACP,YAAY;QACZ,cAAc;QACd,iBAAiB;QACjB,aAAa;QACb,UAAU;IACZ;IACA,OAAO;QACL,YAAY;QACZ,cAAc;QACd,iBAAiB;QACjB,aAAa;QACb,UAAU;IACZ;IACA,WAAW;QACT,YAAY;QACZ,cAAc;QACd,iBAAiB;QACjB,aAAa;QACb,UAAU;IACZ;IACA,oBAAoB;QAClB,YAAY;QACZ,cAAc;QACd,iBAAiB;QACjB,aAAa;QACb,UAAU;IACZ;AACF;AAqBO,MAAM,gBAAgB,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD,IAChC,CAAA,GAAA,oNAAA,CAAA,UAAO,AAAD,EACJ,CAAC,KAAK,MAAQ,CAAC;QACb,GAAG,eAAe,OAAO;QACzB,cAAc;QACd,mBAAmB;YACjB,SAAS,CAAC;YACV,OAAO,CAAC;YACR,WAAW,CAAC;YACZ,oBAAoB,CAAC;QACvB;QACA,cAAc;QAEd,eAAe;QAEf,eAAe,CAAC;YACd,MAAM,EAAE,YAAY,EAAE,iBAAiB,EAAE,GAAG;YAC5C,IAAI;gBACF,YAAY;gBACZ,mBAAmB;oBACjB,GAAG,iBAAiB;oBACpB,CAAC,aAAa,EAAE;wBACd,GAAG,iBAAiB,CAAC,aAAa;wBAClC,YAAY;oBACd;gBACF;YACF;QACF;QACA,iBAAiB,CAAC;YAChB,MAAM,EAAE,YAAY,EAAE,iBAAiB,EAAE,GAAG;YAC5C,IAAI;gBACF,cAAc;gBACd,mBAAmB;oBACjB,GAAG,iBAAiB;oBACpB,CAAC,aAAa,EAAE;wBACd,GAAG,iBAAiB,CAAC,aAAa;wBAClC,cAAc;oBAChB;gBACF;YACF;QACF;QACA,oBAAoB,CAAC;YACnB,MAAM,EAAE,YAAY,EAAE,iBAAiB,EAAE,GAAG;YAC5C,IAAI;gBACF,iBAAiB;gBACjB,mBAAmB;oBACjB,GAAG,iBAAiB;oBACpB,CAAC,aAAa,EAAE;wBACd,GAAG,iBAAiB,CAAC,aAAa;wBAClC,iBAAiB;oBACnB;gBACF;YACF;QACF;QACA,gBAAgB,CAAC;YACf,MAAM,EAAE,YAAY,EAAE,iBAAiB,EAAE,GAAG;YAC5C,IAAI;gBACF,aAAa;gBACb,mBAAmB;oBACjB,GAAG,iBAAiB;oBACpB,CAAC,aAAa,EAAE;wBACd,GAAG,iBAAiB,CAAC,aAAa;wBAClC,aAAa;oBACf;gBACF;YACF;QACF;QACA,aAAa,CAAC;YACZ,MAAM,EAAE,YAAY,EAAE,iBAAiB,EAAE,GAAG;YAC5C,IAAI;gBACF,UAAU;gBACV,mBAAmB;oBACjB,GAAG,iBAAiB;oBACpB,CAAC,aAAa,EAAE;wBACd,GAAG,iBAAiB,CAAC,aAAa;wBAClC,UAAU;oBACZ;gBACF;YACF;QACF;QACA,kBAAkB,CAAC,OAAS,IAAI;gBAAE,eAAe;YAAK;QAEtD,iBAAiB,CAAC;YAChB,MAAM,EACJ,cAAc,aAAa,EAC3B,iBAAiB,EACjB,UAAU,EACV,YAAY,EACZ,eAAe,EACf,WAAW,EACX,QAAQ,EACT,GAAG;YAEJ,MAAM,2BAA2B;gBAC/B,GAAG,iBAAiB;gBACpB,CAAC,cAAc,EAAE;oBACf;oBACA;oBACA;oBACA;oBACA;gBACF;YACF;YAEA,MAAM,eAAe,cAAc,CAAC,OAAO;YAC3C,MAAM,cAAc,wBAAwB,CAAC,OAAO,IAAI,CAAC;YACzD,MAAM,aAAa;gBAAE,GAAG,YAAY;gBAAE,GAAG,WAAW;YAAC;YAErD,IAAI;gBACF,cAAc;gBACd,mBAAmB;gBACnB,GAAG,UAAU;YACf;QACF;QAEA,aAAa,CAAC;YACZ,MAAM,EAAE,iBAAiB,EAAE,YAAY,EAAE,YAAY,EAAE,GAAG;YAC1D,MAAM,eAAe,cAAc,CAAC,OAAO;YAE3C,MAAM,uBAAuB;gBAC3B,GAAG,iBAAiB;gBACpB,CAAC,OAAO,EAAE,CAAC;YACb;YAEA,MAAM,UAA+B;gBACnC,mBAAmB;gBACnB,cAAc,eAAe;YAC/B;YAEA,IAAI,WAAW,cAAc;gBAC3B,OAAO,MAAM,CAAC,SAAS;YACzB;YAEA,IAAI;QACN;QAEA,uBAAuB;YACrB,MAAM,EACJ,UAAU,EACV,YAAY,EACZ,eAAe,EACf,WAAW,EACX,QAAQ,EACT,GAAG;YACJ,OAAO;gBACL;gBACA;gBACA;gBACA;gBACA;YACF;QACF;IACF,CAAC,GACD;IACE,MAAM;AACR","debugId":null}},
    {"offset": {"line": 3233, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/stores/sounds-store.ts"],"sourcesContent":["import { create } from \"zustand\";\r\nimport type { SoundEffect, SavedSound } from \"@/types/sounds\";\r\nimport { storageService } from \"@/lib/storage/storage-service\";\r\nimport { toast } from \"sonner\";\r\nimport { useMediaStore } from \"./media-store\";\r\nimport { useTimelineStore } from \"./timeline-store\";\r\nimport { useProjectStore } from \"./project-store\";\r\nimport { usePlaybackStore } from \"./playback-store\";\r\n\r\ninterface SoundsStore {\r\n  topSoundEffects: SoundEffect[];\r\n  isLoading: boolean;\r\n  error: string | null;\r\n  hasLoaded: boolean;\r\n\r\n  // Filter state\r\n  showCommercialOnly: boolean;\r\n  toggleCommercialFilter: () => void;\r\n\r\n  // Search state\r\n  searchQuery: string;\r\n  searchResults: SoundEffect[];\r\n  isSearching: boolean;\r\n  searchError: string | null;\r\n  lastSearchQuery: string;\r\n  scrollPosition: number;\r\n\r\n  // Pagination state\r\n  currentPage: number;\r\n  hasNextPage: boolean;\r\n  totalCount: number;\r\n  isLoadingMore: boolean;\r\n\r\n  // Saved sounds state\r\n  savedSounds: SavedSound[];\r\n  isSavedSoundsLoaded: boolean;\r\n  isLoadingSavedSounds: boolean;\r\n  savedSoundsError: string | null;\r\n\r\n  // Timeline integration\r\n  addSoundToTimeline: (sound: SoundEffect) => Promise<boolean>;\r\n\r\n  setTopSoundEffects: (sounds: SoundEffect[]) => void;\r\n  setLoading: (loading: boolean) => void;\r\n  setError: (error: string | null) => void;\r\n  setHasLoaded: (loaded: boolean) => void;\r\n\r\n  // Search actions\r\n  setSearchQuery: (query: string) => void;\r\n  setSearchResults: (results: SoundEffect[]) => void;\r\n  setSearching: (searching: boolean) => void;\r\n  setSearchError: (error: string | null) => void;\r\n  setLastSearchQuery: (query: string) => void;\r\n  setScrollPosition: (position: number) => void;\r\n\r\n  // Pagination actions\r\n  setCurrentPage: (page: number) => void;\r\n  setHasNextPage: (hasNext: boolean) => void;\r\n  setTotalCount: (count: number) => void;\r\n  setLoadingMore: (loading: boolean) => void;\r\n  appendSearchResults: (results: SoundEffect[]) => void;\r\n  appendTopSounds: (results: SoundEffect[]) => void;\r\n  resetPagination: () => void;\r\n\r\n  // Saved sounds actions\r\n  loadSavedSounds: () => Promise<void>;\r\n  saveSoundEffect: (soundEffect: SoundEffect) => Promise<void>;\r\n  removeSavedSound: (soundId: number) => Promise<void>;\r\n  isSoundSaved: (soundId: number) => boolean;\r\n  toggleSavedSound: (soundEffect: SoundEffect) => Promise<void>;\r\n  clearSavedSounds: () => Promise<void>;\r\n}\r\n\r\nexport const useSoundsStore = create<SoundsStore>((set, get) => ({\r\n  topSoundEffects: [],\r\n  isLoading: false,\r\n  error: null,\r\n  hasLoaded: false,\r\n  showCommercialOnly: true,\r\n\r\n  toggleCommercialFilter: () => {\r\n    set((state) => ({ showCommercialOnly: !state.showCommercialOnly }));\r\n  },\r\n\r\n  // Search state\r\n  searchQuery: \"\",\r\n  searchResults: [],\r\n  isSearching: false,\r\n  searchError: null,\r\n  lastSearchQuery: \"\",\r\n  scrollPosition: 0,\r\n\r\n  // Pagination state\r\n  currentPage: 1,\r\n  hasNextPage: false,\r\n  totalCount: 0,\r\n  isLoadingMore: false,\r\n\r\n  // Saved sounds state\r\n  savedSounds: [],\r\n  isSavedSoundsLoaded: false,\r\n  isLoadingSavedSounds: false,\r\n  savedSoundsError: null,\r\n\r\n  setTopSoundEffects: (sounds) => set({ topSoundEffects: sounds }),\r\n  setLoading: (loading) => set({ isLoading: loading }),\r\n  setError: (error) => set({ error }),\r\n  setHasLoaded: (loaded) => set({ hasLoaded: loaded }),\r\n\r\n  // Search actions\r\n  setSearchQuery: (query) => set({ searchQuery: query }),\r\n  setSearchResults: (results) =>\r\n    set({ searchResults: results, currentPage: 1 }),\r\n  setSearching: (searching) => set({ isSearching: searching }),\r\n  setSearchError: (error) => set({ searchError: error }),\r\n  setLastSearchQuery: (query) => set({ lastSearchQuery: query }),\r\n  setScrollPosition: (position) => set({ scrollPosition: position }),\r\n\r\n  // Pagination actions\r\n  setCurrentPage: (page) => set({ currentPage: page }),\r\n  setHasNextPage: (hasNext) => set({ hasNextPage: hasNext }),\r\n  setTotalCount: (count) => set({ totalCount: count }),\r\n  setLoadingMore: (loading) => set({ isLoadingMore: loading }),\r\n  appendSearchResults: (results) =>\r\n    set((state) => ({\r\n      searchResults: [...state.searchResults, ...results],\r\n    })),\r\n  appendTopSounds: (results) =>\r\n    set((state) => ({\r\n      topSoundEffects: [...state.topSoundEffects, ...results],\r\n    })),\r\n  resetPagination: () =>\r\n    set({\r\n      currentPage: 1,\r\n      hasNextPage: false,\r\n      totalCount: 0,\r\n      isLoadingMore: false,\r\n    }),\r\n\r\n  // Saved sounds actions\r\n  loadSavedSounds: async () => {\r\n    if (get().isSavedSoundsLoaded) return;\r\n\r\n    try {\r\n      set({ isLoadingSavedSounds: true, savedSoundsError: null });\r\n      const savedSoundsData = await storageService.loadSavedSounds();\r\n      set({\r\n        savedSounds: savedSoundsData.sounds,\r\n        isSavedSoundsLoaded: true,\r\n        isLoadingSavedSounds: false,\r\n      });\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : \"Failed to load saved sounds\";\r\n      set({\r\n        savedSoundsError: errorMessage,\r\n        isLoadingSavedSounds: false,\r\n      });\r\n      console.error(\"Failed to load saved sounds:\", error);\r\n    }\r\n  },\r\n\r\n  saveSoundEffect: async (soundEffect: SoundEffect) => {\r\n    try {\r\n      await storageService.saveSoundEffect({ soundEffect });\r\n\r\n      // Refresh saved sounds\r\n      const savedSoundsData = await storageService.loadSavedSounds();\r\n      set({ savedSounds: savedSoundsData.sounds });\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : \"Failed to save sound\";\r\n      set({ savedSoundsError: errorMessage });\r\n      toast.error(\"Failed to save sound\");\r\n      console.error(\"Failed to save sound:\", error);\r\n    }\r\n  },\r\n\r\n  removeSavedSound: async (soundId: number) => {\r\n    try {\r\n      await storageService.removeSavedSound({ soundId });\r\n\r\n      // Update local state immediately\r\n      set((state) => ({\r\n        savedSounds: state.savedSounds.filter((sound) => sound.id !== soundId),\r\n      }));\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : \"Failed to remove sound\";\r\n      set({ savedSoundsError: errorMessage });\r\n      toast.error(\"Failed to remove sound\");\r\n      console.error(\"Failed to remove sound:\", error);\r\n    }\r\n  },\r\n\r\n  isSoundSaved: (soundId: number) => {\r\n    const { savedSounds } = get();\r\n    return savedSounds.some((sound) => sound.id === soundId);\r\n  },\r\n\r\n  toggleSavedSound: async (soundEffect: SoundEffect) => {\r\n    const { isSoundSaved, saveSoundEffect, removeSavedSound } = get();\r\n\r\n    if (isSoundSaved(soundEffect.id)) {\r\n      await removeSavedSound(soundEffect.id);\r\n    } else {\r\n      await saveSoundEffect(soundEffect);\r\n    }\r\n  },\r\n\r\n  clearSavedSounds: async () => {\r\n    try {\r\n      await storageService.clearSavedSounds();\r\n      set({\r\n        savedSounds: [],\r\n        savedSoundsError: null,\r\n      });\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : \"Failed to clear saved sounds\";\r\n      set({ savedSoundsError: errorMessage });\r\n      toast.error(\"Failed to clear saved sounds\");\r\n      console.error(\"Failed to clear saved sounds:\", error);\r\n    }\r\n  },\r\n\r\n  addSoundToTimeline: async (sound) => {\r\n    const activeProject = useProjectStore.getState().activeProject;\r\n    if (!activeProject) {\r\n      toast.error(\"No active project\");\r\n      return false;\r\n    }\r\n\r\n    const audioUrl = sound.previewUrl;\r\n    if (!audioUrl) {\r\n      toast.error(\"Sound file not available\");\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(audioUrl);\r\n      if (!response.ok)\r\n        throw new Error(`Failed to download audio: ${response.statusText}`);\r\n\r\n      const blob = await response.blob();\r\n      const file = new File([blob], `${sound.name}.mp3`, {\r\n        type: \"audio/mpeg\",\r\n      });\r\n\r\n      await useMediaStore.getState().addMediaFile(activeProject.id, {\r\n        name: sound.name,\r\n        type: \"audio\",\r\n        file,\r\n        duration: sound.duration,\r\n        url: URL.createObjectURL(file),\r\n      });\r\n\r\n      const mediaItem = useMediaStore\r\n        .getState()\r\n        .mediaFiles.find((item) => item.file === file);\r\n      if (!mediaItem) throw new Error(\"Failed to create media item\");\r\n\r\n      const success = useTimelineStore\r\n        .getState()\r\n        .addElementAtTime(mediaItem, usePlaybackStore.getState().currentTime);\r\n\r\n      if (success) {\r\n        return true;\r\n      }\r\n      throw new Error(\"Failed to add to timeline - check for overlaps\");\r\n    } catch (error) {\r\n      console.error(\"Failed to add sound to timeline:\", error);\r\n      toast.error(\r\n        error instanceof Error\r\n          ? error.message\r\n          : \"Failed to add sound to timeline\",\r\n        { id: `sound-${sound.id}` }\r\n      );\r\n      return false;\r\n    }\r\n  },\r\n}));\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3476, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/stores/stickers-store.ts"],"sourcesContent":["import { create } from \"zustand\";\nimport {\n  getCollections,\n  getCollection,\n  searchIcons,\n  downloadSvgAsText,\n  svgToFile,\n  type IconSet,\n  type CollectionInfo,\n  type IconSearchResult,\n} from \"@/lib/iconify-api\";\nimport { useProjectStore } from \"@/stores/project-store\";\nimport { useMediaStore } from \"@/stores/media-store\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { usePlaybackStore } from \"@/stores/playback-store\";\nimport { TIMELINE_CONSTANTS } from \"@/constants/timeline-constants\";\nimport type { MediaFile } from \"@/types/media\";\n\nexport type StickerCategory = \"all\" | \"general\" | \"brands\" | \"emoji\";\n\ninterface StickersStore {\n  searchQuery: string;\n  selectedCategory: StickerCategory;\n  selectedCollection: string | null;\n  viewMode: \"search\" | \"browse\" | \"collection\";\n\n  collections: Record<string, IconSet>;\n  currentCollection: CollectionInfo | null;\n  searchResults: IconSearchResult | null;\n  recentStickers: string[];\n  isLoadingCollections: boolean;\n  isLoadingCollection: boolean;\n  isSearching: boolean;\n  isDownloading: boolean;\n  addingSticker: string | null;\n\n  setSearchQuery: (query: string) => void;\n  setSelectedCategory: (category: StickerCategory) => void;\n  setSelectedCollection: (collection: string | null) => void;\n  setViewMode: (mode: \"search\" | \"browse\" | \"collection\") => void;\n\n  loadCollections: () => Promise<void>;\n  loadCollection: (prefix: string) => Promise<void>;\n  searchStickers: (query: string) => Promise<void>;\n  downloadSticker: (iconName: string) => Promise<File | null>;\n  addStickerToTimeline: (iconName: string) => Promise<void>;\n\n  addToRecentStickers: (iconName: string) => void;\n  clearRecentStickers: () => void;\n}\n\nconst MAX_RECENT_STICKERS = 50;\n\nexport const useStickersStore = create<StickersStore>((set, get) => ({\n  searchQuery: \"\",\n  selectedCategory: \"all\",\n  selectedCollection: null,\n  viewMode: \"browse\",\n\n  collections: {},\n  currentCollection: null,\n  searchResults: null,\n  recentStickers: [],\n\n  isLoadingCollections: false,\n  isLoadingCollection: false,\n  isSearching: false,\n  isDownloading: false,\n  addingSticker: null,\n\n  setSearchQuery: (query) => set({ searchQuery: query }),\n\n  setSelectedCategory: (category) =>\n    set({\n      selectedCategory: category,\n      viewMode: \"browse\",\n      selectedCollection: null,\n      currentCollection: null,\n    }),\n\n  setSelectedCollection: (collection) => {\n    set({\n      selectedCollection: collection,\n      viewMode: collection ? \"collection\" : \"browse\",\n      currentCollection: null,\n    });\n\n    if (collection) {\n      get().loadCollection(collection);\n    }\n  },\n\n  setViewMode: (mode) => set({ viewMode: mode }),\n\n  loadCollections: async () => {\n    set({ isLoadingCollections: true });\n    try {\n      const collections = await getCollections();\n      set({ collections });\n    } catch (error) {\n      console.error(\"Failed to load collections:\", error);\n    } finally {\n      set({ isLoadingCollections: false });\n    }\n  },\n\n  loadCollection: async (prefix: string) => {\n    set({ isLoadingCollection: true });\n    try {\n      const collection = await getCollection(prefix);\n      set({ currentCollection: collection });\n    } catch (error) {\n      console.error(`Failed to load collection ${prefix}:`, error);\n      set({ currentCollection: null });\n    } finally {\n      set({ isLoadingCollection: false });\n    }\n  },\n\n  searchStickers: async (query: string) => {\n    if (!query.trim()) {\n      set({ searchResults: null, viewMode: \"browse\" });\n      return;\n    }\n\n    const { selectedCategory } = get();\n\n    set({ isSearching: true, viewMode: \"search\" });\n    try {\n      let category: string | undefined;\n\n      if (selectedCategory !== \"all\") {\n        if (selectedCategory === \"general\") {\n          category = \"General\";\n        } else if (selectedCategory === \"brands\") {\n          category = \"Brands / Social\";\n        } else if (selectedCategory === \"emoji\") {\n          category = \"Emoji\";\n        }\n      }\n\n      const results = await searchIcons(query, 100, undefined, category);\n      set({ searchResults: results });\n    } catch (error) {\n      console.error(\"Search failed:\", error);\n      set({ searchResults: null });\n    } finally {\n      set({ isSearching: false });\n    }\n  },\n\n  downloadSticker: async (iconName: string) => {\n    set({ isDownloading: true });\n    try {\n      const svgText = await downloadSvgAsText(iconName, {\n        width: 200,\n        height: 200,\n      });\n\n      const fileName = `${iconName.replace(\":\", \"-\")}.svg`;\n      const file = svgToFile(svgText, fileName);\n\n      get().addToRecentStickers(iconName);\n\n      return file;\n    } catch (error) {\n      console.error(`Failed to download sticker ${iconName}:`, error);\n      return null;\n    } finally {\n      set({ isDownloading: false });\n    }\n  },\n\n  addStickerToTimeline: async (iconName: string) => {\n    set({ addingSticker: iconName });\n    try {\n      const { activeProject } = useProjectStore.getState();\n      if (!activeProject) {\n        throw new Error(\"No active project\");\n      }\n\n      const file = await get().downloadSticker(iconName);\n      if (!file) {\n        throw new Error(\"Failed to download sticker\");\n      }\n\n      const mediaItem: Omit<MediaFile, \"id\"> = {\n        name: iconName.replace(\":\", \"-\"),\n        type: \"image\",\n        file,\n        url: URL.createObjectURL(file),\n        width: 200,\n        height: 200,\n        duration: TIMELINE_CONSTANTS.DEFAULT_IMAGE_DURATION,\n        ephemeral: false,\n      };\n\n      const { addMediaFile } = useMediaStore.getState();\n      await addMediaFile(activeProject.id, mediaItem);\n\n      const added = useMediaStore\n        .getState()\n        .mediaFiles.find(\n          (m) => m.url === mediaItem.url && m.name === mediaItem.name\n        );\n      if (!added) {\n        throw new Error(\"Sticker not in media store\");\n      }\n\n      const { currentTime } = usePlaybackStore.getState();\n      const { addElementAtTime } = useTimelineStore.getState();\n      addElementAtTime(added, currentTime);\n    } finally {\n      set({ addingSticker: null });\n    }\n  },\n\n  addToRecentStickers: (iconName: string) => {\n    set((state) => {\n      const recent = [\n        iconName,\n        ...state.recentStickers.filter((s) => s !== iconName),\n      ];\n      return {\n        recentStickers: recent.slice(0, MAX_RECENT_STICKERS),\n      };\n    });\n  },\n\n  clearRecentStickers: () => set({ recentStickers: [] }),\n}));\n"],"names":[],"mappings":";;;AAAA;AACA;AAUA;AACA;AACA;AACA;AACA;;;;;;;;AAoCA,MAAM,sBAAsB;AAErB,MAAM,mBAAmB,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD,EAAiB,CAAC,KAAK,MAAQ,CAAC;QACnE,aAAa;QACb,kBAAkB;QAClB,oBAAoB;QACpB,UAAU;QAEV,aAAa,CAAC;QACd,mBAAmB;QACnB,eAAe;QACf,gBAAgB,EAAE;QAElB,sBAAsB;QACtB,qBAAqB;QACrB,aAAa;QACb,eAAe;QACf,eAAe;QAEf,gBAAgB,CAAC,QAAU,IAAI;gBAAE,aAAa;YAAM;QAEpD,qBAAqB,CAAC,WACpB,IAAI;gBACF,kBAAkB;gBAClB,UAAU;gBACV,oBAAoB;gBACpB,mBAAmB;YACrB;QAEF,uBAAuB,CAAC;YACtB,IAAI;gBACF,oBAAoB;gBACpB,UAAU,aAAa,eAAe;gBACtC,mBAAmB;YACrB;YAEA,IAAI,YAAY;gBACd,MAAM,cAAc,CAAC;YACvB;QACF;QAEA,aAAa,CAAC,OAAS,IAAI;gBAAE,UAAU;YAAK;QAE5C,iBAAiB;YACf,IAAI;gBAAE,sBAAsB;YAAK;YACjC,IAAI;gBACF,MAAM,cAAc,MAAM,CAAA,GAAA,2IAAA,CAAA,iBAAc,AAAD;gBACvC,IAAI;oBAAE;gBAAY;YACpB,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,+BAA+B;YAC/C,SAAU;gBACR,IAAI;oBAAE,sBAAsB;gBAAM;YACpC;QACF;QAEA,gBAAgB,OAAO;YACrB,IAAI;gBAAE,qBAAqB;YAAK;YAChC,IAAI;gBACF,MAAM,aAAa,MAAM,CAAA,GAAA,2IAAA,CAAA,gBAAa,AAAD,EAAE;gBACvC,IAAI;oBAAE,mBAAmB;gBAAW;YACtC,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,CAAC,0BAA0B,EAAE,OAAO,CAAC,CAAC,EAAE;gBACtD,IAAI;oBAAE,mBAAmB;gBAAK;YAChC,SAAU;gBACR,IAAI;oBAAE,qBAAqB;gBAAM;YACnC;QACF;QAEA,gBAAgB,OAAO;YACrB,IAAI,CAAC,MAAM,IAAI,IAAI;gBACjB,IAAI;oBAAE,eAAe;oBAAM,UAAU;gBAAS;gBAC9C;YACF;YAEA,MAAM,EAAE,gBAAgB,EAAE,GAAG;YAE7B,IAAI;gBAAE,aAAa;gBAAM,UAAU;YAAS;YAC5C,IAAI;gBACF,IAAI;gBAEJ,IAAI,qBAAqB,OAAO;oBAC9B,IAAI,qBAAqB,WAAW;wBAClC,WAAW;oBACb,OAAO,IAAI,qBAAqB,UAAU;wBACxC,WAAW;oBACb,OAAO,IAAI,qBAAqB,SAAS;wBACvC,WAAW;oBACb;gBACF;gBAEA,MAAM,UAAU,MAAM,CAAA,GAAA,2IAAA,CAAA,cAAW,AAAD,EAAE,OAAO,KAAK,WAAW;gBACzD,IAAI;oBAAE,eAAe;gBAAQ;YAC/B,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,kBAAkB;gBAChC,IAAI;oBAAE,eAAe;gBAAK;YAC5B,SAAU;gBACR,IAAI;oBAAE,aAAa;gBAAM;YAC3B;QACF;QAEA,iBAAiB,OAAO;YACtB,IAAI;gBAAE,eAAe;YAAK;YAC1B,IAAI;gBACF,MAAM,UAAU,MAAM,CAAA,GAAA,2IAAA,CAAA,oBAAiB,AAAD,EAAE,UAAU;oBAChD,OAAO;oBACP,QAAQ;gBACV;gBAEA,MAAM,WAAW,GAAG,SAAS,OAAO,CAAC,KAAK,KAAK,IAAI,CAAC;gBACpD,MAAM,OAAO,CAAA,GAAA,2IAAA,CAAA,YAAS,AAAD,EAAE,SAAS;gBAEhC,MAAM,mBAAmB,CAAC;gBAE1B,OAAO;YACT,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,CAAC,2BAA2B,EAAE,SAAS,CAAC,CAAC,EAAE;gBACzD,OAAO;YACT,SAAU;gBACR,IAAI;oBAAE,eAAe;gBAAM;YAC7B;QACF;QAEA,sBAAsB,OAAO;YAC3B,IAAI;gBAAE,eAAe;YAAS;YAC9B,IAAI;gBACF,MAAM,EAAE,aAAa,EAAE,GAAG,gJAAA,CAAA,kBAAe,CAAC,QAAQ;gBAClD,IAAI,CAAC,eAAe;oBAClB,MAAM,IAAI,MAAM;gBAClB;gBAEA,MAAM,OAAO,MAAM,MAAM,eAAe,CAAC;gBACzC,IAAI,CAAC,MAAM;oBACT,MAAM,IAAI,MAAM;gBAClB;gBAEA,MAAM,YAAmC;oBACvC,MAAM,SAAS,OAAO,CAAC,KAAK;oBAC5B,MAAM;oBACN;oBACA,KAAK,IAAI,eAAe,CAAC;oBACzB,OAAO;oBACP,QAAQ;oBACR,UAAU,wJAAA,CAAA,qBAAkB,CAAC,sBAAsB;oBACnD,WAAW;gBACb;gBAEA,MAAM,EAAE,YAAY,EAAE,GAAG,8IAAA,CAAA,gBAAa,CAAC,QAAQ;gBAC/C,MAAM,aAAa,cAAc,EAAE,EAAE;gBAErC,MAAM,QAAQ,8IAAA,CAAA,gBAAa,CACxB,QAAQ,GACR,UAAU,CAAC,IAAI,CACd,CAAC,IAAM,EAAE,GAAG,KAAK,UAAU,GAAG,IAAI,EAAE,IAAI,KAAK,UAAU,IAAI;gBAE/D,IAAI,CAAC,OAAO;oBACV,MAAM,IAAI,MAAM;gBAClB;gBAEA,MAAM,EAAE,WAAW,EAAE,GAAG,iJAAA,CAAA,mBAAgB,CAAC,QAAQ;gBACjD,MAAM,EAAE,gBAAgB,EAAE,GAAG,iJAAA,CAAA,mBAAgB,CAAC,QAAQ;gBACtD,iBAAiB,OAAO;YAC1B,SAAU;gBACR,IAAI;oBAAE,eAAe;gBAAK;YAC5B;QACF;QAEA,qBAAqB,CAAC;YACpB,IAAI,CAAC;gBACH,MAAM,SAAS;oBACb;uBACG,MAAM,cAAc,CAAC,MAAM,CAAC,CAAC,IAAM,MAAM;iBAC7C;gBACD,OAAO;oBACL,gBAAgB,OAAO,KAAK,CAAC,GAAG;gBAClC;YACF;QACF;QAEA,qBAAqB,IAAM,IAAI;gBAAE,gBAAgB,EAAE;YAAC;IACtD,CAAC","debugId":null}},
    {"offset": {"line": 3685, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/stores/editor-store.ts"],"sourcesContent":["import { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { CanvasPreset } from \"@/types/editor\";\n\nexport type PlatformLayout = \"tiktok\";\n\nexport const PLATFORM_LAYOUTS: Record<PlatformLayout, string> = {\n  tiktok: \"TikTok\",\n};\n\ninterface LayoutGuideSettings {\n  platform: PlatformLayout | null;\n}\n\ninterface EditorState {\n  // Loading states\n  isInitializing: boolean;\n  isPanelsReady: boolean;\n\n  // Editor UI settings\n  canvasPresets: CanvasPreset[];\n  layoutGuide: LayoutGuideSettings;\n\n  // Actions\n  setInitializing: (loading: boolean) => void;\n  setPanelsReady: (ready: boolean) => void;\n  initializeApp: () => Promise<void>;\n  setLayoutGuide: (settings: Partial<LayoutGuideSettings>) => void;\n  toggleLayoutGuide: (platform: PlatformLayout) => void;\n}\n\nconst DEFAULT_CANVAS_PRESETS: CanvasPreset[] = [\n  { name: \"16:9\", width: 1920, height: 1080 },\n  { name: \"9:16\", width: 1080, height: 1920 },\n  { name: \"1:1\", width: 1080, height: 1080 },\n  { name: \"4:3\", width: 1440, height: 1080 },\n];\n\nexport const useEditorStore = create<EditorState>()(\n  persist(\n    (set) => ({\n      // Initial states\n      isInitializing: true,\n      isPanelsReady: false,\n      canvasPresets: DEFAULT_CANVAS_PRESETS,\n      layoutGuide: {\n        platform: null,\n      },\n\n      // Actions\n      setInitializing: (loading) => {\n        set({ isInitializing: loading });\n      },\n\n      setPanelsReady: (ready) => {\n        set({ isPanelsReady: ready });\n      },\n\n      initializeApp: async () => {\n        console.log(\"Initializing video editor...\");\n        set({ isInitializing: true, isPanelsReady: false });\n\n        set({ isPanelsReady: true, isInitializing: false });\n        console.log(\"Video editor ready\");\n      },\n\n      setLayoutGuide: (settings) => {\n        set((state) => ({\n          layoutGuide: {\n            ...state.layoutGuide,\n            ...settings,\n          },\n        }));\n      },\n\n      toggleLayoutGuide: (platform) => {\n        set((state) => ({\n          layoutGuide: {\n            platform: state.layoutGuide.platform === platform ? null : platform,\n          },\n        }));\n      },\n    }),\n    {\n      name: \"editor-settings\",\n      partialize: (state) => ({\n        layoutGuide: state.layoutGuide,\n      }),\n    }\n  )\n);\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAKO,MAAM,mBAAmD;IAC9D,QAAQ;AACV;AAuBA,MAAM,yBAAyC;IAC7C;QAAE,MAAM;QAAQ,OAAO;QAAM,QAAQ;IAAK;IAC1C;QAAE,MAAM;QAAQ,OAAO;QAAM,QAAQ;IAAK;IAC1C;QAAE,MAAM;QAAO,OAAO;QAAM,QAAQ;IAAK;IACzC;QAAE,MAAM;QAAO,OAAO;QAAM,QAAQ;IAAK;CAC1C;AAEM,MAAM,iBAAiB,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD,IACjC,CAAA,GAAA,oNAAA,CAAA,UAAO,AAAD,EACJ,CAAC,MAAQ,CAAC;QACR,iBAAiB;QACjB,gBAAgB;QAChB,eAAe;QACf,eAAe;QACf,aAAa;YACX,UAAU;QACZ;QAEA,UAAU;QACV,iBAAiB,CAAC;YAChB,IAAI;gBAAE,gBAAgB;YAAQ;QAChC;QAEA,gBAAgB,CAAC;YACf,IAAI;gBAAE,eAAe;YAAM;QAC7B;QAEA,eAAe;YACb,QAAQ,GAAG,CAAC;YACZ,IAAI;gBAAE,gBAAgB;gBAAM,eAAe;YAAM;YAEjD,IAAI;gBAAE,eAAe;gBAAM,gBAAgB;YAAM;YACjD,QAAQ,GAAG,CAAC;QACd;QAEA,gBAAgB,CAAC;YACf,IAAI,CAAC,QAAU,CAAC;oBACd,aAAa;wBACX,GAAG,MAAM,WAAW;wBACpB,GAAG,QAAQ;oBACb;gBACF,CAAC;QACH;QAEA,mBAAmB,CAAC;YAClB,IAAI,CAAC,QAAU,CAAC;oBACd,aAAa;wBACX,UAAU,MAAM,WAAW,CAAC,QAAQ,KAAK,WAAW,OAAO;oBAC7D;gBACF,CAAC;QACH;IACF,CAAC,GACD;IACE,MAAM;IACN,YAAY,CAAC,QAAU,CAAC;YACtB,aAAa,MAAM,WAAW;QAChC,CAAC;AACH","debugId":null}},
    {"offset": {"line": 3774, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/stores/text-properties-store.ts"],"sourcesContent":["import { create } from \"zustand\";\r\nimport { persist } from \"zustand/middleware\";\r\n\r\nexport type TextPropertiesTab = \"transform\" | \"style\";\r\n\r\nexport interface TextPropertiesTabMeta {\r\n  value: TextPropertiesTab;\r\n  label: string;\r\n}\r\n\r\nexport const TEXT_PROPERTIES_TABS: ReadonlyArray<TextPropertiesTabMeta> = [\r\n  { value: \"transform\", label: \"Transform\" },\r\n  { value: \"style\", label: \"Style\" },\r\n] as const;\r\n\r\nexport function isTextPropertiesTab(value: string): value is TextPropertiesTab {\r\n  return TEXT_PROPERTIES_TABS.some((t) => t.value === value);\r\n}\r\n\r\ninterface TextPropertiesState {\r\n  activeTab: TextPropertiesTab;\r\n  setActiveTab: (tab: TextPropertiesTab) => void;\r\n}\r\n\r\nexport const useTextPropertiesStore = create<TextPropertiesState>()(\r\n  persist(\r\n    (set) => ({\r\n      activeTab: \"transform\",\r\n      setActiveTab: (tab) => set({ activeTab: tab }),\r\n    }),\r\n    { name: \"text-properties\" }\r\n  )\r\n);\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;;;AASO,MAAM,uBAA6D;IACxE;QAAE,OAAO;QAAa,OAAO;IAAY;IACzC;QAAE,OAAO;QAAS,OAAO;IAAQ;CAClC;AAEM,SAAS,oBAAoB,KAAa;IAC/C,OAAO,qBAAqB,IAAI,CAAC,CAAC,IAAM,EAAE,KAAK,KAAK;AACtD;AAOO,MAAM,yBAAyB,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD,IACzC,CAAA,GAAA,oNAAA,CAAA,UAAO,AAAD,EACJ,CAAC,MAAQ,CAAC;QACR,WAAW;QACX,cAAc,CAAC,MAAQ,IAAI;gBAAE,WAAW;YAAI;IAC9C,CAAC,GACD;IAAE,MAAM;AAAkB","debugId":null}},
    {"offset": {"line": 3808, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/stores/keybindings-store.ts"],"sourcesContent":["\"use client\";\n\nimport { create } from \"zustand\";\nimport { persist } from \"zustand/middleware\";\nimport { ActionWithOptionalArgs } from \"@/constants/actions\";\nimport { isAppleDevice, isDOMElement, isTypableElement } from \"@/lib/utils\";\nimport { KeybindingConfig, ShortcutKey } from \"@/types/keybinding\";\n\n// Default keybindings configuration\nexport const defaultKeybindings: KeybindingConfig = {\n  space: \"toggle-play\",\n  j: \"seek-backward\",\n  k: \"toggle-play\",\n  l: \"seek-forward\",\n  left: \"frame-step-backward\",\n  right: \"frame-step-forward\",\n  \"shift+left\": \"jump-backward\",\n  \"shift+right\": \"jump-forward\",\n  home: \"goto-start\",\n  enter: \"goto-start\",\n  end: \"goto-end\",\n  s: \"split-element\",\n  n: \"toggle-snapping\",\n  \"ctrl+a\": \"select-all\",\n  \"ctrl+d\": \"duplicate-selected\",\n  \"ctrl+c\": \"copy-selected\",\n  \"ctrl+v\": \"paste-selected\",\n  \"ctrl+z\": \"undo\",\n  \"ctrl+shift+z\": \"redo\",\n  \"ctrl+y\": \"redo\",\n  delete: \"delete-selected\",\n  backspace: \"delete-selected\",\n};\n\nexport interface KeybindingConflict {\n  key: ShortcutKey;\n  existingAction: ActionWithOptionalArgs;\n  newAction: ActionWithOptionalArgs;\n}\n\ninterface KeybindingsState {\n  keybindings: KeybindingConfig;\n  isCustomized: boolean;\n  keybindingsEnabled: boolean;\n  isRecording: boolean;\n\n  // Actions\n  updateKeybinding: (key: ShortcutKey, action: ActionWithOptionalArgs) => void;\n  removeKeybinding: (key: ShortcutKey) => void;\n  resetToDefaults: () => void;\n  importKeybindings: (config: KeybindingConfig) => void;\n  exportKeybindings: () => KeybindingConfig;\n  enableKeybindings: () => void;\n  disableKeybindings: () => void;\n  setIsRecording: (isRecording: boolean) => void;\n\n  // Validation\n  validateKeybinding: (\n    key: ShortcutKey,\n    action: ActionWithOptionalArgs\n  ) => KeybindingConflict | null;\n  getKeybindingsForAction: (action: ActionWithOptionalArgs) => ShortcutKey[];\n\n  // Utility\n  getKeybindingString: (ev: KeyboardEvent) => ShortcutKey | null;\n}\n\nexport const useKeybindingsStore = create<KeybindingsState>()(\n  persist(\n    (set, get) => ({\n      keybindings: { ...defaultKeybindings },\n      isCustomized: false,\n      keybindingsEnabled: true,\n      isRecording: false,\n\n      updateKeybinding: (key: ShortcutKey, action: ActionWithOptionalArgs) => {\n        set((state) => {\n          const newKeybindings = { ...state.keybindings };\n          newKeybindings[key] = action;\n\n          return {\n            keybindings: newKeybindings,\n            isCustomized: true,\n          };\n        });\n      },\n\n      removeKeybinding: (key: ShortcutKey) => {\n        set((state) => {\n          const newKeybindings = { ...state.keybindings };\n          delete newKeybindings[key];\n\n          return {\n            keybindings: newKeybindings,\n            isCustomized: true,\n          };\n        });\n      },\n\n      resetToDefaults: () => {\n        set({\n          keybindings: { ...defaultKeybindings },\n          isCustomized: false,\n        });\n      },\n\n      enableKeybindings: () => {\n        set({ keybindingsEnabled: true });\n      },\n\n      disableKeybindings: () => {\n        set({ keybindingsEnabled: false });\n      },\n\n      importKeybindings: (config: KeybindingConfig) => {\n        // Validate all keys and actions\n        for (const [key, action] of Object.entries(config)) {\n          // Validate the key format\n          if (typeof key !== \"string\" || key.length === 0) {\n            throw new Error(`Invalid key format: ${key}`);\n          }\n        }\n        set({\n          keybindings: { ...config },\n          isCustomized: true,\n        });\n      },\n\n      exportKeybindings: () => {\n        return get().keybindings;\n      },\n\n      validateKeybinding: (\n        key: ShortcutKey,\n        action: ActionWithOptionalArgs\n      ) => {\n        const { keybindings } = get();\n        const existingAction = keybindings[key];\n\n        if (existingAction && existingAction !== action) {\n          return {\n            key,\n            existingAction,\n            newAction: action,\n          };\n        }\n\n        return null;\n      },\n      setIsRecording: (isRecording: boolean) => {\n        set({ isRecording });\n      },\n\n      getKeybindingsForAction: (action: ActionWithOptionalArgs) => {\n        const { keybindings } = get();\n        return Object.keys(keybindings).filter(\n          (key) => keybindings[key as ShortcutKey] === action\n        ) as ShortcutKey[];\n      },\n\n      getKeybindingString: (ev: KeyboardEvent) => {\n        return generateKeybindingString(ev) as ShortcutKey | null;\n      },\n    }),\n    {\n      name: \"opencut-keybindings\",\n      version: 2,\n    }\n  )\n);\n\n// Utility functions\nfunction generateKeybindingString(ev: KeyboardEvent): ShortcutKey | null {\n  const target = ev.target;\n\n  // We may or may not have a modifier key\n  const modifierKey = getActiveModifier(ev);\n\n  // We will always have a non-modifier key\n  const key = getPressedKey(ev);\n  if (!key) return null;\n\n  // All key combos backed by modifiers are valid shortcuts (whether currently typing or not)\n  if (modifierKey) {\n    // If the modifier is shift and the target is an input, we ignore\n    if (\n      modifierKey === \"shift\" &&\n      isDOMElement(target) &&\n      isTypableElement(target)\n    ) {\n      return null;\n    }\n\n    return `${modifierKey}+${key}` as ShortcutKey;\n  }\n\n  // no modifier key here then we do not do anything while on input\n  if (isDOMElement(target) && isTypableElement(target)) return null;\n\n  // single key while not input\n  return `${key}` as ShortcutKey;\n}\n\nfunction getPressedKey(ev: KeyboardEvent): string | null {\n  // Sometimes the property code is not available on the KeyboardEvent object\n  const key = (ev.key ?? \"\").toLowerCase();\n  const code = ev.code ?? \"\";\n\n  if (code === \"Space\" || key === \" \" || key === \"spacebar\" || key === \"space\")\n    return \"space\";\n\n  // Check arrow keys\n  if (key.startsWith(\"arrow\")) {\n    return key.slice(5);\n  }\n\n  // Check for special keys\n  if (key === \"tab\") return \"tab\";\n  if (key === \"home\") return \"home\";\n  if (key === \"end\") return \"end\";\n  if (key === \"delete\") return \"delete\";\n  if (key === \"backspace\") return \"backspace\";\n\n  // Check letter keys\n  if (code.startsWith(\"Key\")) {\n    const letter = code.slice(3).toLowerCase();\n    if (letter.length === 1 && letter >= \"a\" && letter <= \"z\") {\n      return letter;\n    }\n  }\n\n  // Check number keys using physical position for AZERTY support\n  if (code.startsWith(\"Digit\")) {\n    const digit = code.slice(5);\n    if (digit.length === 1 && digit >= \"0\" && digit <= \"9\") {\n      return digit;\n    }\n  }\n\n  // Fallback for other layouts\n  const isDigit = key.length === 1 && key >= \"0\" && key <= \"9\";\n  if (isDigit) return key;\n\n  // Check if slash, period or enter\n  if (key === \"/\" || key === \".\" || key === \"enter\") return key;\n\n  // If no other cases match, this is not a valid key\n  return null;\n}\n\nfunction getActiveModifier(ev: KeyboardEvent): string | null {\n  const modifierKeys = {\n    ctrl: isAppleDevice() ? ev.metaKey : ev.ctrlKey,\n    alt: ev.altKey,\n    shift: ev.shiftKey,\n  };\n\n  // active modifier: ctrl | alt | ctrl+alt | ctrl+shift | ctrl+alt+shift | alt+shift\n  // modiferKeys object's keys are sorted to match the above order\n  const activeModifier = Object.keys(modifierKeys)\n    .filter((key) => modifierKeys[key as keyof typeof modifierKeys])\n    .join(\"+\");\n\n  return activeModifier === \"\" ? null : activeModifier;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4011, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/data/colors/solid.ts"],"sourcesContent":["export const colors = [\n  \"#ffffff\",\n  \"#000000\",\n  \"#ffe2e2\",\n  \"#ffc9c9\",\n  \"#ffa2a2\",\n  \"#ff6467\",\n  \"#fb2c36\",\n  \"#e7000b\",\n  \"#c10007\",\n  \"#9f0712\",\n  \"#82181a\",\n  \"#460809\",\n  \"#fff7ed\",\n  \"#ffedd4\",\n  \"#ffd6a7\",\n  \"#ffb86a\",\n  \"#ff8904\",\n  \"#ff6900\",\n  \"#f54900\",\n  \"#ca3500\",\n  \"#9f2d00\",\n  \"#7e2a0c\",\n  \"#441306\",\n  \"#fffbeb\",\n  \"#fef3c6\",\n  \"#fee685\",\n  \"#ffd230\",\n  \"#ffb900\",\n  \"#fe9a00\",\n  \"#e17100\",\n  \"#bb4d00\",\n  \"#973c00\",\n  \"#7b3306\",\n  \"#461901\",\n  \"#fefce8\",\n  \"#fef9c2\",\n  \"#fff085\",\n  \"#ffdf20\",\n  \"#fdc700\",\n  \"#f0b100\",\n  \"#d08700\",\n  \"#a65f00\",\n  \"#894b00\",\n  \"#733e0a\",\n  \"#432004\",\n  \"#f7fee7\",\n  \"#ecfcca\",\n  \"#d8f999\",\n  \"#bbf451\",\n  \"#9ae600\",\n  \"#7ccf00\",\n  \"#5ea500\",\n  \"#497d00\",\n  \"#3c6300\",\n  \"#35530e\",\n  \"#192e03\",\n  \"#f0fdf4\",\n  \"#dcfce7\",\n  \"#b9f8cf\",\n  \"#7bf1a8\",\n  \"#05df72\",\n  \"#00c950\",\n  \"#00a63e\",\n  \"#008236\",\n  \"#016630\",\n  \"#0d542b\",\n  \"#032e15\",\n  \"#ecfdf5\",\n  \"#d0fae5\",\n  \"#a4f4cf\",\n  \"#5ee9b5\",\n  \"#00d492\",\n  \"#00bc7d\",\n  \"#009966\",\n  \"#007a55\",\n  \"#006045\",\n  \"#004f3b\",\n  \"#002c22\",\n  \"#f0fdfa\",\n  \"#cbfbf1\",\n  \"#96f7e4\",\n  \"#46ecd5\",\n  \"#00d5be\",\n  \"#00bba7\",\n  \"#009689\",\n  \"#00786f\",\n  \"#005f5a\",\n  \"#0b4f4a\",\n  \"#022f2e\",\n  \"#ecfeff\",\n  \"#cefafe\",\n  \"#a2f4fd\",\n  \"#53eafd\",\n  \"#00d3f2\",\n  \"#00b8db\",\n  \"#0092b8\",\n  \"#007595\",\n  \"#005f78\",\n  \"#104e64\",\n  \"#053345\",\n  \"#f0f9ff\",\n  \"#dff2fe\",\n  \"#b8e6fe\",\n  \"#74d4ff\",\n  \"#00bcff\",\n  \"#00a6f4\",\n  \"#0084d1\",\n  \"#0069a8\",\n  \"#00598a\",\n  \"#024a70\",\n  \"#052f4a\",\n  \"#eff6ff\",\n  \"#dbeafe\",\n  \"#bedbff\",\n  \"#8ec5ff\",\n  \"#51a2ff\",\n  \"#2b7fff\",\n  \"#155dfc\",\n  \"#1447e6\",\n  \"#193cb8\",\n  \"#1c398e\",\n  \"#162456\",\n  \"#eef2ff\",\n  \"#e0e7ff\",\n  \"#c6d2ff\",\n  \"#a3b3ff\",\n  \"#7c86ff\",\n  \"#615fff\",\n  \"#4f39f6\",\n  \"#432dd7\",\n  \"#372aac\",\n  \"#312c85\",\n  \"#1e1a4d\",\n  \"#f5f3ff\",\n  \"#ede9fe\",\n  \"#ddd6ff\",\n  \"#c4b4ff\",\n  \"#a684ff\",\n  \"#8e51ff\",\n  \"#7f22fe\",\n  \"#7008e7\",\n  \"#5d0ec0\",\n  \"#4d179a\",\n  \"#2f0d68\",\n  \"#faf5ff\",\n  \"#f3e8ff\",\n  \"#e9d4ff\",\n  \"#dab2ff\",\n  \"#c27aff\",\n  \"#ad46ff\",\n  \"#9810fa\",\n  \"#8200db\",\n  \"#6e11b0\",\n  \"#59168b\",\n  \"#3c0366\",\n  \"#fdf4ff\",\n  \"#fae8ff\",\n  \"#f6cfff\",\n  \"#f4a8ff\",\n  \"#ed6aff\",\n  \"#e12afb\",\n  \"#c800de\",\n  \"#a800b7\",\n  \"#8a0194\",\n  \"#721378\",\n  \"#4b004f\",\n  \"#fdf2f8\",\n  \"#fce7f3\",\n  \"#fccee8\",\n  \"#fda5d5\",\n  \"#fb64b6\",\n  \"#f6339a\",\n  \"#e60076\",\n  \"#c6005c\",\n  \"#a3004c\",\n  \"#861043\",\n  \"#510424\",\n  \"#fff1f2\",\n  \"#ffe4e6\",\n  \"#ffccd3\",\n  \"#ffa1ad\",\n  \"#ff637e\",\n  \"#ff2056\",\n  \"#ec003f\",\n  \"#c70036\",\n  \"#a50036\",\n  \"#8b0836\",\n  \"#4d0218\",\n  \"#f8fafc\",\n  \"#f1f5f9\",\n  \"#e2e8f0\",\n  \"#cad5e2\",\n  \"#90a1b9\",\n  \"#62748e\",\n  \"#45556c\",\n  \"#314158\",\n  \"#1d293d\",\n  \"#0f172b\",\n  \"#020618\",\n  \"#f9fafb\",\n  \"#f3f4f6\",\n  \"#e5e7eb\",\n  \"#d1d5dc\",\n  \"#99a1af\",\n  \"#6a7282\",\n  \"#4a5565\",\n  \"#364153\",\n  \"#1e2939\",\n  \"#101828\",\n  \"#030712\",\n  \"#fafafa\",\n  \"#f4f4f5\",\n  \"#e4e4e7\",\n  \"#d4d4d8\",\n  \"#9f9fa9\",\n  \"#71717b\",\n  \"#52525c\",\n  \"#3f3f46\",\n  \"#27272a\",\n  \"#18181b\",\n  \"#09090b\",\n  \"#f5f5f5\",\n  \"#e5e5e5\",\n  \"#d4d4d4\",\n  \"#a1a1a1\",\n  \"#737373\",\n  \"#525252\",\n  \"#404040\",\n  \"#262626\",\n  \"#171717\",\n  \"#0a0a0a\",\n  \"#fafaf9\",\n  \"#f5f5f4\",\n  \"#e7e5e4\",\n  \"#d6d3d1\",\n  \"#a6a09b\",\n  \"#79716b\",\n  \"#57534d\",\n  \"#44403b\",\n  \"#292524\",\n  \"#1c1917\",\n  \"#0c0a09\",\n];\n"],"names":[],"mappings":";;;AAAO,MAAM,SAAS;IACpB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD","debugId":null}},
    {"offset": {"line": 4262, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/data/colors/pattern-craft.ts"],"sourcesContent":["// These are the gradients from Pattern Craft (https://patterncraft.fun/)\n\nexport const patternCraftGradients = [\n  // Dreamy Sky Pink Glow\n  \"radial-gradient(circle at 30% 70%, rgba(173, 216, 230, 0.35), transparent 60%), radial-gradient(circle at 70% 30%, rgba(255, 182, 193, 0.4), transparent 60%)\",\n\n  // Soft Warm Pastel Texture\n  \"radial-gradient(circle at 20% 80%, rgba(255, 182, 153, 0.3) 0%, transparent 50%), radial-gradient(circle at 80% 20%, rgba(255, 244, 214, 0.5) 0%, transparent 50%), radial-gradient(circle at 40% 40%, rgba(255, 182, 153, 0.1) 0%, transparent 50%), #fff8f0\",\n\n  // Warm Soft Coral & Cream\n  \"radial-gradient(circle at 20% 80%, rgba(255, 160, 146, 0.25) 0%, transparent 50%), radial-gradient(circle at 80% 20%, rgba(255, 244, 228, 0.3) 0%, transparent 50%), radial-gradient(circle at 40% 40%, rgba(255, 160, 146, 0.15) 0%, transparent 50%), #fef9f7\",\n\n  // Soft Green Glow\n  \"radial-gradient(circle at center, #8FFFB0, transparent), white\",\n\n  // Purple Glow Right\n  \"radial-gradient(circle at top right, rgba(173, 109, 244, 0.5), transparent 70%)\",\n\n  // Teal Glow Right\n  \"radial-gradient(circle at top right, rgba(56, 193, 182, 0.5), transparent 70%)\",\n\n  // Warm Orange Glow Right\n  \"radial-gradient(circle at top right, rgba(255, 140, 60, 0.5), transparent 70%)\",\n\n  // Cool Blue Glow Right\n  \"radial-gradient(circle at top right, rgba(70, 130, 180, 0.5), transparent 70%)\",\n\n  // Purple Glow Left\n  \"radial-gradient(circle at top left, rgba(173, 109, 244, 0.5), transparent 70%)\",\n\n  // Pastel Wave\n  \"linear-gradient(120deg, #d5c5ff 0%, #a7f3d0 50%, #f0f0f0 100%)\",\n];\n"],"names":[],"mappings":"AAAA,yEAAyE;;;;AAElE,MAAM,wBAAwB;IACnC,uBAAuB;IACvB;IAEA,2BAA2B;IAC3B;IAEA,0BAA0B;IAC1B;IAEA,kBAAkB;IAClB;IAEA,oBAAoB;IACpB;IAEA,kBAAkB;IAClB;IAEA,yBAAyB;IACzB;IAEA,uBAAuB;IACvB;IAEA,mBAAmB;IACnB;IAEA,cAAc;IACd;CACD","debugId":null}},
    {"offset": {"line": 4292, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/data/colors/syntax-ui.tsx"],"sourcesContent":["// These are the gradients from Syntax UI (https://syntaxui.com/effects/gradients)\n\nexport const syntaxUIGradients = [\n  // Cyan to Blue gradients\n  \"linear-gradient(to right, #22d3ee, #0ea5e9, #0284c7)\",\n  \"linear-gradient(to right, #bfdbfe, #a5f3fc)\",\n  \"linear-gradient(to right, #22d3ee, #0ea5e9, #0284c7)\",\n\n  // Purple gradients\n  \"linear-gradient(to right, #e9d5ff, #d8b4fe, #c084fc)\",\n  \"linear-gradient(to right, #c4b5fd, #a78bfa, #8b5cf6)\",\n\n  // Blue gradients\n  \"linear-gradient(to right, #93c5fd, #60a5fa, #3b82f6)\",\n  \"linear-gradient(to right, #93c5fd, #60a5fa, #3b82f6)\",\n\n  // Green gradients\n  \"linear-gradient(to right, #6ee7b7, #34d399, #10b981)\",\n  \"linear-gradient(to right, #d1fae5, #a7f3d0, #6ee7b7)\",\n\n  // Red gradient\n  \"linear-gradient(to right, #fca5a5, #f87171, #ef4444)\",\n\n  // Yellow/Orange gradient\n  \"linear-gradient(to right, #fde68a, #fbbf24, #f59e0b)\",\n\n  // Pink gradient\n  \"linear-gradient(to right, #fbcfe8, #f9a8d4, #f472b6)\",\n\n  // Neon radial gradient\n  \"radial-gradient(circle at bottom left, #ff00ff, #00ffff)\",\n];\n"],"names":[],"mappings":"AAAA,kFAAkF;;;;AAE3E,MAAM,oBAAoB;IAC/B,yBAAyB;IACzB;IACA;IACA;IAEA,mBAAmB;IACnB;IACA;IAEA,iBAAiB;IACjB;IACA;IAEA,kBAAkB;IAClB;IACA;IAEA,eAAe;IACf;IAEA,yBAAyB;IACzB;IAEA,gBAAgB;IAChB;IAEA,uBAAuB;IACvB;CACD","debugId":null}},
    {"offset": {"line": 4323, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/constants/font-constants.ts"],"sourcesContent":["export interface FontOption {\n  value: string;\n  label: string;\n  category: \"system\" | \"google\" | \"custom\";\n  weights?: number[];\n  hasClassName?: boolean;\n}\n\nexport const FONT_OPTIONS: FontOption[] = [\n  // System fonts (always available)\n  { value: \"Arial\", label: \"Arial\", category: \"system\", hasClassName: false },\n  {\n    value: \"Helvetica\",\n    label: \"Helvetica\",\n    category: \"system\",\n    hasClassName: false,\n  },\n  {\n    value: \"Times New Roman\",\n    label: \"Times New Roman\",\n    category: \"system\",\n    hasClassName: false,\n  },\n  {\n    value: \"Georgia\",\n    label: \"Georgia\",\n    category: \"system\",\n    hasClassName: false,\n  },\n\n  // Google Fonts (loaded in layout.tsx)\n  {\n    value: \"Inter\",\n    label: \"Inter\",\n    category: \"google\",\n    weights: [400, 700],\n    hasClassName: true,\n  },\n  {\n    value: \"Roboto\",\n    label: \"Roboto\",\n    category: \"google\",\n    weights: [400, 700],\n    hasClassName: true,\n  },\n  {\n    value: \"Open Sans\",\n    label: \"Open Sans\",\n    category: \"google\",\n    hasClassName: true,\n  },\n  {\n    value: \"Playfair Display\",\n    label: \"Playfair Display\",\n    category: \"google\",\n    hasClassName: true,\n  },\n  {\n    value: \"Comic Neue\",\n    label: \"Comic Neue\",\n    category: \"google\",\n    hasClassName: false,\n  },\n] as const;\n\nexport const DEFAULT_FONT = \"Arial\";\n\n// Type-safe font family union\nexport type FontFamily = (typeof FONT_OPTIONS)[number][\"value\"];\n\n// Helper functions\nexport const getFontByValue = (value: string): FontOption | undefined =>\n  FONT_OPTIONS.find((font) => font.value === value);\n\nexport const getGoogleFonts = (): FontOption[] =>\n  FONT_OPTIONS.filter((font) => font.category === \"google\");\n\nexport const getSystemFonts = (): FontOption[] =>\n  FONT_OPTIONS.filter((font) => font.category === \"system\");\n"],"names":[],"mappings":";;;;;;;AAQO,MAAM,eAA6B;IACxC,kCAAkC;IAClC;QAAE,OAAO;QAAS,OAAO;QAAS,UAAU;QAAU,cAAc;IAAM;IAC1E;QACE,OAAO;QACP,OAAO;QACP,UAAU;QACV,cAAc;IAChB;IACA;QACE,OAAO;QACP,OAAO;QACP,UAAU;QACV,cAAc;IAChB;IACA;QACE,OAAO;QACP,OAAO;QACP,UAAU;QACV,cAAc;IAChB;IAEA,sCAAsC;IACtC;QACE,OAAO;QACP,OAAO;QACP,UAAU;QACV,SAAS;YAAC;YAAK;SAAI;QACnB,cAAc;IAChB;IACA;QACE,OAAO;QACP,OAAO;QACP,UAAU;QACV,SAAS;YAAC;YAAK;SAAI;QACnB,cAAc;IAChB;IACA;QACE,OAAO;QACP,OAAO;QACP,UAAU;QACV,cAAc;IAChB;IACA;QACE,OAAO;QACP,OAAO;QACP,UAAU;QACV,cAAc;IAChB;IACA;QACE,OAAO;QACP,OAAO;QACP,UAAU;QACV,cAAc;IAChB;CACD;AAEM,MAAM,eAAe;AAMrB,MAAM,iBAAiB,CAAC,QAC7B,aAAa,IAAI,CAAC,CAAC,OAAS,KAAK,KAAK,KAAK;AAEtC,MAAM,iBAAiB,IAC5B,aAAa,MAAM,CAAC,CAAC,OAAS,KAAK,QAAQ,KAAK;AAE3C,MAAM,iBAAiB,IAC5B,aAAa,MAAM,CAAC,CAAC,OAAS,KAAK,QAAQ,KAAK","debugId":null}},
    {"offset": {"line": 4404, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/constants/actions.ts"],"sourcesContent":["/* An `action` is a unique verb that is associated with certain thing that can be done on OpenCut.\n * For example, toggling playback or seeking.\n */\n\nimport {\n  useEffect,\n  useRef,\n  useState,\n  useCallback,\n  MutableRefObject,\n} from \"react\";\n\n// Simple event emitter for action changes\nclass ActionEmitter {\n  private listeners: Array<(actions: Action[]) => void> = [];\n\n  subscribe(listener: (actions: Action[]) => void) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter((l) => l !== listener);\n    };\n  }\n\n  emit(actions: Action[]) {\n    this.listeners.forEach((listener) => listener(actions));\n  }\n}\n\nconst actionEmitter = new ActionEmitter();\n\nexport type Action =\n  | \"toggle-play\" // Toggle play/pause state\n  | \"stop-playback\" // Stop playback\n  | \"seek-forward\" // Seek forward in playback\n  | \"seek-backward\" // Seek backward in playback\n  | \"frame-step-forward\" // Step forward by one frame\n  | \"frame-step-backward\" // Step backward by one frame\n  | \"jump-forward\" // Jump forward by 5 seconds\n  | \"jump-backward\" // Jump backward by 5 seconds\n  | \"goto-start\" // Go to timeline start\n  | \"goto-end\" // Go to timeline end\n  | \"split-element\" // Split element at current time\n  | \"delete-selected\" // Delete selected elements\n  | \"select-all\" // Select all elements\n  | \"duplicate-selected\" // Duplicate selected element\n  | \"toggle-snapping\" // Toggle snapping\n  | \"undo\" // Undo last action\n  | \"redo\" // Redo last undone action\n  | \"copy-selected\" // Copy selected elements to clipboard\n  | \"paste-selected\"; // Paste elements from clipboard at playhead\n\n/**\n * Defines the arguments, if present for a given type that is required to be passed on\n * invocation and will be passed to action handlers.\n *\n * This type is supposed to be an object with the key being one of the actions mentioned above.\n * The value to the key can be anything.\n * If an action has no argument, you do not need to add it to this type.\n *\n * NOTE: We can't enforce type checks to make sure the key is Action, you\n * will know if you got something wrong if there is a type error in this file\n */\ntype ActionArgsMap = {\n  \"seek-forward\": { seconds: number } | undefined; // Args needed for seeking forward (default: 1)\n  \"seek-backward\": { seconds: number } | undefined; // Args needed for seeking backward (default: 1)\n  \"jump-forward\": { seconds: number } | undefined; // Args needed for jumping forward (default: 5)\n  \"jump-backward\": { seconds: number } | undefined; // Args needed for jumping backward (default: 5)\n};\n\ntype KeysWithValueUndefined<T> = {\n  [K in keyof T]: undefined extends T[K] ? K : never;\n}[keyof T];\n\n/**\n * Actions which require arguments for their invocation\n */\nexport type ActionWithArgs = keyof ActionArgsMap;\n\n/**\n * Actions which optionally takes in arguments for their invocation\n */\n\nexport type ActionWithOptionalArgs =\n  | ActionWithNoArgs\n  | KeysWithValueUndefined<ActionArgsMap>;\n\n/**\n * Actions which do not require arguments for their invocation\n */\nexport type ActionWithNoArgs = Exclude<Action, ActionWithArgs>;\n\n/**\n * Resolves the argument type for a given Action\n */\ntype ArgOfHoppAction<A extends Action> = A extends ActionWithArgs\n  ? ActionArgsMap[A]\n  : undefined;\n\n/**\n * Resolves the action function for a given Action, used by action handler function defs\n */\ntype ActionFunc<A extends Action> = A extends ActionWithArgs\n  ? (arg: ArgOfHoppAction<A>, trigger?: InvocationTriggers) => void\n  : (_?: undefined, trigger?: InvocationTriggers) => void;\n\ntype BoundActionList = {\n  [A in Action]?: Array<ActionFunc<A>>;\n};\n\nconst boundActions: BoundActionList = {};\n\nlet currentActiveActions: Action[] = [];\n\nfunction updateActiveActions() {\n  const newActions = Object.keys(boundActions) as Action[];\n  currentActiveActions = newActions;\n  actionEmitter.emit(newActions);\n}\n\nexport function bindAction<A extends Action>(\n  action: A,\n  handler: ActionFunc<A>\n) {\n  if (boundActions[action]) {\n    boundActions[action]?.push(handler);\n  } else {\n    // 'any' assertion because TypeScript doesn't seem to be able to figure out the links.\n    boundActions[action] = [handler] as any;\n  }\n\n  updateActiveActions();\n}\n\nexport type InvocationTriggers = \"keypress\" | \"mouseclick\";\n\ntype InvokeActionFunc = {\n  (\n    action: ActionWithOptionalArgs,\n    args?: undefined,\n    trigger?: InvocationTriggers\n  ): void;\n  <A extends ActionWithArgs>(action: A, args: ActionArgsMap[A]): void;\n};\n\n/**\n * Invokes an action, triggering action handlers if any registered.\n * The second and third arguments are optional\n * @param action The action to fire\n * @param args The argument passed to the action handler. Optional if action has no args required\n * @param trigger Optionally supply the trigger that invoked the action (keypress/mouseclick)\n */\nexport const invokeAction: InvokeActionFunc = <A extends Action>(\n  action: A,\n  args?: ArgOfHoppAction<A>,\n  trigger?: InvocationTriggers\n) => {\n  boundActions[action]?.forEach((handler) => (handler as any)(args, trigger));\n};\n\nexport function unbindAction<A extends Action>(\n  action: A,\n  handler: ActionFunc<A>\n) {\n  // 'any' assertion because TypeScript doesn't seem to be able to figure out the links.\n  boundActions[action] = boundActions[action]?.filter(\n    (x) => x !== handler\n  ) as any;\n\n  if (boundActions[action]?.length === 0) {\n    delete boundActions[action];\n  }\n\n  updateActiveActions();\n}\n\n/**\n * Returns whether a given action is bound at a given time\n *\n * @param action The action to check\n */\nexport function isActionBound(action: Action): boolean {\n  return !!boundActions[action];\n}\n\n/**\n * A React hook that defines a component can handle a given\n * Action. The handler will be bound when the component is mounted\n * and unbound when the component is unmounted.\n * @param action The action to be bound\n * @param handler The function to be called when the action is invoked\n * @param isActive A ref that indicates whether the action is active\n */\nexport function useActionHandler<A extends Action>(\n  action: A,\n  handler: ActionFunc<A>,\n  isActive: MutableRefObject<boolean> | boolean | undefined\n) {\n  const handlerRef = useRef(handler);\n  const [isBound, setIsBound] = useState(false);\n\n  // Update handler ref when handler changes\n  useEffect(() => {\n    handlerRef.current = handler;\n  }, [handler]);\n\n  // Create a stable handler wrapper\n  const stableHandler = useCallback(\n    (args: any, trigger?: InvocationTriggers) => {\n      (handlerRef.current as any)(args, trigger);\n    },\n    []\n  ) as ActionFunc<A>;\n\n  useEffect(() => {\n    const shouldBind =\n      isActive === undefined ||\n      (typeof isActive === \"boolean\" ? isActive : isActive.current);\n\n    if (shouldBind && !isBound) {\n      bindAction(action, stableHandler);\n      setIsBound(true);\n    } else if (!shouldBind && isBound) {\n      unbindAction(action, stableHandler);\n      setIsBound(false);\n    }\n\n    return () => {\n      if (isBound) {\n        unbindAction(action, stableHandler);\n        setIsBound(false);\n      }\n    };\n  }, [action, stableHandler, isActive, isBound]);\n\n  // Handle ref-based isActive changes\n  useEffect(() => {\n    if (isActive && typeof isActive === \"object\" && \"current\" in isActive) {\n      // Poll for ref changes\n      const interval = setInterval(() => {\n        const shouldBind = isActive.current;\n        if (shouldBind !== isBound) {\n          if (shouldBind) {\n            bindAction(action, stableHandler);\n          } else {\n            unbindAction(action, stableHandler);\n          }\n          setIsBound(shouldBind);\n        }\n      }, 100);\n      return () => clearInterval(interval);\n    }\n  }, [action, stableHandler, isActive, isBound]);\n}\n\n/**\n * A React hook that returns the current list of active actions\n * and re-renders when the list changes\n */\nexport function useActiveActions(): Action[] {\n  const [activeActions, setActiveActions] = useState<Action[]>([]);\n\n  useEffect(() => {\n    // Set initial value\n    setActiveActions(currentActiveActions);\n\n    // Subscribe to changes\n    const unsubscribe = actionEmitter.subscribe(setActiveActions);\n    return unsubscribe;\n  }, []);\n\n  return activeActions;\n}\n\n/**\n * A React hook that returns whether a specific action is currently bound\n * and re-renders when the binding state changes\n */\nexport function useIsActionBound(action: Action): boolean {\n  const [isBound, setIsBound] = useState(() => isActionBound(action));\n\n  useEffect(() => {\n    const updateBoundState = () => {\n      setIsBound(isActionBound(action));\n    };\n\n    // Set initial value\n    updateBoundState();\n\n    // Subscribe to changes\n    const unsubscribe = actionEmitter.subscribe(updateBoundState);\n    return unsubscribe;\n  }, [action]);\n\n  return isBound;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4552, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/app/editor/%5Bproject_id%5D/page.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useRef } from \"react\";\nimport { useParams, useRouter } from \"next/navigation\";\nimport {\n  ResizablePanelGroup,\n  ResizablePanel,\n  ResizableHandle,\n} from \"@/components/ui/resizable\";\nimport { MediaPanel } from \"@/components/editor/media-panel\";\nimport { PropertiesPanel } from \"@/components/editor/properties-panel\";\nimport { Timeline } from \"@/components/editor/timeline\";\nimport { PreviewPanel } from \"@/components/editor/preview-panel\";\nimport { EditorHeader } from \"@/components/editor/editor-header\";\nimport { usePanelStore } from \"@/stores/panel-store\";\nimport { useProjectStore } from \"@/stores/project-store\";\nimport { EditorProvider } from \"@/components/providers/editor-provider\";\nimport { usePlaybackControls } from \"@/hooks/use-playback-controls\";\nimport { Onboarding } from \"@/components/editor/onboarding\";\n\nexport default function Editor() {\n  const {\n    toolsPanel,\n    previewPanel,\n    mainContent,\n    timeline,\n    setToolsPanel,\n    setPreviewPanel,\n    setMainContent,\n    setTimeline,\n    propertiesPanel,\n    setPropertiesPanel,\n    activePreset,\n    resetCounter,\n  } = usePanelStore();\n\n  const {\n    activeProject,\n    loadProject,\n    createNewProject,\n    isInvalidProjectId,\n    markProjectIdAsInvalid,\n  } = useProjectStore();\n  const params = useParams();\n  const router = useRouter();\n  const projectId = params.project_id as string;\n  const handledProjectIds = useRef<Set<string>>(new Set());\n  const isInitializingRef = useRef<boolean>(false);\n\n  usePlaybackControls();\n\n  useEffect(() => {\n    let isCancelled = false;\n\n    const initProject = async () => {\n      if (!projectId) {\n        return;\n      }\n\n      // Prevent duplicate initialization\n      if (isInitializingRef.current) {\n        return;\n      }\n\n      // Check if project is already loaded\n      if (activeProject?.id === projectId) {\n        return;\n      }\n\n      // Check global invalid tracking first (most important for preventing duplicates)\n      if (isInvalidProjectId(projectId)) {\n        return;\n      }\n\n      // Check if we've already handled this project ID locally\n      if (handledProjectIds.current.has(projectId)) {\n        return;\n      }\n\n      // Mark as initializing to prevent race conditions\n      isInitializingRef.current = true;\n      handledProjectIds.current.add(projectId);\n\n      try {\n        await loadProject(projectId);\n\n        // Check if component was unmounted during async operation\n        if (isCancelled) {\n          return;\n        }\n\n        // Project loaded successfully\n        isInitializingRef.current = false;\n      } catch (error) {\n        // Check if component was unmounted during async operation\n        if (isCancelled) {\n          return;\n        }\n\n        // More specific error handling - only create new project for actual \"not found\" errors\n        const isProjectNotFound =\n          error instanceof Error &&\n          (error.message.includes(\"not found\") ||\n            error.message.includes(\"does not exist\") ||\n            error.message.includes(\"Project not found\"));\n\n        if (isProjectNotFound) {\n          // Mark this project ID as invalid globally BEFORE creating project\n          markProjectIdAsInvalid(projectId);\n\n          try {\n            const newProjectId = await createNewProject(\"Untitled Project\");\n\n            // Check again if component was unmounted\n            if (isCancelled) {\n              return;\n            }\n\n            router.replace(`/editor/${newProjectId}`);\n          } catch (createError) {\n            console.error(\"Failed to create new project:\", createError);\n          }\n        } else {\n          // For other errors (storage issues, corruption, etc.), don't create new project\n          console.error(\n            \"Project loading failed with recoverable error:\",\n            error\n          );\n          // Remove from handled set so user can retry\n          handledProjectIds.current.delete(projectId);\n        }\n\n        isInitializingRef.current = false;\n      }\n    };\n\n    initProject();\n\n    // Cleanup function to cancel async operations\n    return () => {\n      isCancelled = true;\n      isInitializingRef.current = false;\n    };\n  }, [\n    projectId,\n    loadProject,\n    createNewProject,\n    router,\n    isInvalidProjectId,\n    markProjectIdAsInvalid,\n  ]);\n\n  return (\n    <EditorProvider>\n      <div className=\"h-screen w-screen flex flex-col bg-background overflow-hidden\">\n        <EditorHeader />\n        <div className=\"flex-1 min-h-0 min-w-0\">\n          {activePreset === \"media\" ? (\n            <ResizablePanelGroup\n              key={`media-${activePreset}-${resetCounter}`}\n              direction=\"horizontal\"\n              className=\"h-full w-full gap-[0.18rem] px-3 pb-3\"\n            >\n              <ResizablePanel\n                defaultSize={toolsPanel}\n                minSize={15}\n                maxSize={40}\n                onResize={setToolsPanel}\n                className=\"min-w-0 rounded-sm\"\n              >\n                <MediaPanel />\n              </ResizablePanel>\n\n              <ResizableHandle withHandle />\n\n              <ResizablePanel\n                defaultSize={100 - toolsPanel}\n                minSize={60}\n                className=\"min-w-0 min-h-0\"\n              >\n                <ResizablePanelGroup\n                  direction=\"vertical\"\n                  className=\"h-full w-full gap-[0.18rem]\"\n                >\n                  <ResizablePanel\n                    defaultSize={mainContent}\n                    minSize={30}\n                    maxSize={85}\n                    onResize={setMainContent}\n                    className=\"min-h-0\"\n                  >\n                    <ResizablePanelGroup\n                      direction=\"horizontal\"\n                      className=\"h-full w-full gap-[0.19rem]\"\n                    >\n                      <ResizablePanel\n                        defaultSize={previewPanel}\n                        minSize={30}\n                        onResize={setPreviewPanel}\n                        className=\"min-w-0 min-h-0 flex-1\"\n                      >\n                        <PreviewPanel />\n                      </ResizablePanel>\n\n                      <ResizableHandle withHandle />\n\n                      <ResizablePanel\n                        defaultSize={propertiesPanel}\n                        minSize={15}\n                        maxSize={40}\n                        onResize={setPropertiesPanel}\n                        className=\"min-w-0\"\n                      >\n                        <PropertiesPanel />\n                      </ResizablePanel>\n                    </ResizablePanelGroup>\n                  </ResizablePanel>\n\n                  <ResizableHandle withHandle />\n\n                  <ResizablePanel\n                    defaultSize={timeline}\n                    minSize={15}\n                    maxSize={70}\n                    onResize={setTimeline}\n                    className=\"min-h-0\"\n                  >\n                    <Timeline />\n                  </ResizablePanel>\n                </ResizablePanelGroup>\n              </ResizablePanel>\n            </ResizablePanelGroup>\n          ) : activePreset === \"inspector\" ? (\n            <ResizablePanelGroup\n              key={`inspector-${activePreset}-${resetCounter}`}\n              direction=\"horizontal\"\n              className=\"h-full w-full gap-[0.18rem] px-3 pb-3\"\n            >\n              <ResizablePanel\n                defaultSize={100 - propertiesPanel}\n                minSize={30}\n                onResize={(size) => setPropertiesPanel(100 - size)}\n                className=\"min-w-0 min-h-0\"\n              >\n                <ResizablePanelGroup\n                  direction=\"vertical\"\n                  className=\"h-full w-full gap-[0.18rem]\"\n                >\n                  <ResizablePanel\n                    defaultSize={mainContent}\n                    minSize={30}\n                    maxSize={85}\n                    onResize={setMainContent}\n                    className=\"min-h-0\"\n                  >\n                    <ResizablePanelGroup\n                      direction=\"horizontal\"\n                      className=\"h-full w-full gap-[0.19rem]\"\n                    >\n                      <ResizablePanel\n                        defaultSize={toolsPanel}\n                        minSize={15}\n                        maxSize={40}\n                        onResize={setToolsPanel}\n                        className=\"min-w-0 rounded-sm\"\n                      >\n                        <MediaPanel />\n                      </ResizablePanel>\n\n                      <ResizableHandle withHandle />\n\n                      <ResizablePanel\n                        defaultSize={previewPanel}\n                        minSize={30}\n                        onResize={setPreviewPanel}\n                        className=\"min-w-0 min-h-0 flex-1\"\n                      >\n                        <PreviewPanel />\n                      </ResizablePanel>\n                    </ResizablePanelGroup>\n                  </ResizablePanel>\n\n                  <ResizableHandle withHandle />\n\n                  <ResizablePanel\n                    defaultSize={timeline}\n                    minSize={15}\n                    maxSize={70}\n                    onResize={setTimeline}\n                    className=\"min-h-0\"\n                  >\n                    <Timeline />\n                  </ResizablePanel>\n                </ResizablePanelGroup>\n              </ResizablePanel>\n\n              <ResizableHandle withHandle />\n\n              <ResizablePanel\n                defaultSize={propertiesPanel}\n                minSize={15}\n                maxSize={40}\n                onResize={setPropertiesPanel}\n                className=\"min-w-0 min-h-0\"\n              >\n                <PropertiesPanel />\n              </ResizablePanel>\n            </ResizablePanelGroup>\n          ) : activePreset === \"vertical-preview\" ? (\n            <ResizablePanelGroup\n              key={`vertical-preview-${activePreset}-${resetCounter}`}\n              direction=\"horizontal\"\n              className=\"h-full w-full gap-[0.18rem] px-3 pb-3\"\n            >\n              <ResizablePanel\n                defaultSize={100 - previewPanel}\n                minSize={30}\n                onResize={(size) => setPreviewPanel(100 - size)}\n                className=\"min-w-0 min-h-0\"\n              >\n                <ResizablePanelGroup\n                  direction=\"vertical\"\n                  className=\"h-full w-full gap-[0.18rem]\"\n                >\n                  <ResizablePanel\n                    defaultSize={mainContent}\n                    minSize={30}\n                    maxSize={85}\n                    onResize={setMainContent}\n                    className=\"min-h-0\"\n                  >\n                    <ResizablePanelGroup\n                      direction=\"horizontal\"\n                      className=\"h-full w-full gap-[0.19rem]\"\n                    >\n                      <ResizablePanel\n                        defaultSize={toolsPanel}\n                        minSize={15}\n                        maxSize={40}\n                        onResize={setToolsPanel}\n                        className=\"min-w-0 rounded-sm\"\n                      >\n                        <MediaPanel />\n                      </ResizablePanel>\n\n                      <ResizableHandle withHandle />\n\n                      <ResizablePanel\n                        defaultSize={propertiesPanel}\n                        minSize={15}\n                        maxSize={40}\n                        onResize={setPropertiesPanel}\n                        className=\"min-w-0\"\n                      >\n                        <PropertiesPanel />\n                      </ResizablePanel>\n                    </ResizablePanelGroup>\n                  </ResizablePanel>\n\n                  <ResizableHandle withHandle />\n\n                  <ResizablePanel\n                    defaultSize={timeline}\n                    minSize={15}\n                    maxSize={70}\n                    onResize={setTimeline}\n                    className=\"min-h-0\"\n                  >\n                    <Timeline />\n                  </ResizablePanel>\n                </ResizablePanelGroup>\n              </ResizablePanel>\n\n              <ResizableHandle withHandle />\n\n              <ResizablePanel\n                defaultSize={previewPanel}\n                minSize={30}\n                onResize={setPreviewPanel}\n                className=\"min-w-0 min-h-0\"\n              >\n                <PreviewPanel />\n              </ResizablePanel>\n            </ResizablePanelGroup>\n          ) : (\n            <ResizablePanelGroup\n              key={`default-${activePreset}-${resetCounter}`}\n              direction=\"vertical\"\n              className=\"h-full w-full gap-[0.18rem]\"\n            >\n              <ResizablePanel\n                defaultSize={mainContent}\n                minSize={30}\n                maxSize={85}\n                onResize={setMainContent}\n                className=\"min-h-0\"\n              >\n                {/* Main content area */}\n                <ResizablePanelGroup\n                  direction=\"horizontal\"\n                  className=\"h-full w-full gap-[0.19rem] px-3\"\n                >\n                  {/* Tools Panel */}\n                  <ResizablePanel\n                    defaultSize={toolsPanel}\n                    minSize={15}\n                    maxSize={40}\n                    onResize={setToolsPanel}\n                    className=\"min-w-0 rounded-sm\"\n                  >\n                    <MediaPanel />\n                  </ResizablePanel>\n\n                  <ResizableHandle withHandle />\n\n                  {/* Preview Area */}\n                  <ResizablePanel\n                    defaultSize={previewPanel}\n                    minSize={30}\n                    onResize={setPreviewPanel}\n                    className=\"min-w-0 min-h-0 flex-1\"\n                  >\n                    <PreviewPanel />\n                  </ResizablePanel>\n\n                  <ResizableHandle withHandle />\n\n                  <ResizablePanel\n                    defaultSize={propertiesPanel}\n                    minSize={15}\n                    maxSize={40}\n                    onResize={setPropertiesPanel}\n                    className=\"min-w-0 rounded-sm\"\n                  >\n                    <PropertiesPanel />\n                  </ResizablePanel>\n                </ResizablePanelGroup>\n              </ResizablePanel>\n\n              <ResizableHandle withHandle />\n\n              {/* Timeline */}\n              <ResizablePanel\n                defaultSize={timeline}\n                minSize={15}\n                maxSize={70}\n                onResize={setTimeline}\n                className=\"min-h-0 px-3 pb-3\"\n              >\n                <Timeline />\n              </ResizablePanel>\n            </ResizablePanelGroup>\n          )}\n        </div>\n        <Onboarding />\n      </div>\n    </EditorProvider>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}