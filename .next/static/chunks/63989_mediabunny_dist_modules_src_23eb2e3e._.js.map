{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/muxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AsyncMutex } from './misc.js';\nexport class Muxer {\n    constructor(output) {\n        this.mutex = new AsyncMutex();\n        /**\n         * This field is used to synchronize multiple MediaStreamTracks. They use the same time coordinate system across\n         * tracks, and to ensure correct audio-video sync, we must use the same offset for all of them. The reason an offset\n         * is needed at all is because the timestamps typically don't start at zero.\n         */\n        this.firstMediaStreamTimestamp = null;\n        this.trackTimestampInfo = new WeakMap();\n        this.output = output;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onTrackClose(track) { }\n    validateAndNormalizeTimestamp(track, timestampInSeconds, isKeyFrame) {\n        timestampInSeconds += track.source._timestampOffset;\n        let timestampInfo = this.trackTimestampInfo.get(track);\n        if (!timestampInfo) {\n            if (!isKeyFrame) {\n                throw new Error('First frame must be a key frame.');\n            }\n            timestampInfo = {\n                maxTimestamp: timestampInSeconds,\n                maxTimestampBeforeLastKeyFrame: timestampInSeconds,\n            };\n            this.trackTimestampInfo.set(track, timestampInfo);\n        }\n        if (timestampInSeconds < 0) {\n            throw new Error(`Timestamps must be non-negative (got ${timestampInSeconds}s).`);\n        }\n        if (isKeyFrame) {\n            timestampInfo.maxTimestampBeforeLastKeyFrame = timestampInfo.maxTimestamp;\n        }\n        if (timestampInSeconds < timestampInfo.maxTimestampBeforeLastKeyFrame) {\n            throw new Error(`Timestamps cannot be smaller than the highest timestamp of the previous run (a run begins with a`\n                + ` key frame and ends right before the next key frame). Got ${timestampInSeconds}s, but highest`\n                + ` timestamp is ${timestampInfo.maxTimestampBeforeLastKeyFrame}s.`);\n        }\n        timestampInfo.maxTimestamp = Math.max(timestampInfo.maxTimestamp, timestampInSeconds);\n        return timestampInSeconds;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AACD;;AACO,MAAM;IAYT,6DAA6D;IAC7D,aAAa,KAAK,EAAE,CAAE;IACtB,8BAA8B,KAAK,EAAE,kBAAkB,EAAE,UAAU,EAAE;QACjE,sBAAsB,MAAM,MAAM,CAAC,gBAAgB;QACnD,IAAI,gBAAgB,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC;QAChD,IAAI,CAAC,eAAe;YAChB,IAAI,CAAC,YAAY;gBACb,MAAM,IAAI,MAAM;YACpB;YACA,gBAAgB;gBACZ,cAAc;gBACd,gCAAgC;YACpC;YACA,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,OAAO;QACvC;QACA,IAAI,qBAAqB,GAAG;YACxB,MAAM,IAAI,MAAM,AAAC,wCAA0D,OAAnB,oBAAmB;QAC/E;QACA,IAAI,YAAY;YACZ,cAAc,8BAA8B,GAAG,cAAc,YAAY;QAC7E;QACA,IAAI,qBAAqB,cAAc,8BAA8B,EAAE;YACnE,MAAM,IAAI,MAAM,AAAC,qGACX,AAAC,6DAA+E,OAAnB,oBAAmB,oBAChF,AAAC,iBAA6D,OAA7C,cAAc,8BAA8B,EAAC;QACxE;QACA,cAAc,YAAY,GAAG,KAAK,GAAG,CAAC,cAAc,YAAY,EAAE;QAClE,OAAO;IACX;IAvCA,YAAY,MAAM,CAAE;QAChB,IAAI,CAAC,KAAK,GAAG,IAAI,qNAAA,CAAA,aAAU;QAC3B;;;;SAIC,GACD,IAAI,CAAC,yBAAyB,GAAG;QACjC,IAAI,CAAC,kBAAkB,GAAG,IAAI;QAC9B,IAAI,CAAC,MAAM,GAAG;IAClB;AA8BJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/adts/adts-muxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { parseAacAudioSpecificConfig, validateAudioChunkMetadata } from '../codec.js';\nimport { assert, Bitstream, toUint8Array } from '../misc.js';\nimport { Muxer } from '../muxer.js';\nexport class AdtsMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.header = new Uint8Array(7);\n        this.headerBitstream = new Bitstream(this.header);\n        this.audioSpecificConfig = null;\n        this.format = format;\n        this.writer = output._writer;\n    }\n    async start() {\n        // Nothing needed here\n    }\n    async getMimeType() {\n        return 'audio/aac';\n    }\n    async addEncodedVideoPacket() {\n        throw new Error('ADTS does not support video.');\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        // https://wiki.multimedia.cx/index.php/ADTS (last visited: 2025/08/17)\n        const release = await this.mutex.acquire();\n        try {\n            this.validateAndNormalizeTimestamp(track, packet.timestamp, packet.type === 'key');\n            if (!this.audioSpecificConfig) {\n                validateAudioChunkMetadata(meta);\n                const description = meta?.decoderConfig?.description;\n                assert(description);\n                this.audioSpecificConfig = parseAacAudioSpecificConfig(toUint8Array(description));\n                const { objectType, frequencyIndex, channelConfiguration } = this.audioSpecificConfig;\n                const profile = objectType - 1;\n                this.headerBitstream.writeBits(12, 0b1111_11111111); // Syncword\n                this.headerBitstream.writeBits(1, 0); // MPEG Version\n                this.headerBitstream.writeBits(2, 0); // Layer\n                this.headerBitstream.writeBits(1, 1); // Protection absence\n                this.headerBitstream.writeBits(2, profile); // Profile\n                this.headerBitstream.writeBits(4, frequencyIndex); // MPEG-4 Sampling Frequency Index\n                this.headerBitstream.writeBits(1, 0); // Private bit\n                this.headerBitstream.writeBits(3, channelConfiguration); // MPEG-4 Channel Configuration\n                this.headerBitstream.writeBits(1, 0); // Originality\n                this.headerBitstream.writeBits(1, 0); // Home\n                this.headerBitstream.writeBits(1, 0); // Copyright ID bit\n                this.headerBitstream.writeBits(1, 0); // Copyright ID start\n                this.headerBitstream.skipBits(13); // Frame length\n                this.headerBitstream.writeBits(11, 0x7ff); // Buffer fullness\n                this.headerBitstream.writeBits(2, 0); // Number of AAC frames minus 1\n                // Omit CRC check\n            }\n            const frameLength = packet.data.byteLength + this.header.byteLength;\n            this.headerBitstream.pos = 30;\n            this.headerBitstream.writeBits(13, frameLength);\n            const startPos = this.writer.getPos();\n            this.writer.write(this.header);\n            this.writer.write(packet.data);\n            if (this.format._options.onFrame) {\n                const frameBytes = new Uint8Array(frameLength);\n                frameBytes.set(this.header, 0);\n                frameBytes.set(packet.data, this.header.byteLength);\n                this.format._options.onFrame(frameBytes, startPos);\n            }\n            await this.writer.flush();\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue() {\n        throw new Error('ADTS does not support subtitles.');\n    }\n    async finalize() { }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/subtitles.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst cueBlockHeaderRegex = /(?:(.+?)\\n)?((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})\\s+-->\\s+((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})/g;\nconst preambleStartRegex = /^WEBVTT(.|\\n)*?\\n{2}/;\nexport const inlineTimestampRegex = /<(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})>/g;\nexport class SubtitleParser {\n    constructor(options) {\n        this.preambleText = null;\n        this.preambleEmitted = false;\n        this.options = options;\n    }\n    parse(text) {\n        text = text.replaceAll('\\r\\n', '\\n').replaceAll('\\r', '\\n');\n        cueBlockHeaderRegex.lastIndex = 0;\n        let match;\n        if (!this.preambleText) {\n            if (!preambleStartRegex.test(text)) {\n                throw new Error('WebVTT preamble incorrect.');\n            }\n            match = cueBlockHeaderRegex.exec(text);\n            const preamble = text.slice(0, match?.index ?? text.length).trimEnd();\n            if (!preamble) {\n                throw new Error('No WebVTT preamble provided.');\n            }\n            this.preambleText = preamble;\n            if (match) {\n                text = text.slice(match.index);\n                cueBlockHeaderRegex.lastIndex = 0;\n            }\n        }\n        while ((match = cueBlockHeaderRegex.exec(text))) {\n            const notes = text.slice(0, match.index);\n            const cueIdentifier = match[1];\n            const matchEnd = match.index + match[0].length;\n            const bodyStart = text.indexOf('\\n', matchEnd) + 1;\n            const cueSettings = text.slice(matchEnd, bodyStart).trim();\n            let bodyEnd = text.indexOf('\\n\\n', matchEnd);\n            if (bodyEnd === -1)\n                bodyEnd = text.length;\n            const startTime = parseSubtitleTimestamp(match[2]);\n            const endTime = parseSubtitleTimestamp(match[3]);\n            const duration = endTime - startTime;\n            const body = text.slice(bodyStart, bodyEnd).trim();\n            text = text.slice(bodyEnd).trimStart();\n            cueBlockHeaderRegex.lastIndex = 0;\n            const cue = {\n                timestamp: startTime / 1000,\n                duration: duration / 1000,\n                text: body,\n                identifier: cueIdentifier,\n                settings: cueSettings,\n                notes,\n            };\n            const meta = {};\n            if (!this.preambleEmitted) {\n                meta.config = {\n                    description: this.preambleText,\n                };\n                this.preambleEmitted = true;\n            }\n            this.options.output(cue, meta);\n        }\n    }\n}\nconst timestampRegex = /(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})/;\nexport const parseSubtitleTimestamp = (string) => {\n    const match = timestampRegex.exec(string);\n    if (!match)\n        throw new Error('Expected match.');\n    return 60 * 60 * 1000 * Number(match[1] || '0')\n        + 60 * 1000 * Number(match[2])\n        + 1000 * Number(match[3])\n        + Number(match[4]);\n};\nexport const formatSubtitleTimestamp = (timestamp) => {\n    const hours = Math.floor(timestamp / (60 * 60 * 1000));\n    const minutes = Math.floor((timestamp % (60 * 60 * 1000)) / (60 * 1000));\n    const seconds = Math.floor((timestamp % (60 * 1000)) / 1000);\n    const milliseconds = timestamp % 1000;\n    return hours.toString().padStart(2, '0') + ':'\n        + minutes.toString().padStart(2, '0') + ':'\n        + seconds.toString().padStart(2, '0') + '.'\n        + milliseconds.toString().padStart(3, '0');\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 239, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-boxes.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { toUint8Array, assert, isU32, last, textEncoder, COLOR_PRIMARIES_MAP, TRANSFER_CHARACTERISTICS_MAP, MATRIX_COEFFICIENTS_MAP, colorSpaceIsComplete, UNDETERMINED_LANGUAGE, } from '../misc.js';\nimport { generateAv1CodecConfigurationFromCodecString, parsePcmCodec, PCM_AUDIO_CODECS, } from '../codec.js';\nimport { formatSubtitleTimestamp } from '../subtitles.js';\nimport { GLOBAL_TIMESCALE, intoTimescale, } from './isobmff-muxer.js';\nimport { parseOpusIdentificationHeader } from '../codec-data.js';\nexport class IsobmffBoxWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n        /**\n         * Stores the position from the start of the file to where boxes elements have been written. This is used to\n         * rewrite/edit elements that were already added before, and to measure sizes of things.\n         */\n        this.offsets = new WeakMap();\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeU64(value) {\n        this.helperView.setUint32(0, Math.floor(value / 2 ** 32), false);\n        this.helperView.setUint32(4, value, false);\n        this.writer.write(this.helper.subarray(0, 8));\n    }\n    writeAscii(text) {\n        for (let i = 0; i < text.length; i++) {\n            this.helperView.setUint8(i % 8, text.charCodeAt(i));\n            if (i % 8 === 7)\n                this.writer.write(this.helper);\n        }\n        if (text.length % 8 !== 0) {\n            this.writer.write(this.helper.subarray(0, text.length % 8));\n        }\n    }\n    writeBox(box) {\n        this.offsets.set(box, this.writer.getPos());\n        if (box.contents && !box.children) {\n            this.writeBoxHeader(box, box.size ?? box.contents.byteLength + 8);\n            this.writer.write(box.contents);\n        }\n        else {\n            const startPos = this.writer.getPos();\n            this.writeBoxHeader(box, 0);\n            if (box.contents)\n                this.writer.write(box.contents);\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        this.writeBox(child);\n            const endPos = this.writer.getPos();\n            const size = box.size ?? endPos - startPos;\n            this.writer.seek(startPos);\n            this.writeBoxHeader(box, size);\n            this.writer.seek(endPos);\n        }\n    }\n    writeBoxHeader(box, size) {\n        this.writeU32(box.largeSize ? 1 : size);\n        this.writeAscii(box.type);\n        if (box.largeSize)\n            this.writeU64(size);\n    }\n    measureBoxHeader(box) {\n        return 8 + (box.largeSize ? 8 : 0);\n    }\n    patchBox(box) {\n        const boxOffset = this.offsets.get(box);\n        assert(boxOffset !== undefined);\n        const endPos = this.writer.getPos();\n        this.writer.seek(boxOffset);\n        this.writeBox(box);\n        this.writer.seek(endPos);\n    }\n    measureBox(box) {\n        if (box.contents && !box.children) {\n            const headerSize = this.measureBoxHeader(box);\n            return headerSize + box.contents.byteLength;\n        }\n        else {\n            let result = this.measureBoxHeader(box);\n            if (box.contents)\n                result += box.contents.byteLength;\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        result += this.measureBox(child);\n            return result;\n        }\n    }\n}\nconst bytes = new Uint8Array(8);\nconst view = new DataView(bytes.buffer);\nconst u8 = (value) => {\n    return [(value % 0x100 + 0x100) % 0x100];\n};\nconst u16 = (value) => {\n    view.setUint16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst i16 = (value) => {\n    view.setInt16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst u24 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[1], bytes[2], bytes[3]];\n};\nconst u32 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst i32 = (value) => {\n    view.setInt32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst u64 = (value) => {\n    view.setUint32(0, Math.floor(value / 2 ** 32), false);\n    view.setUint32(4, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]];\n};\nconst fixed_8_8 = (value) => {\n    view.setInt16(0, 2 ** 8 * value, false);\n    return [bytes[0], bytes[1]];\n};\nconst fixed_16_16 = (value) => {\n    view.setInt32(0, 2 ** 16 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst fixed_2_30 = (value) => {\n    view.setInt32(0, 2 ** 30 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst variableUnsignedInt = (value, byteLength) => {\n    const bytes = [];\n    let remaining = value;\n    do {\n        let byte = remaining & 0x7f;\n        remaining >>= 7;\n        // If this isn't the first byte we're adding (meaning there will be more bytes after it\n        // when we reverse the array), set the continuation bit\n        if (bytes.length > 0) {\n            byte |= 0x80;\n        }\n        bytes.push(byte);\n        if (byteLength !== undefined) {\n            byteLength--;\n        }\n    } while (remaining > 0 || byteLength);\n    // Reverse the array since we built it backwards\n    return bytes.reverse();\n};\nconst ascii = (text, nullTerminated = false) => {\n    const bytes = Array(text.length).fill(null).map((_, i) => text.charCodeAt(i));\n    if (nullTerminated)\n        bytes.push(0x00);\n    return bytes;\n};\nconst lastPresentedSample = (samples) => {\n    let result = null;\n    for (const sample of samples) {\n        if (!result || sample.timestamp > result.timestamp) {\n            result = sample;\n        }\n    }\n    return result;\n};\nconst rotationMatrix = (rotationInDegrees) => {\n    const theta = rotationInDegrees * (Math.PI / 180);\n    const cosTheta = Math.round(Math.cos(theta));\n    const sinTheta = Math.round(Math.sin(theta));\n    // Matrices are post-multiplied in ISOBMFF, meaning this is the transpose of your typical rotation matrix\n    return [\n        cosTheta, sinTheta, 0,\n        -sinTheta, cosTheta, 0,\n        0, 0, 1,\n    ];\n};\nconst IDENTITY_MATRIX = rotationMatrix(0);\nconst matrixToBytes = (matrix) => {\n    return [\n        fixed_16_16(matrix[0]), fixed_16_16(matrix[1]), fixed_2_30(matrix[2]),\n        fixed_16_16(matrix[3]), fixed_16_16(matrix[4]), fixed_2_30(matrix[5]),\n        fixed_16_16(matrix[6]), fixed_16_16(matrix[7]), fixed_2_30(matrix[8]),\n    ];\n};\nexport const box = (type, contents, children) => ({\n    type,\n    contents: contents && new Uint8Array(contents.flat(10)),\n    children,\n});\n/** A FullBox always starts with a version byte, followed by three flag bytes. */\nexport const fullBox = (type, version, flags, contents, children) => box(type, [u8(version), u24(flags), contents ?? []], children);\n/**\n * File Type Compatibility Box: Allows the reader to determine whether this is a type of file that the\n * reader understands.\n */\nexport const ftyp = (details) => {\n    // You can find the full logic for this at\n    // https://github.com/FFmpeg/FFmpeg/blob/de2fb43e785773738c660cdafb9309b1ef1bc80d/libavformat/movenc.c#L5518\n    // Obviously, this lib only needs a small subset of that logic.\n    const minorVersion = 0x200;\n    if (details.isQuickTime) {\n        return box('ftyp', [\n            ascii('qt  '), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('qt  '),\n        ]);\n    }\n    if (details.fragmented) {\n        return box('ftyp', [\n            ascii('iso5'), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('iso5'),\n            ascii('iso6'),\n            ascii('mp41'),\n        ]);\n    }\n    return box('ftyp', [\n        ascii('isom'), // Major brand\n        u32(minorVersion), // Minor version\n        // Compatible brands\n        ascii('isom'),\n        details.holdsAvc ? ascii('avc1') : [],\n        ascii('mp41'),\n    ]);\n};\n/** Movie Sample Data Box. Contains the actual frames/samples of the media. */\nexport const mdat = (reserveLargeSize) => ({ type: 'mdat', largeSize: reserveLargeSize });\n/**\n * Movie Box: Used to specify the information that defines a movie - that is, the information that allows\n * an application to interpret the sample data that is stored elsewhere.\n */\nexport const moov = (trackDatas, creationTime, fragmented = false) => box('moov', undefined, [\n    mvhd(creationTime, trackDatas),\n    ...trackDatas.map(x => trak(x, creationTime)),\n    fragmented ? mvex(trackDatas) : null,\n]);\n/** Movie Header Box: Used to specify the characteristics of the entire movie, such as timescale and duration. */\nexport const mvhd = (creationTime, trackDatas) => {\n    const duration = intoTimescale(Math.max(0, ...trackDatas\n        .filter(x => x.samples.length > 0)\n        .map((x) => {\n        const lastSample = lastPresentedSample(x.samples);\n        return lastSample.timestamp + lastSample.duration;\n    })), GLOBAL_TIMESCALE);\n    const nextTrackId = Math.max(0, ...trackDatas.map(x => x.track.id)) + 1;\n    // Conditionally use u64 if u32 isn't enough\n    const needsU64 = !isU32(creationTime) || !isU32(duration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    return fullBox('mvhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(GLOBAL_TIMESCALE), // Timescale\n        u32OrU64(duration), // Duration\n        fixed_16_16(1), // Preferred rate\n        fixed_8_8(1), // Preferred volume\n        Array(10).fill(0), // Reserved\n        matrixToBytes(IDENTITY_MATRIX), // Matrix\n        Array(24).fill(0), // Pre-defined\n        u32(nextTrackId), // Next track ID\n    ]);\n};\n/**\n * Track Box: Defines a single track of a movie. A movie may consist of one or more tracks. Each track is\n * independent of the other tracks in the movie and carries its own temporal and spatial information. Each Track Box\n * contains its associated Media Box.\n */\nexport const trak = (trackData, creationTime) => box('trak', undefined, [\n    tkhd(trackData, creationTime),\n    mdia(trackData, creationTime),\n]);\n/** Track Header Box: Specifies the characteristics of a single track within a movie. */\nexport const tkhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const durationInGlobalTimescale = intoTimescale(lastSample ? lastSample.timestamp + lastSample.duration : 0, GLOBAL_TIMESCALE);\n    const needsU64 = !isU32(creationTime) || !isU32(durationInGlobalTimescale);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    let matrix;\n    if (trackData.type === 'video') {\n        const rotation = trackData.track.metadata.rotation;\n        matrix = rotationMatrix(rotation ?? 0);\n    }\n    else {\n        matrix = IDENTITY_MATRIX;\n    }\n    return fullBox('tkhd', +needsU64, 3, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.track.id), // Track ID\n        u32(0), // Reserved\n        u32OrU64(durationInGlobalTimescale), // Duration\n        Array(8).fill(0), // Reserved\n        u16(0), // Layer\n        u16(trackData.track.id), // Alternate group\n        fixed_8_8(trackData.type === 'audio' ? 1 : 0), // Volume\n        u16(0), // Reserved\n        matrixToBytes(matrix), // Matrix\n        fixed_16_16(trackData.type === 'video' ? trackData.info.width : 0), // Track width\n        fixed_16_16(trackData.type === 'video' ? trackData.info.height : 0), // Track height\n    ]);\n};\n/** Media Box: Describes and define a track's media type and sample data. */\nexport const mdia = (trackData, creationTime) => box('mdia', undefined, [\n    mdhd(trackData, creationTime),\n    hdlr(trackData),\n    minf(trackData),\n]);\n/** Media Header Box: Specifies the characteristics of a media, including timescale and duration. */\nexport const mdhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const localDuration = intoTimescale(lastSample ? lastSample.timestamp + lastSample.duration : 0, trackData.timescale);\n    const needsU64 = !isU32(creationTime) || !isU32(localDuration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    let language = 0;\n    for (const character of (trackData.track.metadata.languageCode ?? UNDETERMINED_LANGUAGE)) {\n        language <<= 5;\n        language += character.charCodeAt(0) - 0x60;\n    }\n    return fullBox('mdhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.timescale), // Timescale\n        u32OrU64(localDuration), // Duration\n        u16(language), // Language\n        u16(0), // Quality\n    ]);\n};\nconst TRACK_TYPE_TO_COMPONENT_SUBTYPE = {\n    video: 'vide',\n    audio: 'soun',\n    subtitle: 'text',\n};\nconst TRACK_TYPE_TO_HANDLER_NAME = {\n    video: 'MediabunnyVideoHandler',\n    audio: 'MediabunnySoundHandler',\n    subtitle: 'MediabunnyTextHandler',\n};\n/** Handler Reference Box: Specifies the media handler component that is to be used to interpret the media's data. */\nexport const hdlr = (trackData) => fullBox('hdlr', 0, 0, [\n    ascii('mhlr'), // Component type\n    ascii(TRACK_TYPE_TO_COMPONENT_SUBTYPE[trackData.type]), // Component subtype\n    u32(0), // Component manufacturer\n    u32(0), // Component flags\n    u32(0), // Component flags mask\n    ascii(TRACK_TYPE_TO_HANDLER_NAME[trackData.type], true), // Component name\n]);\n/**\n * Media Information Box: Stores handler-specific information for a track's media data. The media handler uses this\n * information to map from media time to media data and to process the media data.\n */\nexport const minf = (trackData) => box('minf', undefined, [\n    TRACK_TYPE_TO_HEADER_BOX[trackData.type](),\n    dinf(),\n    stbl(trackData),\n]);\n/** Video Media Information Header Box: Defines specific color and graphics mode information. */\nexport const vmhd = () => fullBox('vmhd', 0, 1, [\n    u16(0), // Graphics mode\n    u16(0), // Opcolor R\n    u16(0), // Opcolor G\n    u16(0), // Opcolor B\n]);\n/** Sound Media Information Header Box: Stores the sound media's control information, such as balance. */\nexport const smhd = () => fullBox('smhd', 0, 0, [\n    u16(0), // Balance\n    u16(0), // Reserved\n]);\n/** Null Media Header Box. */\nexport const nmhd = () => fullBox('nmhd', 0, 0);\nconst TRACK_TYPE_TO_HEADER_BOX = {\n    video: vmhd,\n    audio: smhd,\n    subtitle: nmhd,\n};\n/**\n * Data Information Box: Contains information specifying the data handler component that provides access to the\n * media data. The data handler component uses the Data Information Box to interpret the media's data.\n */\nexport const dinf = () => box('dinf', undefined, [\n    dref(),\n]);\n/**\n * Data Reference Box: Contains tabular data that instructs the data handler component how to access the media's data.\n */\nexport const dref = () => fullBox('dref', 0, 0, [\n    u32(1), // Entry count\n], [\n    url(),\n]);\nexport const url = () => fullBox('url ', 0, 1); // Self-reference flag enabled\n/**\n * Sample Table Box: Contains information for converting from media time to sample number to sample location. This box\n * also indicates how to interpret the sample (for example, whether to decompress the video data and, if so, how).\n */\nexport const stbl = (trackData) => {\n    const needsCtts = trackData.compositionTimeOffsetTable.length > 1\n        || trackData.compositionTimeOffsetTable.some(x => x.sampleCompositionTimeOffset !== 0);\n    return box('stbl', undefined, [\n        stsd(trackData),\n        stts(trackData),\n        needsCtts ? ctts(trackData) : null,\n        needsCtts ? cslg(trackData) : null,\n        stsc(trackData),\n        stsz(trackData),\n        stco(trackData),\n        stss(trackData),\n    ]);\n};\n/**\n * Sample Description Box: Stores information that allows you to decode samples in the media. The data stored in the\n * sample description varies, depending on the media type.\n */\nexport const stsd = (trackData) => {\n    let sampleDescription;\n    if (trackData.type === 'video') {\n        sampleDescription = videoSampleDescription(VIDEO_CODEC_TO_BOX_NAME[trackData.track.source._codec], trackData);\n    }\n    else if (trackData.type === 'audio') {\n        const boxName = audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime);\n        assert(boxName);\n        sampleDescription = soundSampleDescription(boxName, trackData);\n    }\n    else if (trackData.type === 'subtitle') {\n        sampleDescription = subtitleSampleDescription(SUBTITLE_CODEC_TO_BOX_NAME[trackData.track.source._codec], trackData);\n    }\n    assert(sampleDescription);\n    return fullBox('stsd', 0, 0, [\n        u32(1), // Entry count\n    ], [\n        sampleDescription,\n    ]);\n};\n/** Video Sample Description Box: Contains information that defines how to interpret video media data. */\nexport const videoSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n    u16(0), // Pre-defined\n    u16(0), // Reserved\n    Array(12).fill(0), // Pre-defined\n    u16(trackData.info.width), // Width\n    u16(trackData.info.height), // Height\n    u32(0x00480000), // Horizontal resolution\n    u32(0x00480000), // Vertical resolution\n    u32(0), // Reserved\n    u16(1), // Frame count\n    Array(32).fill(0), // Compressor name\n    u16(0x0018), // Depth\n    i16(0xffff), // Pre-defined\n], [\n    VIDEO_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n    colorSpaceIsComplete(trackData.info.decoderConfig.colorSpace) ? colr(trackData) : null,\n]);\n/** Colour Information Box: Specifies the color space of the video. */\nexport const colr = (trackData) => box('colr', [\n    ascii('nclx'), // Colour type\n    u16(COLOR_PRIMARIES_MAP[trackData.info.decoderConfig.colorSpace.primaries]), // Colour primaries\n    u16(TRANSFER_CHARACTERISTICS_MAP[trackData.info.decoderConfig.colorSpace.transfer]), // Transfer characteristics\n    u16(MATRIX_COEFFICIENTS_MAP[trackData.info.decoderConfig.colorSpace.matrix]), // Matrix coefficients\n    u8((trackData.info.decoderConfig.colorSpace.fullRange ? 1 : 0) << 7), // Full range flag\n]);\n/** AVC Configuration Box: Provides additional information to the decoder. */\nexport const avcC = (trackData) => trackData.info.decoderConfig && box('avcC', [\n    // For AVC, description is an AVCDecoderConfigurationRecord, so nothing else to do here\n    ...toUint8Array(trackData.info.decoderConfig.description),\n]);\n/** HEVC Configuration Box: Provides additional information to the decoder. */\nexport const hvcC = (trackData) => trackData.info.decoderConfig && box('hvcC', [\n    // For HEVC, description is an HEVCDecoderConfigurationRecord, so nothing else to do here\n    ...toUint8Array(trackData.info.decoderConfig.description),\n]);\n/** VP Configuration Box: Provides additional information to the decoder. */\nexport const vpcC = (trackData) => {\n    // Reference: https://www.webmproject.org/vp9/mp4/\n    if (!trackData.info.decoderConfig) {\n        return null;\n    }\n    const decoderConfig = trackData.info.decoderConfig;\n    const parts = decoderConfig.codec.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1; // 4:2:0 colocated with luma (0,0)\n    const videoFullRangeFlag = parts[8] ? Number(parts[8]) : Number(decoderConfig.colorSpace?.fullRange ?? 0);\n    const thirdByte = (bitDepth << 4) + (chromaSubsampling << 1) + videoFullRangeFlag;\n    const colourPrimaries = parts[5]\n        ? Number(parts[5])\n        : decoderConfig.colorSpace?.primaries\n            ? COLOR_PRIMARIES_MAP[decoderConfig.colorSpace.primaries]\n            : 2; // Default to undetermined\n    const transferCharacteristics = parts[6]\n        ? Number(parts[6])\n        : decoderConfig.colorSpace?.transfer\n            ? TRANSFER_CHARACTERISTICS_MAP[decoderConfig.colorSpace.transfer]\n            : 2;\n    const matrixCoefficients = parts[7]\n        ? Number(parts[7])\n        : decoderConfig.colorSpace?.matrix\n            ? MATRIX_COEFFICIENTS_MAP[decoderConfig.colorSpace.matrix]\n            : 2;\n    return fullBox('vpcC', 1, 0, [\n        u8(profile), // Profile\n        u8(level), // Level\n        u8(thirdByte), // Bit depth, chroma subsampling, full range\n        u8(colourPrimaries), // Colour primaries\n        u8(transferCharacteristics), // Transfer characteristics\n        u8(matrixCoefficients), // Matrix coefficients\n        u16(0), // Codec initialization data size\n    ]);\n};\n/** AV1 Configuration Box: Provides additional information to the decoder. */\nexport const av1C = (trackData) => {\n    return box('av1C', generateAv1CodecConfigurationFromCodecString(trackData.info.decoderConfig.codec));\n};\n/** Sound Sample Description Box: Contains information that defines how to interpret sound media data. */\nexport const soundSampleDescription = (compressionType, trackData) => {\n    let version = 0;\n    let contents;\n    let sampleSizeInBits = 16;\n    if (PCM_AUDIO_CODECS.includes(trackData.track.source._codec)) {\n        const codec = trackData.track.source._codec;\n        const { sampleSize } = parsePcmCodec(codec);\n        sampleSizeInBits = 8 * sampleSize;\n        if (sampleSizeInBits > 16) {\n            version = 1;\n        }\n    }\n    if (version === 0) {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(sampleSizeInBits), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n        ];\n    }\n    else {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(Math.min(sampleSizeInBits, 16)), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n            u32(1), // Samples per packet (must be 1 for uncompressed formats)\n            u32(sampleSizeInBits / 8), // Bytes per packet\n            u32(trackData.info.numberOfChannels * sampleSizeInBits / 8), // Bytes per frame\n            u32(2), // Bytes per sample (constant in FFmpeg)\n        ];\n    }\n    return box(compressionType, contents, [\n        audioCodecToConfigurationBox(trackData.track.source._codec, trackData.muxer.isQuickTime)?.(trackData) ?? null,\n    ]);\n};\n/** MPEG-4 Elementary Stream Descriptor Box. */\nexport const esds = (trackData) => {\n    // We build up the bytes in a layered way which reflects the nested structure\n    let objectTypeIndication;\n    switch (trackData.track.source._codec) {\n        case 'aac':\n            {\n                objectTypeIndication = 0x40;\n            }\n            ;\n            break;\n        case 'mp3':\n            {\n                objectTypeIndication = 0x6b;\n            }\n            ;\n            break;\n        case 'vorbis':\n            {\n                objectTypeIndication = 0xdd;\n            }\n            ;\n            break;\n        default: throw new Error(`Unhandled audio codec: ${trackData.track.source._codec}`);\n    }\n    let bytes = [\n        ...u8(objectTypeIndication), // Object type indication\n        ...u8(0x15), // stream type(6bits)=5 audio, flags(2bits)=1\n        ...u24(0), // 24bit buffer size\n        ...u32(0), // max bitrate\n        ...u32(0), // avg bitrate\n    ];\n    if (trackData.info.decoderConfig.description) {\n        const description = toUint8Array(trackData.info.decoderConfig.description);\n        // Add the decoder description to the end\n        bytes = [\n            ...bytes,\n            ...u8(0x05), // TAG(5) = DecoderSpecificInfo\n            ...variableUnsignedInt(description.byteLength),\n            ...description,\n        ];\n    }\n    bytes = [\n        ...u16(1), // ES_ID = 1\n        ...u8(0x00), // flags etc = 0\n        ...u8(0x04), // TAG(4) = ES Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n        ...u8(0x06), // TAG(6)\n        ...u8(0x01), // length\n        ...u8(0x02), // data\n    ];\n    bytes = [\n        ...u8(0x03), // TAG(3) = Object Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n    ];\n    return fullBox('esds', 0, 0, bytes);\n};\nexport const wave = (trackData) => {\n    return box('wave', undefined, [\n        frma(trackData),\n        enda(trackData),\n        box('\\x00\\x00\\x00\\x00'), // NULL tag at the end\n    ]);\n};\nexport const frma = (trackData) => {\n    return box('frma', [\n        ascii(audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime)),\n    ]);\n};\n// This box specifies PCM endianness\nexport const enda = (trackData) => {\n    const { littleEndian } = parsePcmCodec(trackData.track.source._codec);\n    return box('enda', [\n        u16(+littleEndian),\n    ]);\n};\n/** Opus Specific Box. */\nexport const dOps = (trackData) => {\n    let outputChannelCount = trackData.info.numberOfChannels;\n    // Default PreSkip, should be at least 80 milliseconds worth of playback, measured in 48000 Hz samples\n    let preSkip = 3840;\n    let inputSampleRate = trackData.info.sampleRate;\n    let outputGain = 0;\n    let channelMappingFamily = 0;\n    let channelMappingTable = new Uint8Array(0);\n    // Read preskip and from codec private data from the encoder\n    // https://www.rfc-editor.org/rfc/rfc7845#section-5\n    const description = trackData.info.decoderConfig?.description;\n    if (description) {\n        assert(description.byteLength >= 18);\n        const bytes = toUint8Array(description);\n        const header = parseOpusIdentificationHeader(bytes);\n        outputChannelCount = header.outputChannelCount;\n        preSkip = header.preSkip;\n        inputSampleRate = header.inputSampleRate;\n        outputGain = header.outputGain;\n        channelMappingFamily = header.channelMappingFamily;\n        if (header.channelMappingTable) {\n            channelMappingTable = header.channelMappingTable;\n        }\n    }\n    // https://www.opus-codec.org/docs/opus_in_isobmff.html\n    return box('dOps', [\n        u8(0), // Version\n        u8(outputChannelCount), // OutputChannelCount\n        u16(preSkip), // PreSkip\n        u32(inputSampleRate), // InputSampleRate\n        i16(outputGain), // OutputGain\n        u8(channelMappingFamily), // ChannelMappingFamily\n        ...channelMappingTable,\n    ]);\n};\n/** FLAC specific box. */\nexport const dfLa = (trackData) => {\n    const description = trackData.info.decoderConfig?.description;\n    assert(description);\n    const bytes = toUint8Array(description);\n    return fullBox('dfLa', 0, 0, [\n        ...bytes.subarray(4),\n    ]);\n};\n/** PCM Configuration Box, ISO/IEC 23003-5. */\nconst pcmC = (trackData) => {\n    const { littleEndian, sampleSize } = parsePcmCodec(trackData.track.source._codec);\n    const formatFlags = +littleEndian;\n    return fullBox('pcmC', 0, 0, [\n        u8(formatFlags),\n        u8(8 * sampleSize),\n    ]);\n};\nexport const subtitleSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n], [\n    SUBTITLE_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n]);\nexport const vttC = (trackData) => box('vttC', [\n    ...textEncoder.encode(trackData.info.config.description),\n]);\nexport const txtC = (textConfig) => fullBox('txtC', 0, 0, [\n    ...textConfig, 0, // Text config (null-terminated)\n]);\n/**\n * Time-To-Sample Box: Stores duration information for a media's samples, providing a mapping from a time in a media\n * to the corresponding data sample. The table is compact, meaning that consecutive samples with the same time delta\n * will be grouped.\n */\nexport const stts = (trackData) => {\n    return fullBox('stts', 0, 0, [\n        u32(trackData.timeToSampleTable.length), // Number of entries\n        trackData.timeToSampleTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            u32(x.sampleDelta), // Sample duration\n        ]),\n    ]);\n};\n/** Sync Sample Box: Identifies the key frames in the media, marking the random access points within a stream. */\nexport const stss = (trackData) => {\n    if (trackData.samples.every(x => x.type === 'key'))\n        return null; // No stss box -> every frame is a key frame\n    const keySamples = [...trackData.samples.entries()].filter(([, sample]) => sample.type === 'key');\n    return fullBox('stss', 0, 0, [\n        u32(keySamples.length), // Number of entries\n        keySamples.map(([index]) => u32(index + 1)), // Sync sample table\n    ]);\n};\n/**\n * Sample-To-Chunk Box: As samples are added to a media, they are collected into chunks that allow optimized data\n * access. A chunk contains one or more samples. Chunks in a media may have different sizes, and the samples within a\n * chunk may have different sizes. The Sample-To-Chunk Box stores chunk information for the samples in a media, stored\n * in a compactly-coded fashion.\n */\nexport const stsc = (trackData) => {\n    return fullBox('stsc', 0, 0, [\n        u32(trackData.compactlyCodedChunkTable.length), // Number of entries\n        trackData.compactlyCodedChunkTable.map(x => [\n            u32(x.firstChunk), // First chunk\n            u32(x.samplesPerChunk), // Samples per chunk\n            u32(1), // Sample description index\n        ]),\n    ]);\n};\n/** Sample Size Box: Specifies the byte size of each sample in the media. */\nexport const stsz = (trackData) => {\n    if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n        const { sampleSize } = parsePcmCodec(trackData.track.source._codec);\n        // With PCM, every sample has the same size\n        return fullBox('stsz', 0, 0, [\n            u32(sampleSize * trackData.info.numberOfChannels), // Sample size\n            u32(trackData.samples.reduce((acc, x) => acc + intoTimescale(x.duration, trackData.timescale), 0)),\n        ]);\n    }\n    return fullBox('stsz', 0, 0, [\n        u32(0), // Sample size (0 means non-constant size)\n        u32(trackData.samples.length), // Number of entries\n        trackData.samples.map(x => u32(x.size)), // Sample size table\n    ]);\n};\n/** Chunk Offset Box: Identifies the location of each chunk of data in the media's data stream, relative to the file. */\nexport const stco = (trackData) => {\n    if (trackData.finalizedChunks.length > 0 && last(trackData.finalizedChunks).offset >= 2 ** 32) {\n        // If the file is large, use the co64 box\n        return fullBox('co64', 0, 0, [\n            u32(trackData.finalizedChunks.length), // Number of entries\n            trackData.finalizedChunks.map(x => u64(x.offset)), // Chunk offset table\n        ]);\n    }\n    return fullBox('stco', 0, 0, [\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(x => u32(x.offset)), // Chunk offset table\n    ]);\n};\n/**\n * Composition Time to Sample Box: Stores composition time offset information (PTS-DTS) for a\n * media's samples. The table is compact, meaning that consecutive samples with the same time\n * composition time offset will be grouped.\n */\nexport const ctts = (trackData) => {\n    return fullBox('ctts', 1, 0, [\n        u32(trackData.compositionTimeOffsetTable.length), // Number of entries\n        trackData.compositionTimeOffsetTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            i32(x.sampleCompositionTimeOffset), // Sample offset\n        ]),\n    ]);\n};\n/**\n * Composition to Decode Box: Stores information about the composition and display times of the media samples.\n */\nexport const cslg = (trackData) => {\n    let leastDecodeToDisplayDelta = Infinity;\n    let greatestDecodeToDisplayDelta = -Infinity;\n    let compositionStartTime = Infinity;\n    let compositionEndTime = -Infinity;\n    assert(trackData.compositionTimeOffsetTable.length > 0);\n    assert(trackData.samples.length > 0);\n    for (let i = 0; i < trackData.compositionTimeOffsetTable.length; i++) {\n        const entry = trackData.compositionTimeOffsetTable[i];\n        leastDecodeToDisplayDelta = Math.min(leastDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n        greatestDecodeToDisplayDelta = Math.max(greatestDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n    }\n    for (let i = 0; i < trackData.samples.length; i++) {\n        const sample = trackData.samples[i];\n        compositionStartTime = Math.min(compositionStartTime, intoTimescale(sample.timestamp, trackData.timescale));\n        compositionEndTime = Math.max(compositionEndTime, intoTimescale(sample.timestamp + sample.duration, trackData.timescale));\n    }\n    const compositionToDtsShift = Math.max(-leastDecodeToDisplayDelta, 0);\n    if (compositionEndTime >= 2 ** 31) {\n        // For very large files, the composition end time can't be represented in i32, so let's just scrap the box in\n        // that case. QuickTime fails to read the file if there's a cslg box with version 1, so that's sadly not an\n        // option.\n        return null;\n    }\n    return fullBox('cslg', 0, 0, [\n        i32(compositionToDtsShift), // Composition to DTS shift\n        i32(leastDecodeToDisplayDelta), // Least decode to display delta\n        i32(greatestDecodeToDisplayDelta), // Greatest decode to display delta\n        i32(compositionStartTime), // Composition start time\n        i32(compositionEndTime), // Composition end time\n    ]);\n};\n/**\n * Movie Extends Box: This box signals to readers that the file is fragmented. Contains a single Track Extends Box\n * for each track in the movie.\n */\nexport const mvex = (trackDatas) => {\n    return box('mvex', undefined, trackDatas.map(trex));\n};\n/** Track Extends Box: Contains the default values used by the movie fragments. */\nexport const trex = (trackData) => {\n    return fullBox('trex', 0, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(1), // Default sample description index\n        u32(0), // Default sample duration\n        u32(0), // Default sample size\n        u32(0), // Default sample flags\n    ]);\n};\n/**\n * Movie Fragment Box: The movie fragments extend the presentation in time. They provide the information that would\n * previously have been\tin the Movie Box.\n */\nexport const moof = (sequenceNumber, trackDatas) => {\n    return box('moof', undefined, [\n        mfhd(sequenceNumber),\n        ...trackDatas.map(traf),\n    ]);\n};\n/** Movie Fragment Header Box: Contains a sequence number as a safety check. */\nexport const mfhd = (sequenceNumber) => {\n    return fullBox('mfhd', 0, 0, [\n        u32(sequenceNumber), // Sequence number\n    ]);\n};\nconst fragmentSampleFlags = (sample) => {\n    let byte1 = 0;\n    let byte2 = 0;\n    const byte3 = 0;\n    const byte4 = 0;\n    const sampleIsDifferenceSample = sample.type === 'delta';\n    byte2 |= +sampleIsDifferenceSample;\n    if (sampleIsDifferenceSample) {\n        byte1 |= 1; // There is redundant coding in this sample\n    }\n    else {\n        byte1 |= 2; // There is no redundant coding in this sample\n    }\n    // Note that there are a lot of other flags to potentially set here, but most are irrelevant / non-necessary\n    return byte1 << 24 | byte2 << 16 | byte3 << 8 | byte4;\n};\n/** Track Fragment Box */\nexport const traf = (trackData) => {\n    return box('traf', undefined, [\n        tfhd(trackData),\n        tfdt(trackData),\n        trun(trackData),\n    ]);\n};\n/** Track Fragment Header Box: Provides a reference to the extended track, and flags. */\nexport const tfhd = (trackData) => {\n    assert(trackData.currentChunk);\n    let tfFlags = 0;\n    tfFlags |= 0x00008; // Default sample duration present\n    tfFlags |= 0x00010; // Default sample size present\n    tfFlags |= 0x00020; // Default sample flags present\n    tfFlags |= 0x20000; // Default base is moof\n    // Prefer the second sample over the first one, as the first one is a sync sample and therefore the \"odd one out\"\n    const referenceSample = trackData.currentChunk.samples[1] ?? trackData.currentChunk.samples[0];\n    const referenceSampleInfo = {\n        duration: referenceSample.timescaleUnitsToNextSample,\n        size: referenceSample.size,\n        flags: fragmentSampleFlags(referenceSample),\n    };\n    return fullBox('tfhd', 0, tfFlags, [\n        u32(trackData.track.id), // Track ID\n        u32(referenceSampleInfo.duration), // Default sample duration\n        u32(referenceSampleInfo.size), // Default sample size\n        u32(referenceSampleInfo.flags), // Default sample flags\n    ]);\n};\n/**\n * Track Fragment Decode Time Box: Provides the absolute decode time of the first sample of the fragment. This is\n * useful for performing random access on the media file.\n */\nexport const tfdt = (trackData) => {\n    assert(trackData.currentChunk);\n    return fullBox('tfdt', 1, 0, [\n        u64(intoTimescale(trackData.currentChunk.startTimestamp, trackData.timescale)), // Base Media Decode Time\n    ]);\n};\n/** Track Run Box: Specifies a run of contiguous samples for a given track. */\nexport const trun = (trackData) => {\n    assert(trackData.currentChunk);\n    const allSampleDurations = trackData.currentChunk.samples.map(x => x.timescaleUnitsToNextSample);\n    const allSampleSizes = trackData.currentChunk.samples.map(x => x.size);\n    const allSampleFlags = trackData.currentChunk.samples.map(fragmentSampleFlags);\n    const allSampleCompositionTimeOffsets = trackData.currentChunk.samples\n        .map(x => intoTimescale(x.timestamp - x.decodeTimestamp, trackData.timescale));\n    const uniqueSampleDurations = new Set(allSampleDurations);\n    const uniqueSampleSizes = new Set(allSampleSizes);\n    const uniqueSampleFlags = new Set(allSampleFlags);\n    const uniqueSampleCompositionTimeOffsets = new Set(allSampleCompositionTimeOffsets);\n    const firstSampleFlagsPresent = uniqueSampleFlags.size === 2 && allSampleFlags[0] !== allSampleFlags[1];\n    const sampleDurationPresent = uniqueSampleDurations.size > 1;\n    const sampleSizePresent = uniqueSampleSizes.size > 1;\n    const sampleFlagsPresent = !firstSampleFlagsPresent && uniqueSampleFlags.size > 1;\n    const sampleCompositionTimeOffsetsPresent = uniqueSampleCompositionTimeOffsets.size > 1 || [...uniqueSampleCompositionTimeOffsets].some(x => x !== 0);\n    let flags = 0;\n    flags |= 0x0001; // Data offset present\n    flags |= 0x0004 * +firstSampleFlagsPresent; // First sample flags present\n    flags |= 0x0100 * +sampleDurationPresent; // Sample duration present\n    flags |= 0x0200 * +sampleSizePresent; // Sample size present\n    flags |= 0x0400 * +sampleFlagsPresent; // Sample flags present\n    flags |= 0x0800 * +sampleCompositionTimeOffsetsPresent; // Sample composition time offsets present\n    return fullBox('trun', 1, flags, [\n        u32(trackData.currentChunk.samples.length), // Sample count\n        u32(trackData.currentChunk.offset - trackData.currentChunk.moofOffset || 0), // Data offset\n        firstSampleFlagsPresent ? u32(allSampleFlags[0]) : [],\n        trackData.currentChunk.samples.map((_, i) => [\n            sampleDurationPresent ? u32(allSampleDurations[i]) : [], // Sample duration\n            sampleSizePresent ? u32(allSampleSizes[i]) : [], // Sample size\n            sampleFlagsPresent ? u32(allSampleFlags[i]) : [], // Sample flags\n            // Sample composition time offsets\n            sampleCompositionTimeOffsetsPresent ? i32(allSampleCompositionTimeOffsets[i]) : [],\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Box: For each track, provides pointers to sync samples within the file\n * for random access.\n */\nexport const mfra = (trackDatas) => {\n    return box('mfra', undefined, [\n        ...trackDatas.map(tfra),\n        mfro(),\n    ]);\n};\n/** Track Fragment Random Access Box: Provides pointers to sync samples within the file for random access. */\nexport const tfra = (trackData, trackIndex) => {\n    const version = 1; // Using this version allows us to use 64-bit time and offset values\n    return fullBox('tfra', version, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(0b111111), // This specifies that traf number, trun number and sample number are 32-bit ints\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(chunk => [\n            u64(intoTimescale(chunk.samples[0].timestamp, trackData.timescale)), // Time (in presentation time)\n            u64(chunk.moofOffset), // moof offset\n            u32(trackIndex + 1), // traf number\n            u32(1), // trun number\n            u32(1), // Sample number\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Offset Box: Provides the size of the enclosing mfra box. This box can be used by readers\n * to quickly locate the mfra box by searching from the end of the file.\n */\nexport const mfro = () => {\n    return fullBox('mfro', 0, 0, [\n        // This value needs to be overwritten manually from the outside, where the actual size of the enclosing mfra box\n        // is known\n        u32(0), // Size\n    ]);\n};\n/** VTT Empty Cue Box */\nexport const vtte = () => box('vtte');\n/** VTT Cue Box */\nexport const vttc = (payload, timestamp, identifier, settings, sourceId) => box('vttc', undefined, [\n    sourceId !== null ? box('vsid', [i32(sourceId)]) : null,\n    identifier !== null ? box('iden', [...textEncoder.encode(identifier)]) : null,\n    timestamp !== null ? box('ctim', [...textEncoder.encode(formatSubtitleTimestamp(timestamp))]) : null,\n    settings !== null ? box('sttg', [...textEncoder.encode(settings)]) : null,\n    box('payl', [...textEncoder.encode(payload)]),\n]);\n/** VTT Additional Text Box */\nexport const vtta = (notes) => box('vtta', [...textEncoder.encode(notes)]);\nconst VIDEO_CODEC_TO_BOX_NAME = {\n    avc: 'avc1',\n    hevc: 'hvc1',\n    vp8: 'vp08',\n    vp9: 'vp09',\n    av1: 'av01',\n};\nconst VIDEO_CODEC_TO_CONFIGURATION_BOX = {\n    avc: avcC,\n    hevc: hvcC,\n    vp8: vpcC,\n    vp9: vpcC,\n    av1: av1C,\n};\nconst audioCodecToBoxName = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return 'mp4a';\n        case 'mp3': return 'mp4a';\n        case 'opus': return 'Opus';\n        case 'vorbis': return 'mp4a';\n        case 'flac': return 'fLaC';\n        case 'ulaw': return 'ulaw';\n        case 'alaw': return 'alaw';\n        case 'pcm-u8': return 'raw ';\n        case 'pcm-s8': return 'sowt';\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s16': return 'sowt';\n            case 'pcm-s16be': return 'twos';\n            case 'pcm-s24': return 'in24';\n            case 'pcm-s24be': return 'in24';\n            case 'pcm-s32': return 'in32';\n            case 'pcm-s32be': return 'in32';\n            case 'pcm-f32': return 'fl32';\n            case 'pcm-f32be': return 'fl32';\n            case 'pcm-f64': return 'fl64';\n            case 'pcm-f64be': return 'fl64';\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return 'ipcm';\n            case 'pcm-s16be': return 'ipcm';\n            case 'pcm-s24': return 'ipcm';\n            case 'pcm-s24be': return 'ipcm';\n            case 'pcm-s32': return 'ipcm';\n            case 'pcm-s32be': return 'ipcm';\n            case 'pcm-f32': return 'fpcm';\n            case 'pcm-f32be': return 'fpcm';\n            case 'pcm-f64': return 'fpcm';\n            case 'pcm-f64be': return 'fpcm';\n        }\n    }\n};\nconst audioCodecToConfigurationBox = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return esds;\n        case 'mp3': return esds;\n        case 'opus': return dOps;\n        case 'vorbis': return esds;\n        case 'flac': return dfLa;\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s24': return wave;\n            case 'pcm-s24be': return wave;\n            case 'pcm-s32': return wave;\n            case 'pcm-s32be': return wave;\n            case 'pcm-f32': return wave;\n            case 'pcm-f32be': return wave;\n            case 'pcm-f64': return wave;\n            case 'pcm-f64be': return wave;\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return pcmC;\n            case 'pcm-s16be': return pcmC;\n            case 'pcm-s24': return pcmC;\n            case 'pcm-s24be': return pcmC;\n            case 'pcm-s32': return pcmC;\n            case 'pcm-s32be': return pcmC;\n            case 'pcm-f32': return pcmC;\n            case 'pcm-f32be': return pcmC;\n            case 'pcm-f64': return pcmC;\n            case 'pcm-f64be': return pcmC;\n        }\n    }\n    return null;\n};\nconst SUBTITLE_CODEC_TO_BOX_NAME = {\n    webvtt: 'wvtt',\n};\nconst SUBTITLE_CODEC_TO_CONFIGURATION_BOX = {\n    webvtt: vttC,\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1432, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/writer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert } from './misc.js';\nexport class Writer {\n    constructor() {\n        /** Setting this to true will cause the writer to ensure data is written in a strictly monotonic, streamable way. */\n        this.ensureMonotonicity = false;\n        this.trackedWrites = null;\n        this.trackedStart = -1;\n        this.trackedEnd = -1;\n    }\n    start() { }\n    maybeTrackWrites(data) {\n        if (!this.trackedWrites) {\n            return;\n        }\n        // Handle negative relative write positions\n        let pos = this.getPos();\n        if (pos < this.trackedStart) {\n            if (pos + data.byteLength <= this.trackedStart) {\n                return;\n            }\n            data = data.subarray(this.trackedStart - pos);\n            pos = 0;\n        }\n        const neededSize = pos + data.byteLength - this.trackedStart;\n        let newLength = this.trackedWrites.byteLength;\n        while (newLength < neededSize) {\n            newLength *= 2;\n        }\n        // Check if we need to resize the buffer\n        if (newLength !== this.trackedWrites.byteLength) {\n            const copy = new Uint8Array(newLength);\n            copy.set(this.trackedWrites, 0);\n            this.trackedWrites = copy;\n        }\n        this.trackedWrites.set(data, pos - this.trackedStart);\n        this.trackedEnd = Math.max(this.trackedEnd, pos + data.byteLength);\n    }\n    startTrackingWrites() {\n        this.trackedWrites = new Uint8Array(2 ** 10);\n        this.trackedStart = this.getPos();\n        this.trackedEnd = this.trackedStart;\n    }\n    stopTrackingWrites() {\n        if (!this.trackedWrites) {\n            throw new Error('Internal error: Can\\'t get tracked writes since nothing was tracked.');\n        }\n        const slice = this.trackedWrites.subarray(0, this.trackedEnd - this.trackedStart);\n        const result = {\n            data: slice,\n            start: this.trackedStart,\n            end: this.trackedEnd,\n        };\n        this.trackedWrites = null;\n        return result;\n    }\n}\nconst ARRAY_BUFFER_INITIAL_SIZE = 2 ** 16;\nconst ARRAY_BUFFER_MAX_SIZE = 2 ** 32;\nexport class BufferTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.maxPos = 0;\n        this.target = target;\n        this.supportsResize = 'resize' in new ArrayBuffer(0);\n        if (this.supportsResize) {\n            try {\n                // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE, { maxByteLength: ARRAY_BUFFER_MAX_SIZE });\n            }\n            catch {\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n                this.supportsResize = false;\n            }\n        }\n        else {\n            this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n        }\n        this.bytes = new Uint8Array(this.buffer);\n    }\n    ensureSize(size) {\n        let newLength = this.buffer.byteLength;\n        while (newLength < size)\n            newLength *= 2;\n        if (newLength === this.buffer.byteLength)\n            return;\n        if (newLength > ARRAY_BUFFER_MAX_SIZE) {\n            throw new Error(`ArrayBuffer exceeded maximum size of ${ARRAY_BUFFER_MAX_SIZE} bytes. Please consider using another`\n                + ` target.`);\n        }\n        if (this.supportsResize) {\n            // Use resize if it exists\n            // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            this.buffer.resize(newLength);\n            // The Uint8Array scales automatically\n        }\n        else {\n            const newBuffer = new ArrayBuffer(newLength);\n            const newBytes = new Uint8Array(newBuffer);\n            newBytes.set(this.bytes, 0);\n            this.buffer = newBuffer;\n            this.bytes = newBytes;\n        }\n    }\n    write(data) {\n        this.maybeTrackWrites(data);\n        this.ensureSize(this.pos + data.byteLength);\n        this.bytes.set(data, this.pos);\n        this.pos += data.byteLength;\n        this.maxPos = Math.max(this.maxPos, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() { }\n    async finalize() {\n        this.ensureSize(this.pos);\n        this.target.buffer = this.buffer.slice(0, Math.max(this.maxPos, this.pos));\n    }\n    async close() { }\n    getSlice(start, end) {\n        return this.bytes.slice(start, end);\n    }\n}\nconst DEFAULT_CHUNK_SIZE = 2 ** 24;\nconst MAX_CHUNKS_AT_ONCE = 2;\n/**\n * Writes to a StreamTarget every time it is flushed, sending out all of the new data written since the\n * last flush. This is useful for streaming applications, like piping the output to disk. When using the chunked mode,\n * data will first be accumulated in larger chunks, and then the entire chunk will be flushed out at once when ready.\n */\nexport class StreamTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.sections = [];\n        this.lastWriteEnd = 0;\n        this.lastFlushEnd = 0;\n        this.writer = null;\n        /**\n         * The data is divided up into fixed-size chunks, whose contents are first filled in RAM and then flushed out.\n         * A chunk is flushed if all of its contents have been written.\n         */\n        this.chunks = [];\n        this.target = target;\n        this.chunked = target._options.chunked ?? false;\n        this.chunkSize = target._options.chunkSize ?? DEFAULT_CHUNK_SIZE;\n    }\n    start() {\n        this.writer = this.target._writable.getWriter();\n    }\n    write(data) {\n        if (this.pos > this.lastWriteEnd) {\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        this.maybeTrackWrites(data);\n        this.sections.push({\n            data: data.slice(),\n            start: this.pos,\n        });\n        this.pos += data.byteLength;\n        this.lastWriteEnd = Math.max(this.lastWriteEnd, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() {\n        if (this.pos > this.lastWriteEnd) {\n            // There's a \"void\" between the last written byte and the next byte we're about to write. Let's pad that\n            // void with zeroes explicitly.\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        assert(this.writer);\n        if (this.sections.length === 0)\n            return;\n        const chunks = [];\n        const sorted = [...this.sections].sort((a, b) => a.start - b.start);\n        chunks.push({\n            start: sorted[0].start,\n            size: sorted[0].data.byteLength,\n        });\n        // Figure out how many contiguous chunks we have\n        for (let i = 1; i < sorted.length; i++) {\n            const lastChunk = chunks[chunks.length - 1];\n            const section = sorted[i];\n            if (section.start <= lastChunk.start + lastChunk.size) {\n                lastChunk.size = Math.max(lastChunk.size, section.start + section.data.byteLength - lastChunk.start);\n            }\n            else {\n                chunks.push({\n                    start: section.start,\n                    size: section.data.byteLength,\n                });\n            }\n        }\n        for (const chunk of chunks) {\n            chunk.data = new Uint8Array(chunk.size);\n            // Make sure to write the data in the correct order for correct overwriting\n            for (const section of this.sections) {\n                // Check if the section is in the chunk\n                if (chunk.start <= section.start && section.start < chunk.start + chunk.size) {\n                    chunk.data.set(section.data, section.start - chunk.start);\n                }\n            }\n            if (this.writer.desiredSize !== null && this.writer.desiredSize <= 0) {\n                await this.writer.ready; // Allow the writer to apply backpressure\n            }\n            if (this.chunked) {\n                // Let's first gather the data into bigger chunks before writing it\n                this.writeDataIntoChunks(chunk.data, chunk.start);\n                this.tryToFlushChunks();\n            }\n            else {\n                if (this.ensureMonotonicity && chunk.start !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                // Write out the data immediately\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data,\n                    position: chunk.start,\n                });\n                this.lastFlushEnd = chunk.start + chunk.data.byteLength;\n            }\n        }\n        this.sections.length = 0;\n    }\n    writeDataIntoChunks(data, position) {\n        // First, find the chunk to write the data into, or create one if none exists\n        let chunkIndex = this.chunks.findIndex(x => x.start <= position && position < x.start + this.chunkSize);\n        if (chunkIndex === -1)\n            chunkIndex = this.createChunk(position);\n        const chunk = this.chunks[chunkIndex];\n        // Figure out how much to write to the chunk, and then write to the chunk\n        const relativePosition = position - chunk.start;\n        const toWrite = data.subarray(0, Math.min(this.chunkSize - relativePosition, data.byteLength));\n        chunk.data.set(toWrite, relativePosition);\n        // Create a section describing the region of data that was just written to\n        const section = {\n            start: relativePosition,\n            end: relativePosition + toWrite.byteLength,\n        };\n        this.insertSectionIntoChunk(chunk, section);\n        // Queue chunk for flushing to target if it has been fully written to\n        if (chunk.written[0].start === 0 && chunk.written[0].end === this.chunkSize) {\n            chunk.shouldFlush = true;\n        }\n        // Make sure we don't hold too many chunks in memory at once to keep memory usage down\n        if (this.chunks.length > MAX_CHUNKS_AT_ONCE) {\n            // Flush all but the last chunk\n            for (let i = 0; i < this.chunks.length - 1; i++) {\n                this.chunks[i].shouldFlush = true;\n            }\n            this.tryToFlushChunks();\n        }\n        // If the data didn't fit in one chunk, recurse with the remaining data\n        if (toWrite.byteLength < data.byteLength) {\n            this.writeDataIntoChunks(data.subarray(toWrite.byteLength), position + toWrite.byteLength);\n        }\n    }\n    insertSectionIntoChunk(chunk, section) {\n        let low = 0;\n        let high = chunk.written.length - 1;\n        let index = -1;\n        // Do a binary search to find the last section with a start not larger than `section`'s start\n        while (low <= high) {\n            const mid = Math.floor(low + (high - low + 1) / 2);\n            if (chunk.written[mid].start <= section.start) {\n                low = mid + 1;\n                index = mid;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        // Insert the new section\n        chunk.written.splice(index + 1, 0, section);\n        if (index === -1 || chunk.written[index].end < section.start)\n            index++;\n        // Merge overlapping sections\n        while (index < chunk.written.length - 1 && chunk.written[index].end >= chunk.written[index + 1].start) {\n            chunk.written[index].end = Math.max(chunk.written[index].end, chunk.written[index + 1].end);\n            chunk.written.splice(index + 1, 1);\n        }\n    }\n    createChunk(includesPosition) {\n        const start = Math.floor(includesPosition / this.chunkSize) * this.chunkSize;\n        const chunk = {\n            start,\n            data: new Uint8Array(this.chunkSize),\n            written: [],\n            shouldFlush: false,\n        };\n        this.chunks.push(chunk);\n        this.chunks.sort((a, b) => a.start - b.start);\n        return this.chunks.indexOf(chunk);\n    }\n    tryToFlushChunks(force = false) {\n        assert(this.writer);\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            if (!chunk.shouldFlush && !force)\n                continue;\n            for (const section of chunk.written) {\n                const position = chunk.start + section.start;\n                if (this.ensureMonotonicity && position !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data.subarray(section.start, section.end),\n                    position,\n                });\n                this.lastFlushEnd = chunk.start + section.end;\n            }\n            this.chunks.splice(i--, 1);\n        }\n    }\n    finalize() {\n        if (this.chunked) {\n            this.tryToFlushChunks(true);\n        }\n        assert(this.writer);\n        return this.writer.close();\n    }\n    async close() {\n        return this.writer?.close();\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1776, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/target.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { BufferTargetWriter, StreamTargetWriter } from './writer.js';\n/**\n * Base class for targets, specifying where output files are written.\n * @public\n */\nexport class Target {\n    constructor() {\n        /** @internal */\n        this._output = null;\n    }\n}\n/**\n * A target that writes data directly into an ArrayBuffer in memory. Great for performance, but not suitable for very\n * large files. The buffer will be available once the output has been finalized.\n * @public\n */\nexport class BufferTarget extends Target {\n    constructor() {\n        super(...arguments);\n        /** Stores the final output buffer. Until the output is finalized, this will be null. */\n        this.buffer = null;\n    }\n    /** @internal */\n    _createWriter() {\n        return new BufferTargetWriter(this);\n    }\n}\n/**\n * This target writes data to a WritableStream, making it a general-purpose target for writing data anywhere. It is\n * also compatible with FileSystemWritableFileStream for use with the File System Access API. The WritableStream can\n * also apply backpressure, which will propagate to the output and throttle the encoders.\n * @public\n */\nexport class StreamTarget extends Target {\n    constructor(writable, options = {}) {\n        super();\n        if (!(writable instanceof WritableStream)) {\n            throw new TypeError('StreamTarget requires a WritableStream instance.');\n        }\n        if (options != null && typeof options !== 'object') {\n            throw new TypeError('StreamTarget options, when provided, must be an object.');\n        }\n        if (options.chunked !== undefined && typeof options.chunked !== 'boolean') {\n            throw new TypeError('options.chunked, when provided, must be a boolean.');\n        }\n        if (options.chunkSize !== undefined && (!Number.isInteger(options.chunkSize) || options.chunkSize < 1024)) {\n            throw new TypeError('options.chunkSize, when provided, must be an integer and not smaller than 1024.');\n        }\n        this._writable = writable;\n        this._options = options;\n    }\n    /** @internal */\n    _createWriter() {\n        return new StreamTargetWriter(this);\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;AACD;;AAKO,MAAM;IACT,aAAc;QACV,cAAc,GACd,IAAI,CAAC,OAAO,GAAG;IACnB;AACJ;AAMO,MAAM,qBAAqB;IAM9B,cAAc,GACd,gBAAgB;QACZ,OAAO,IAAI,uNAAA,CAAA,qBAAkB,CAAC,IAAI;IACtC;IARA,aAAc;QACV,KAAK,IAAI;QACT,sFAAsF,GACtF,IAAI,CAAC,MAAM,GAAG;IAClB;AAKJ;AAOO,MAAM,qBAAqB;IAkB9B,cAAc,GACd,gBAAgB;QACZ,OAAO,IAAI,uNAAA,CAAA,qBAAkB,CAAC,IAAI;IACtC;IApBA,YAAY,QAAQ,EAAE,UAAU,CAAC,CAAC,CAAE;QAChC,KAAK;QACL,IAAI,CAAC,CAAC,oBAAoB,cAAc,GAAG;YACvC,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,WAAW,QAAQ,OAAO,YAAY,UAAU;YAChD,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,QAAQ,OAAO,KAAK,aAAa,OAAO,QAAQ,OAAO,KAAK,WAAW;YACvE,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,QAAQ,SAAS,KAAK,aAAa,CAAC,CAAC,OAAO,SAAS,CAAC,QAAQ,SAAS,KAAK,QAAQ,SAAS,GAAG,IAAI,GAAG;YACvG,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,QAAQ,GAAG;IACpB;AAKJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1829, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/isobmff/isobmff-muxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { ftyp, IsobmffBoxWriter, mdat, mfra, moof, moov, vtta, vttc, vtte } from './isobmff-boxes.js';\nimport { Muxer } from '../muxer.js';\nimport { BufferTargetWriter } from '../writer.js';\nimport { assert, computeRationalApproximation, last, promiseWithResolvers } from '../misc.js';\nimport { MovOutputFormat } from '../output-format.js';\nimport { inlineTimestampRegex } from '../subtitles.js';\nimport { parsePcmCodec, PCM_AUDIO_CODECS, validateAudioChunkMetadata, validateSubtitleMetadata, validateVideoChunkMetadata, } from '../codec.js';\nimport { BufferTarget } from '../target.js';\nimport { extractAvcDecoderConfigurationRecord, extractHevcDecoderConfigurationRecord, serializeAvcDecoderConfigurationRecord, serializeHevcDecoderConfigurationRecord, transformAnnexBToLengthPrefixed, } from '../codec-data.js';\nimport { buildIsobmffMimeType } from './isobmff-misc.js';\nimport { MAX_BOX_HEADER_SIZE, MIN_BOX_HEADER_SIZE } from './isobmff-reader.js';\nexport const GLOBAL_TIMESCALE = 1000;\nconst TIMESTAMP_OFFSET = 2_082_844_800; // Seconds between Jan 1 1904 and Jan 1 1970\nexport const intoTimescale = (timeInSeconds, timescale, round = true) => {\n    const value = timeInSeconds * timescale;\n    return round ? Math.round(value) : value;\n};\nexport class IsobmffMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.auxTarget = new BufferTarget();\n        this.auxWriter = this.auxTarget._createWriter();\n        this.auxBoxWriter = new IsobmffBoxWriter(this.auxWriter);\n        this.mdat = null;\n        this.trackDatas = [];\n        this.allTracksKnown = promiseWithResolvers();\n        this.creationTime = Math.floor(Date.now() / 1000) + TIMESTAMP_OFFSET;\n        this.finalizedChunks = [];\n        this.nextFragmentNumber = 1;\n        // Only relevant for fragmented files, to make sure new fragments start with the highest timestamp seen so far\n        this.maxWrittenTimestamp = -Infinity;\n        this.format = format;\n        this.writer = output._writer;\n        this.boxWriter = new IsobmffBoxWriter(this.writer);\n        this.isQuickTime = format instanceof MovOutputFormat;\n        // If the fastStart option isn't defined, enable in-memory fast start if the target is an ArrayBuffer, as the\n        // memory usage remains identical\n        const fastStartDefault = this.writer instanceof BufferTargetWriter ? 'in-memory' : false;\n        this.fastStart = format._options.fastStart ?? fastStartDefault;\n        this.isFragmented = this.fastStart === 'fragmented';\n        if (this.fastStart === 'in-memory' || this.isFragmented) {\n            this.writer.ensureMonotonicity = true;\n        }\n        this.minimumFragmentDuration = format._options.minimumFragmentDuration ?? 1;\n    }\n    async start() {\n        const release = await this.mutex.acquire();\n        const holdsAvc = this.output._tracks.some(x => x.type === 'video' && x.source._codec === 'avc');\n        // Write the header\n        {\n            if (this.format._options.onFtyp) {\n                this.writer.startTrackingWrites();\n            }\n            this.boxWriter.writeBox(ftyp({\n                isQuickTime: this.isQuickTime,\n                holdsAvc: holdsAvc,\n                fragmented: this.isFragmented,\n            }));\n            if (this.format._options.onFtyp) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onFtyp(data, start);\n            }\n        }\n        if (this.fastStart === 'in-memory') {\n            this.mdat = mdat(false);\n        }\n        else if (this.isFragmented) {\n            // We write the moov box once we write out the first fragment to make sure we get the decoder configs\n        }\n        else {\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat = mdat(true); // Reserve large size by default, can refine this when finalizing.\n            this.boxWriter.writeBox(this.mdat);\n        }\n        await this.writer.flush();\n        release();\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        const codecStrings = this.trackDatas.map((trackData) => {\n            if (trackData.type === 'video') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else if (trackData.type === 'audio') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else {\n                const map = {\n                    webvtt: 'wvtt',\n                };\n                return map[trackData.track.source._codec];\n            }\n        });\n        return buildIsobmffMimeType({\n            isQuickTime: this.isQuickTime,\n            hasVideo: this.trackDatas.some(x => x.type === 'video'),\n            hasAudio: this.trackDatas.some(x => x.type === 'audio'),\n            codecStrings,\n        });\n    }\n    getVideoTrackData(track, packet, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateVideoChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const decoderConfig = { ...meta.decoderConfig };\n        assert(decoderConfig.codedWidth !== undefined);\n        assert(decoderConfig.codedHeight !== undefined);\n        let requiresAnnexBTransformation = false;\n        if (track.source._codec === 'avc' && !decoderConfig.description) {\n            // ISOBMFF can only hold AVC in the AVCC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = extractAvcDecoderConfigurationRecord(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are'\n                    + ' in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or'\n                    + ' provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in AVCC format.');\n            }\n            decoderConfig.description = serializeAvcDecoderConfigurationRecord(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        else if (track.source._codec === 'hevc' && !decoderConfig.description) {\n            // ISOBMFF can only hold HEVC in the HEVC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = extractHevcDecoderConfigurationRecord(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets'\n                    + ' are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or'\n                    + ' provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in HEVC format.');\n            }\n            decoderConfig.description = serializeHevcDecoderConfigurationRecord(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        // The frame rate set by the user may not be an integer. Since timescale is an integer, we'll approximate the\n        // frame time (inverse of frame rate) with a rational number, then use that approximation's denominator\n        // as the timescale.\n        const timescale = computeRationalApproximation(1 / (track.metadata.frameRate ?? 57600), 1e6).denominator;\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'video',\n            info: {\n                width: decoderConfig.codedWidth,\n                height: decoderConfig.codedHeight,\n                decoderConfig: decoderConfig,\n                requiresAnnexBTransformation,\n            },\n            timescale,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getAudioTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'audio',\n            info: {\n                numberOfChannels: meta.decoderConfig.numberOfChannels,\n                sampleRate: meta.decoderConfig.sampleRate,\n                decoderConfig: meta.decoderConfig,\n                requiresPcmTransformation: !this.isFragmented\n                    && PCM_AUDIO_CODECS.includes(track.source._codec),\n            },\n            timescale: meta.decoderConfig.sampleRate,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getSubtitleTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateSubtitleMetadata(meta);\n        assert(meta);\n        assert(meta.config);\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'subtitle',\n            info: {\n                config: meta.config,\n            },\n            timescale: 1000, // Reasonable\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n            lastCueEndTimestamp: 0,\n            cueQueue: [],\n            nextSourceId: 0,\n            cueToSourceId: new WeakMap(),\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    async addEncodedVideoPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getVideoTrackData(track, packet, meta);\n            let packetData = packet.data;\n            if (trackData.info.requiresAnnexBTransformation) {\n                const transformedData = transformAnnexBToLengthPrefixed(packetData);\n                if (!transformedData) {\n                    throw new Error('Failed to transform packet data. Make sure all packets are provided in Annex B format, as'\n                        + ' specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.');\n                }\n                packetData = transformedData;\n            }\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packetData, timestamp, packet.duration, packet.type);\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getAudioTrackData(track, meta);\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packet.data, timestamp, packet.duration, packet.type);\n            if (trackData.info.requiresPcmTransformation) {\n                await this.maybePadWithSilence(trackData, timestamp);\n            }\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async maybePadWithSilence(trackData, untilTimestamp) {\n        // The PCM transformation assumes that all samples are contiguous. This is not something that is enforced, so\n        // we need to pad the \"holes\" in between samples (and before the first sample) with additional\n        // \"silence samples\".\n        const lastSample = last(trackData.samples);\n        const lastEndTimestamp = lastSample\n            ? lastSample.timestamp + lastSample.duration\n            : 0;\n        const delta = untilTimestamp - lastEndTimestamp;\n        const deltaInTimescale = intoTimescale(delta, trackData.timescale);\n        if (deltaInTimescale > 0) {\n            const { sampleSize, silentValue } = parsePcmCodec(trackData.info.decoderConfig.codec);\n            const samplesNeeded = deltaInTimescale * trackData.info.numberOfChannels;\n            const data = new Uint8Array(sampleSize * samplesNeeded).fill(silentValue);\n            const paddingSample = this.createSampleForTrack(trackData, new Uint8Array(data.buffer), lastEndTimestamp, delta, 'key');\n            await this.registerSample(trackData, paddingSample);\n        }\n    }\n    async addSubtitleCue(track, cue, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getSubtitleTrackData(track, meta);\n            this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);\n            if (track.source._codec === 'webvtt') {\n                trackData.cueQueue.push(cue);\n                await this.processWebVTTCues(trackData, cue.timestamp);\n            }\n            else {\n                // TODO\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    async processWebVTTCues(trackData, until) {\n        // WebVTT cues need to undergo special processing as empty sections need to be padded out with samples, and\n        // overlapping samples require special logic. The algorithm produces the format specified in ISO 14496-30.\n        while (trackData.cueQueue.length > 0) {\n            const timestamps = new Set([]);\n            for (const cue of trackData.cueQueue) {\n                assert(cue.timestamp <= until);\n                assert(trackData.lastCueEndTimestamp <= cue.timestamp + cue.duration);\n                timestamps.add(Math.max(cue.timestamp, trackData.lastCueEndTimestamp)); // Start timestamp\n                timestamps.add(cue.timestamp + cue.duration); // End timestamp\n            }\n            const sortedTimestamps = [...timestamps].sort((a, b) => a - b);\n            // These are the timestamps of the next sample we'll create:\n            const sampleStart = sortedTimestamps[0];\n            const sampleEnd = sortedTimestamps[1] ?? sampleStart;\n            if (until < sampleEnd) {\n                break;\n            }\n            // We may need to pad out empty space with an vtte box\n            if (trackData.lastCueEndTimestamp < sampleStart) {\n                this.auxWriter.seek(0);\n                const box = vtte();\n                this.auxBoxWriter.writeBox(box);\n                const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n                const sample = this.createSampleForTrack(trackData, body, trackData.lastCueEndTimestamp, sampleStart - trackData.lastCueEndTimestamp, 'key');\n                await this.registerSample(trackData, sample);\n                trackData.lastCueEndTimestamp = sampleStart;\n            }\n            this.auxWriter.seek(0);\n            for (let i = 0; i < trackData.cueQueue.length; i++) {\n                const cue = trackData.cueQueue[i];\n                if (cue.timestamp >= sampleEnd) {\n                    break;\n                }\n                inlineTimestampRegex.lastIndex = 0;\n                const containsTimestamp = inlineTimestampRegex.test(cue.text);\n                const endTimestamp = cue.timestamp + cue.duration;\n                let sourceId = trackData.cueToSourceId.get(cue);\n                if (sourceId === undefined && sampleEnd < endTimestamp) {\n                    // We know this cue will appear in more than one sample, therefore we need to mark it with a\n                    // unique ID\n                    sourceId = trackData.nextSourceId++;\n                    trackData.cueToSourceId.set(cue, sourceId);\n                }\n                if (cue.notes) {\n                    // Any notes/comments are included in a special vtta box\n                    const box = vtta(cue.notes);\n                    this.auxBoxWriter.writeBox(box);\n                }\n                const box = vttc(cue.text, containsTimestamp ? sampleStart : null, cue.identifier ?? null, cue.settings ?? null, sourceId ?? null);\n                this.auxBoxWriter.writeBox(box);\n                if (endTimestamp === sampleEnd) {\n                    // The cue won't appear in any future sample, so we're done with it\n                    trackData.cueQueue.splice(i--, 1);\n                }\n            }\n            const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n            const sample = this.createSampleForTrack(trackData, body, sampleStart, sampleEnd - sampleStart, 'key');\n            await this.registerSample(trackData, sample);\n            trackData.lastCueEndTimestamp = sampleEnd;\n        }\n    }\n    createSampleForTrack(trackData, data, timestamp, duration, type) {\n        const sample = {\n            timestamp,\n            decodeTimestamp: timestamp, // This may be refined later\n            duration,\n            data,\n            size: data.byteLength,\n            type,\n            timescaleUnitsToNextSample: intoTimescale(duration, trackData.timescale), // Will be refined\n        };\n        return sample;\n    }\n    processTimestamps(trackData, nextSample) {\n        if (trackData.timestampProcessingQueue.length === 0) {\n            return;\n        }\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            let totalDuration = 0;\n            // Compute the total duration in the track timescale (which is equal to the amount of PCM audio samples)\n            // and simply say that's how many new samples there are.\n            for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n                const sample = trackData.timestampProcessingQueue[i];\n                const duration = intoTimescale(sample.duration, trackData.timescale);\n                totalDuration += duration;\n            }\n            if (trackData.timeToSampleTable.length === 0) {\n                trackData.timeToSampleTable.push({\n                    sampleCount: totalDuration,\n                    sampleDelta: 1,\n                });\n            }\n            else {\n                const lastEntry = last(trackData.timeToSampleTable);\n                lastEntry.sampleCount += totalDuration;\n            }\n            trackData.timestampProcessingQueue.length = 0;\n            return;\n        }\n        const sortedTimestamps = trackData.timestampProcessingQueue.map(x => x.timestamp).sort((a, b) => a - b);\n        for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n            const sample = trackData.timestampProcessingQueue[i];\n            // Since the user only supplies presentation time, but these may be out of order, we reverse-engineer from\n            // that a sensible decode timestamp. The notion of a decode timestamp doesn't really make sense\n            // (presentation timestamp & decode order are all you need), but it is a concept in ISOBMFF so we need to\n            // model it.\n            sample.decodeTimestamp = sortedTimestamps[i];\n            if (!this.isFragmented && trackData.lastTimescaleUnits === null) {\n                // In non-fragmented files, the first decode timestamp is always zero. If the first presentation\n                // timestamp isn't zero, we'll simply use the composition time offset to achieve it.\n                sample.decodeTimestamp = 0;\n            }\n            const sampleCompositionTimeOffset = intoTimescale(sample.timestamp - sample.decodeTimestamp, trackData.timescale);\n            const durationInTimescale = intoTimescale(sample.duration, trackData.timescale);\n            if (trackData.lastTimescaleUnits !== null) {\n                assert(trackData.lastSample);\n                const timescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n                assert(delta >= 0);\n                trackData.lastTimescaleUnits += delta;\n                trackData.lastSample.timescaleUnitsToNextSample = delta;\n                if (!this.isFragmented) {\n                    let lastTableEntry = last(trackData.timeToSampleTable);\n                    assert(lastTableEntry);\n                    if (lastTableEntry.sampleCount === 1) {\n                        lastTableEntry.sampleDelta = delta;\n                        const entryBefore = trackData.timeToSampleTable[trackData.timeToSampleTable.length - 2];\n                        if (entryBefore && entryBefore.sampleDelta === delta) {\n                            // If the delta is the same as the previous one, merge the two entries\n                            entryBefore.sampleCount++;\n                            trackData.timeToSampleTable.pop();\n                            lastTableEntry = entryBefore;\n                        }\n                    }\n                    else if (lastTableEntry.sampleDelta !== delta) {\n                        // The delta has changed, so we need a new entry to reach the current sample\n                        lastTableEntry.sampleCount--;\n                        trackData.timeToSampleTable.push(lastTableEntry = {\n                            sampleCount: 1,\n                            sampleDelta: delta,\n                        });\n                    }\n                    if (lastTableEntry.sampleDelta === durationInTimescale) {\n                        // The sample's duration matches the delta, so we can increment the count\n                        lastTableEntry.sampleCount++;\n                    }\n                    else {\n                        // Add a new entry in order to maintain the last sample's true duration\n                        trackData.timeToSampleTable.push({\n                            sampleCount: 1,\n                            sampleDelta: durationInTimescale,\n                        });\n                    }\n                    const lastCompositionTimeOffsetTableEntry = last(trackData.compositionTimeOffsetTable);\n                    assert(lastCompositionTimeOffsetTableEntry);\n                    if (lastCompositionTimeOffsetTableEntry.sampleCompositionTimeOffset === sampleCompositionTimeOffset) {\n                        // Simply increment the count\n                        lastCompositionTimeOffsetTableEntry.sampleCount++;\n                    }\n                    else {\n                        // The composition time offset has changed, so create a new entry with the new composition time\n                        // offset\n                        trackData.compositionTimeOffsetTable.push({\n                            sampleCount: 1,\n                            sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                        });\n                    }\n                }\n            }\n            else {\n                // Decode timestamp of the first sample\n                trackData.lastTimescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                if (!this.isFragmented) {\n                    trackData.timeToSampleTable.push({\n                        sampleCount: 1,\n                        sampleDelta: durationInTimescale,\n                    });\n                    trackData.compositionTimeOffsetTable.push({\n                        sampleCount: 1,\n                        sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                    });\n                }\n            }\n            trackData.lastSample = sample;\n        }\n        trackData.timestampProcessingQueue.length = 0;\n        assert(trackData.lastSample);\n        assert(trackData.lastTimescaleUnits !== null);\n        if (nextSample !== undefined && trackData.lastSample.timescaleUnitsToNextSample === 0) {\n            assert(nextSample.type === 'key');\n            // Given the next sample, we can make a guess about the duration of the last sample. This avoids having\n            // the last sample's duration in each fragment be \"0\" for fragmented files. The guess we make here is\n            // actually correct most of the time, since typically, no delta frame with a lower timestamp follows the key\n            // frame (although it can happen).\n            const timescaleUnits = intoTimescale(nextSample.timestamp, trackData.timescale, false);\n            const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n            trackData.lastSample.timescaleUnitsToNextSample = delta;\n        }\n    }\n    async registerSample(trackData, sample) {\n        if (sample.type === 'key') {\n            this.processTimestamps(trackData, sample);\n        }\n        trackData.timestampProcessingQueue.push(sample);\n        if (this.isFragmented) {\n            trackData.sampleQueue.push(sample);\n            await this.interleaveSamples();\n        }\n        else {\n            await this.addSampleToTrack(trackData, sample);\n        }\n    }\n    async addSampleToTrack(trackData, sample) {\n        if (!this.isFragmented) {\n            trackData.samples.push(sample);\n        }\n        let beginNewChunk = false;\n        if (!trackData.currentChunk) {\n            beginNewChunk = true;\n        }\n        else {\n            // Timestamp don't need to be monotonic (think B-frames), so we may need to update the start timestamp of\n            // the chunk\n            trackData.currentChunk.startTimestamp = Math.min(trackData.currentChunk.startTimestamp, sample.timestamp);\n            const currentChunkDuration = sample.timestamp - trackData.currentChunk.startTimestamp;\n            if (this.isFragmented) {\n                // We can only finalize this fragment (and begin a new one) if we know that each track will be able to\n                // start the new one with a key frame.\n                const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData) => {\n                    if (trackData === otherTrackData) {\n                        return sample.type === 'key';\n                    }\n                    const firstQueuedSample = otherTrackData.sampleQueue[0];\n                    if (firstQueuedSample) {\n                        return firstQueuedSample.type === 'key';\n                    }\n                    return otherTrackData.track.source._closed;\n                });\n                if (currentChunkDuration >= this.minimumFragmentDuration\n                    && keyFrameQueuedEverywhere\n                    && sample.timestamp > this.maxWrittenTimestamp) {\n                    beginNewChunk = true;\n                    await this.finalizeFragment();\n                }\n            }\n            else {\n                beginNewChunk = currentChunkDuration >= 0.5; // Chunk is long enough, we need a new one\n            }\n        }\n        if (beginNewChunk) {\n            if (trackData.currentChunk) {\n                await this.finalizeCurrentChunk(trackData);\n            }\n            trackData.currentChunk = {\n                startTimestamp: sample.timestamp,\n                samples: [],\n                offset: null,\n                moofOffset: null,\n            };\n        }\n        assert(trackData.currentChunk);\n        trackData.currentChunk.samples.push(sample);\n        if (this.isFragmented) {\n            this.maxWrittenTimestamp = Math.max(this.maxWrittenTimestamp, sample.timestamp);\n        }\n    }\n    async finalizeCurrentChunk(trackData) {\n        assert(!this.isFragmented);\n        if (!trackData.currentChunk)\n            return;\n        trackData.finalizedChunks.push(trackData.currentChunk);\n        this.finalizedChunks.push(trackData.currentChunk);\n        let sampleCount = trackData.currentChunk.samples.length;\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            sampleCount = trackData.currentChunk.samples\n                .reduce((acc, sample) => acc + intoTimescale(sample.duration, trackData.timescale), 0);\n        }\n        if (trackData.compactlyCodedChunkTable.length === 0\n            || last(trackData.compactlyCodedChunkTable).samplesPerChunk !== sampleCount) {\n            trackData.compactlyCodedChunkTable.push({\n                firstChunk: trackData.finalizedChunks.length, // 1-indexed\n                samplesPerChunk: sampleCount,\n            });\n        }\n        if (this.fastStart === 'in-memory') {\n            trackData.currentChunk.offset = 0; // We'll compute the proper offset when finalizing\n            return;\n        }\n        // Write out the data\n        trackData.currentChunk.offset = this.writer.getPos();\n        for (const sample of trackData.currentChunk.samples) {\n            assert(sample.data);\n            this.writer.write(sample.data);\n            sample.data = null; // Can be GC'd\n        }\n        await this.writer.flush();\n    }\n    async interleaveSamples(isFinalCall = false) {\n        assert(this.isFragmented);\n        if (!isFinalCall) {\n            if (!this.allTracksAreKnown()) {\n                return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n            }\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall && trackData.sampleQueue.length === 0 && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.sampleQueue.length > 0 && trackData.sampleQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.sampleQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const sample = trackWithMinTimestamp.sampleQueue.shift();\n            await this.addSampleToTrack(trackWithMinTimestamp, sample);\n        }\n    }\n    async finalizeFragment(flushWriter = true) {\n        assert(this.isFragmented);\n        const fragmentNumber = this.nextFragmentNumber++;\n        if (fragmentNumber === 1) {\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            // Write the moov box now that we have all decoder configs\n            const movieBox = moov(this.trackDatas, this.creationTime, true);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        // Not all tracks need to be present in every fragment\n        const tracksInFragment = this.trackDatas.filter(x => x.currentChunk);\n        // Create an initial moof box and measure it; we need this to know where the following mdat box will begin\n        const moofBox = moof(fragmentNumber, tracksInFragment);\n        const moofOffset = this.writer.getPos();\n        const mdatStartPos = moofOffset + this.boxWriter.measureBox(moofBox);\n        let currentPos = mdatStartPos + MIN_BOX_HEADER_SIZE;\n        let fragmentStartTimestamp = Infinity;\n        for (const trackData of tracksInFragment) {\n            trackData.currentChunk.offset = currentPos;\n            trackData.currentChunk.moofOffset = moofOffset;\n            for (const sample of trackData.currentChunk.samples) {\n                currentPos += sample.size;\n            }\n            fragmentStartTimestamp = Math.min(fragmentStartTimestamp, trackData.currentChunk.startTimestamp);\n        }\n        const mdatSize = currentPos - mdatStartPos;\n        const needsLargeMdatSize = mdatSize >= 2 ** 32;\n        if (needsLargeMdatSize) {\n            // Shift all offsets by 8. Previously, all chunks were shifted assuming the large box size, but due to what\n            // I suspect is a bug in WebKit, it failed in Safari (when livestreaming with MSE, not for static playback).\n            for (const trackData of tracksInFragment) {\n                trackData.currentChunk.offset += MAX_BOX_HEADER_SIZE - MIN_BOX_HEADER_SIZE;\n            }\n        }\n        if (this.format._options.onMoof) {\n            this.writer.startTrackingWrites();\n        }\n        const newMoofBox = moof(fragmentNumber, tracksInFragment);\n        this.boxWriter.writeBox(newMoofBox);\n        if (this.format._options.onMoof) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMoof(data, start, fragmentStartTimestamp);\n        }\n        assert(this.writer.getPos() === mdatStartPos);\n        if (this.format._options.onMdat) {\n            this.writer.startTrackingWrites();\n        }\n        const mdatBox = mdat(needsLargeMdatSize);\n        mdatBox.size = mdatSize;\n        this.boxWriter.writeBox(mdatBox);\n        this.writer.seek(mdatStartPos + (needsLargeMdatSize ? MAX_BOX_HEADER_SIZE : MIN_BOX_HEADER_SIZE));\n        // Write sample data\n        for (const trackData of tracksInFragment) {\n            for (const sample of trackData.currentChunk.samples) {\n                this.writer.write(sample.data);\n                sample.data = null; // Can be GC'd\n            }\n        }\n        if (this.format._options.onMdat) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMdat(data, start);\n        }\n        for (const trackData of tracksInFragment) {\n            trackData.finalizedChunks.push(trackData.currentChunk);\n            this.finalizedChunks.push(trackData.currentChunk);\n            trackData.currentChunk = null;\n        }\n        if (flushWriter) {\n            await this.writer.flush();\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose(track) {\n        const release = await this.mutex.acquire();\n        if (track.type === 'subtitle' && track.source._codec === 'webvtt') {\n            const trackData = this.trackDatas.find(x => x.track === track);\n            if (trackData) {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        if (this.isFragmented) {\n            // Since a track is now closed, we may be able to write out chunks that were previously waiting\n            await this.interleaveSamples();\n        }\n        release();\n    }\n    /** Finalizes the file, making it ready for use. Must be called after all video and audio chunks have been added. */\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        for (const trackData of this.trackDatas) {\n            if (trackData.type === 'subtitle' && trackData.track.source._codec === 'webvtt') {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.isFragmented) {\n            await this.interleaveSamples(true);\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n            }\n            await this.finalizeFragment(false); // Don't flush the last fragment as we will flush it with the mfra box\n        }\n        else {\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n                await this.finalizeCurrentChunk(trackData);\n            }\n        }\n        if (this.fastStart === 'in-memory') {\n            assert(this.mdat);\n            let mdatSize;\n            // We know how many chunks there are, but computing the chunk positions requires an iterative approach:\n            // In order to know where the first chunk should go, we first need to know the size of the moov box. But we\n            // cannot write a proper moov box without first knowing all chunk positions. So, we generate a tentative\n            // moov box with placeholder values (0) for the chunk offsets to be able to compute its size. If it then\n            // turns out that appending all chunks exceeds 4 GiB, we need to repeat this process, now with the co64 box\n            // being used in the moov box instead, which will make it larger. After that, we definitely know the final\n            // size of the moov box and can compute the proper chunk positions.\n            for (let i = 0; i < 2; i++) {\n                const movieBox = moov(this.trackDatas, this.creationTime);\n                const movieBoxSize = this.boxWriter.measureBox(movieBox);\n                mdatSize = this.boxWriter.measureBox(this.mdat);\n                let currentChunkPos = this.writer.getPos() + movieBoxSize + mdatSize;\n                for (const chunk of this.finalizedChunks) {\n                    chunk.offset = currentChunkPos;\n                    for (const { data } of chunk.samples) {\n                        assert(data);\n                        currentChunkPos += data.byteLength;\n                        mdatSize += data.byteLength;\n                    }\n                }\n                if (currentChunkPos < 2 ** 32)\n                    break;\n                if (mdatSize >= 2 ** 32)\n                    this.mdat.largeSize = true;\n            }\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            const movieBox = moov(this.trackDatas, this.creationTime);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat.size = mdatSize;\n            this.boxWriter.writeBox(this.mdat);\n            for (const chunk of this.finalizedChunks) {\n                for (const sample of chunk.samples) {\n                    assert(sample.data);\n                    this.writer.write(sample.data);\n                    sample.data = null;\n                }\n            }\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n        }\n        else if (this.isFragmented) {\n            // Append the mfra box to the end of the file for better random access\n            const startPos = this.writer.getPos();\n            const mfraBox = mfra(this.trackDatas);\n            this.boxWriter.writeBox(mfraBox);\n            // Patch the 'size' field of the mfro box at the end of the mfra box now that we know its actual size\n            const mfraBoxSize = this.writer.getPos() - startPos;\n            this.writer.seek(this.writer.getPos() - 4);\n            this.boxWriter.writeU32(mfraBoxSize);\n        }\n        else {\n            assert(this.mdat);\n            const mdatPos = this.boxWriter.offsets.get(this.mdat);\n            assert(mdatPos !== undefined);\n            const mdatSize = this.writer.getPos() - mdatPos;\n            this.mdat.size = mdatSize;\n            this.mdat.largeSize = mdatSize >= 2 ** 32; // Only use the large size if we need it\n            this.boxWriter.patchBox(this.mdat);\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            const movieBox = moov(this.trackDatas, this.creationTime);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        release();\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2687, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/matroska/matroska-muxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream, COLOR_PRIMARIES_MAP, MATRIX_COEFFICIENTS_MAP, TRANSFER_CHARACTERISTICS_MAP, UNDETERMINED_LANGUAGE, assert, colorSpaceIsComplete, normalizeRotation, promiseWithResolvers, roundToMultiple, textEncoder, toUint8Array, writeBits, } from '../misc.js';\nimport { CODEC_STRING_MAP, EBMLFloat32, EBMLFloat64, EBMLId, EBMLSignedInt, EBMLWriter, } from './ebml.js';\nimport { buildMatroskaMimeType } from './matroska-misc.js';\nimport { WebMOutputFormat } from '../output-format.js';\nimport { formatSubtitleTimestamp, inlineTimestampRegex, parseSubtitleTimestamp, } from '../subtitles.js';\nimport { OPUS_INTERNAL_SAMPLE_RATE, PCM_AUDIO_CODECS, generateAv1CodecConfigurationFromCodecString, generateVp9CodecConfigurationFromCodecString, parsePcmCodec, validateAudioChunkMetadata, validateSubtitleMetadata, validateVideoChunkMetadata, } from '../codec.js';\nimport { Muxer } from '../muxer.js';\nimport { parseOpusIdentificationHeader } from '../codec-data.js';\nconst MIN_CLUSTER_TIMESTAMP_MS = -(2 ** 15);\nconst MAX_CLUSTER_TIMESTAMP_MS = 2 ** 15 - 1;\nconst APP_NAME = 'https://github.com/Vanilagy/mediabunny';\nconst SEGMENT_SIZE_BYTES = 6;\nconst CLUSTER_SIZE_BYTES = 5;\nconst TRACK_TYPE_MAP = {\n    video: 1,\n    audio: 2,\n    subtitle: 17,\n};\nexport class MatroskaMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.trackDatas = [];\n        this.allTracksKnown = promiseWithResolvers();\n        this.segment = null;\n        this.segmentInfo = null;\n        this.seekHead = null;\n        this.tracksElement = null;\n        this.segmentDuration = null;\n        this.cues = null;\n        this.currentCluster = null;\n        this.currentClusterStartMsTimestamp = null;\n        this.currentClusterMaxMsTimestamp = null;\n        this.trackDatasInCurrentCluster = new Map();\n        this.duration = 0;\n        this.writer = output._writer;\n        this.format = format;\n        this.ebmlWriter = new EBMLWriter(this.writer);\n        if (this.format._options.appendOnly) {\n            this.writer.ensureMonotonicity = true;\n        }\n    }\n    async start() {\n        const release = await this.mutex.acquire();\n        this.writeEBMLHeader();\n        if (!this.format._options.appendOnly) {\n            this.createSeekHead();\n        }\n        this.createSegmentInfo();\n        this.createCues();\n        await this.writer.flush();\n        release();\n    }\n    writeEBMLHeader() {\n        if (this.format._options.onEbmlHeader) {\n            this.writer.startTrackingWrites();\n        }\n        const ebmlHeader = { id: EBMLId.EBML, data: [\n                { id: EBMLId.EBMLVersion, data: 1 },\n                { id: EBMLId.EBMLReadVersion, data: 1 },\n                { id: EBMLId.EBMLMaxIDLength, data: 4 },\n                { id: EBMLId.EBMLMaxSizeLength, data: 8 },\n                { id: EBMLId.DocType, data: this.format instanceof WebMOutputFormat ? 'webm' : 'matroska' },\n                { id: EBMLId.DocTypeVersion, data: 2 },\n                { id: EBMLId.DocTypeReadVersion, data: 2 },\n            ] };\n        this.ebmlWriter.writeEBML(ebmlHeader);\n        if (this.format._options.onEbmlHeader) {\n            const { data, start } = this.writer.stopTrackingWrites(); // start should be 0\n            this.format._options.onEbmlHeader(data, start);\n        }\n    }\n    /**\n     * Creates a SeekHead element which is positioned near the start of the file and allows the media player to seek to\n     * relevant sections more easily. Since we don't know the positions of those sections yet, we'll set them later.\n     */\n    createSeekHead() {\n        const kaxCues = new Uint8Array([0x1c, 0x53, 0xbb, 0x6b]);\n        const kaxInfo = new Uint8Array([0x15, 0x49, 0xa9, 0x66]);\n        const kaxTracks = new Uint8Array([0x16, 0x54, 0xae, 0x6b]);\n        const seekHead = { id: EBMLId.SeekHead, data: [\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxCues },\n                        { id: EBMLId.SeekPosition, size: 5, data: 0 },\n                    ] },\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxInfo },\n                        { id: EBMLId.SeekPosition, size: 5, data: 0 },\n                    ] },\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxTracks },\n                        { id: EBMLId.SeekPosition, size: 5, data: 0 },\n                    ] },\n            ] };\n        this.seekHead = seekHead;\n    }\n    createSegmentInfo() {\n        const segmentDuration = { id: EBMLId.Duration, data: new EBMLFloat64(0) };\n        this.segmentDuration = segmentDuration;\n        const segmentInfo = { id: EBMLId.Info, data: [\n                { id: EBMLId.TimestampScale, data: 1e6 },\n                { id: EBMLId.MuxingApp, data: APP_NAME },\n                { id: EBMLId.WritingApp, data: APP_NAME },\n                !this.format._options.appendOnly ? segmentDuration : null,\n            ] };\n        this.segmentInfo = segmentInfo;\n    }\n    createTracks() {\n        const tracksElement = { id: EBMLId.Tracks, data: [] };\n        this.tracksElement = tracksElement;\n        for (const trackData of this.trackDatas) {\n            const codecId = CODEC_STRING_MAP[trackData.track.source._codec];\n            assert(codecId);\n            let seekPreRollNs = 0;\n            if (trackData.type === 'audio' && trackData.track.source._codec === 'opus') {\n                seekPreRollNs = 1e6 * 80; // In \"Matroska ticks\" (nanoseconds)\n                const description = trackData.info.decoderConfig.description;\n                if (description) {\n                    const bytes = toUint8Array(description);\n                    const header = parseOpusIdentificationHeader(bytes);\n                    // Use the preSkip value from the header\n                    seekPreRollNs = Math.round(1e9 * (header.preSkip / OPUS_INTERNAL_SAMPLE_RATE));\n                }\n            }\n            tracksElement.data.push({ id: EBMLId.TrackEntry, data: [\n                    { id: EBMLId.TrackNumber, data: trackData.track.id },\n                    { id: EBMLId.TrackUID, data: trackData.track.id },\n                    { id: EBMLId.TrackType, data: TRACK_TYPE_MAP[trackData.type] },\n                    { id: EBMLId.FlagLacing, data: 0 },\n                    { id: EBMLId.Language, data: trackData.track.metadata.languageCode ?? UNDETERMINED_LANGUAGE },\n                    { id: EBMLId.CodecID, data: codecId },\n                    { id: EBMLId.CodecDelay, data: 0 },\n                    { id: EBMLId.SeekPreRoll, data: seekPreRollNs },\n                    (trackData.type === 'video' ? this.videoSpecificTrackInfo(trackData) : null),\n                    (trackData.type === 'audio' ? this.audioSpecificTrackInfo(trackData) : null),\n                    (trackData.type === 'subtitle' ? this.subtitleSpecificTrackInfo(trackData) : null),\n                ] });\n        }\n    }\n    videoSpecificTrackInfo(trackData) {\n        const { frameRate, rotation } = trackData.track.metadata;\n        const elements = [\n            (trackData.info.decoderConfig.description\n                ? {\n                    id: EBMLId.CodecPrivate,\n                    data: toUint8Array(trackData.info.decoderConfig.description),\n                }\n                : null),\n            (frameRate\n                ? {\n                    id: EBMLId.DefaultDuration,\n                    data: 1e9 / frameRate,\n                }\n                : null),\n        ];\n        // Convert from clockwise to counter-clockwise\n        const flippedRotation = rotation ? normalizeRotation(-rotation) : 0;\n        const colorSpace = trackData.info.decoderConfig.colorSpace;\n        const videoElement = { id: EBMLId.Video, data: [\n                { id: EBMLId.PixelWidth, data: trackData.info.width },\n                { id: EBMLId.PixelHeight, data: trackData.info.height },\n                (colorSpaceIsComplete(colorSpace)\n                    ? {\n                        id: EBMLId.Colour,\n                        data: [\n                            {\n                                id: EBMLId.MatrixCoefficients,\n                                data: MATRIX_COEFFICIENTS_MAP[colorSpace.matrix],\n                            },\n                            {\n                                id: EBMLId.TransferCharacteristics,\n                                data: TRANSFER_CHARACTERISTICS_MAP[colorSpace.transfer],\n                            },\n                            {\n                                id: EBMLId.Primaries,\n                                data: COLOR_PRIMARIES_MAP[colorSpace.primaries],\n                            },\n                            {\n                                id: EBMLId.Range,\n                                data: colorSpace.fullRange ? 2 : 1,\n                            },\n                        ],\n                    }\n                    : null),\n                (flippedRotation\n                    ? {\n                        id: EBMLId.Projection,\n                        data: [\n                            {\n                                id: EBMLId.ProjectionType,\n                                data: 0, // rectangular\n                            },\n                            {\n                                id: EBMLId.ProjectionPoseRoll,\n                                data: new EBMLFloat32((flippedRotation + 180) % 360 - 180), // [0, 270] -> [-180, 90]\n                            },\n                        ],\n                    }\n                    : null),\n            ] };\n        elements.push(videoElement);\n        return elements;\n    }\n    audioSpecificTrackInfo(trackData) {\n        const pcmInfo = PCM_AUDIO_CODECS.includes(trackData.track.source._codec)\n            ? parsePcmCodec(trackData.track.source._codec)\n            : null;\n        return [\n            (trackData.info.decoderConfig.description\n                ? {\n                    id: EBMLId.CodecPrivate,\n                    data: toUint8Array(trackData.info.decoderConfig.description),\n                }\n                : null),\n            { id: EBMLId.Audio, data: [\n                    { id: EBMLId.SamplingFrequency, data: new EBMLFloat32(trackData.info.sampleRate) },\n                    { id: EBMLId.Channels, data: trackData.info.numberOfChannels },\n                    pcmInfo ? { id: EBMLId.BitDepth, data: 8 * pcmInfo.sampleSize } : null,\n                ] },\n        ];\n    }\n    subtitleSpecificTrackInfo(trackData) {\n        return [\n            { id: EBMLId.CodecPrivate, data: textEncoder.encode(trackData.info.config.description) },\n        ];\n    }\n    createSegment() {\n        const segment = {\n            id: EBMLId.Segment,\n            size: this.format._options.appendOnly ? -1 : SEGMENT_SIZE_BYTES,\n            data: [\n                !this.format._options.appendOnly ? this.seekHead : null,\n                this.segmentInfo,\n                this.tracksElement,\n            ],\n        };\n        this.segment = segment;\n        if (this.format._options.onSegmentHeader) {\n            this.writer.startTrackingWrites();\n        }\n        this.ebmlWriter.writeEBML(segment);\n        if (this.format._options.onSegmentHeader) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onSegmentHeader(data, start);\n        }\n    }\n    createCues() {\n        this.cues = { id: EBMLId.Cues, data: [] };\n    }\n    get segmentDataOffset() {\n        assert(this.segment);\n        return this.ebmlWriter.dataOffsets.get(this.segment);\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        const codecStrings = this.trackDatas.map((trackData) => {\n            if (trackData.type === 'video') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else if (trackData.type === 'audio') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else {\n                const map = {\n                    webvtt: 'wvtt',\n                };\n                return map[trackData.track.source._codec];\n            }\n        });\n        return buildMatroskaMimeType({\n            isWebM: this.format instanceof WebMOutputFormat,\n            hasVideo: this.trackDatas.some(x => x.type === 'video'),\n            hasAudio: this.trackDatas.some(x => x.type === 'audio'),\n            codecStrings,\n        });\n    }\n    getVideoTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateVideoChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        assert(meta.decoderConfig.codedWidth !== undefined);\n        assert(meta.decoderConfig.codedHeight !== undefined);\n        const newTrackData = {\n            track,\n            type: 'video',\n            info: {\n                width: meta.decoderConfig.codedWidth,\n                height: meta.decoderConfig.codedHeight,\n                decoderConfig: meta.decoderConfig,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        if (track.source._codec === 'vp9') {\n            // https://www.webmproject.org/docs/container specifies that VP9 \"SHOULD\" make use of the CodecPrivate\n            // field. Since WebCodecs makes no use of the description field for VP9, we need to derive it ourselves:\n            newTrackData.info.decoderConfig = {\n                ...newTrackData.info.decoderConfig,\n                description: new Uint8Array(generateVp9CodecConfigurationFromCodecString(newTrackData.info.decoderConfig.codec)),\n            };\n        }\n        else if (track.source._codec === 'av1') {\n            // Per https://github.com/ietf-wg-cellar/matroska-specification/blob/master/codec/av1.md, AV1 requires\n            // CodecPrivate to be set, but WebCodecs makes no use of the description field for AV1. Thus, let's derive\n            // it ourselves:\n            newTrackData.info.decoderConfig = {\n                ...newTrackData.info.decoderConfig,\n                description: new Uint8Array(generateAv1CodecConfigurationFromCodecString(newTrackData.info.decoderConfig.codec)),\n            };\n        }\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getAudioTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const newTrackData = {\n            track,\n            type: 'audio',\n            info: {\n                numberOfChannels: meta.decoderConfig.numberOfChannels,\n                sampleRate: meta.decoderConfig.sampleRate,\n                decoderConfig: meta.decoderConfig,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getSubtitleTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateSubtitleMetadata(meta);\n        assert(meta);\n        assert(meta.config);\n        const newTrackData = {\n            track,\n            type: 'subtitle',\n            info: {\n                config: meta.config,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    async addEncodedVideoPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getVideoTrackData(track, meta);\n            const isKeyFrame = packet.type === 'key';\n            let timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);\n            let duration = packet.duration;\n            if (track.metadata.frameRate !== undefined) {\n                // Constrain the time values to the frame rate\n                timestamp = roundToMultiple(timestamp, 1 / track.metadata.frameRate);\n                duration = roundToMultiple(duration, 1 / track.metadata.frameRate);\n            }\n            const videoChunk = this.createInternalChunk(packet.data, timestamp, duration, packet.type);\n            if (track.source._codec === 'vp9')\n                this.fixVP9ColorSpace(trackData, videoChunk);\n            trackData.chunkQueue.push(videoChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getAudioTrackData(track, meta);\n            const isKeyFrame = packet.type === 'key';\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);\n            const audioChunk = this.createInternalChunk(packet.data, timestamp, packet.duration, packet.type);\n            trackData.chunkQueue.push(audioChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue(track, cue, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getSubtitleTrackData(track, meta);\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);\n            let bodyText = cue.text;\n            const timestampMs = Math.round(timestamp * 1000);\n            // Replace in-body timestamps so that they're relative to the cue start time\n            inlineTimestampRegex.lastIndex = 0;\n            bodyText = bodyText.replace(inlineTimestampRegex, (match) => {\n                const time = parseSubtitleTimestamp(match.slice(1, -1));\n                const offsetTime = time - timestampMs;\n                return `<${formatSubtitleTimestamp(offsetTime)}>`;\n            });\n            const body = textEncoder.encode(bodyText);\n            const additions = `${cue.settings ?? ''}\\n${cue.identifier ?? ''}\\n${cue.notes ?? ''}`;\n            const subtitleChunk = this.createInternalChunk(body, timestamp, cue.duration, 'key', additions.trim() ? textEncoder.encode(additions) : null);\n            trackData.chunkQueue.push(subtitleChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async interleaveChunks(isFinalCall = false) {\n        if (!isFinalCall) {\n            if (!this.allTracksAreKnown()) {\n                return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n            }\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall && trackData.chunkQueue.length === 0 && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.chunkQueue.length > 0 && trackData.chunkQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.chunkQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const chunk = trackWithMinTimestamp.chunkQueue.shift();\n            this.writeBlock(trackWithMinTimestamp, chunk);\n        }\n        if (!isFinalCall) {\n            await this.writer.flush();\n        }\n    }\n    /**\n     * Due to [a bug in Chromium](https://bugs.chromium.org/p/chromium/issues/detail?id=1377842), VP9 streams often\n     * lack color space information. This method patches in that information.\n     */\n    fixVP9ColorSpace(trackData, chunk) {\n        // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf\n        if (chunk.type !== 'key')\n            return;\n        if (!trackData.info.decoderConfig.colorSpace || !trackData.info.decoderConfig.colorSpace.matrix)\n            return;\n        const bitstream = new Bitstream(chunk.data);\n        bitstream.skipBits(2);\n        const profileLowBit = bitstream.readBits(1);\n        const profileHighBit = bitstream.readBits(1);\n        const profile = (profileHighBit << 1) + profileLowBit;\n        if (profile === 3)\n            bitstream.skipBits(1);\n        const showExistingFrame = bitstream.readBits(1);\n        if (showExistingFrame)\n            return;\n        const frameType = bitstream.readBits(1);\n        if (frameType !== 0)\n            return; // Just to be sure\n        bitstream.skipBits(2);\n        const syncCode = bitstream.readBits(24);\n        if (syncCode !== 0x498342)\n            return;\n        if (profile >= 2)\n            bitstream.skipBits(1);\n        const colorSpaceID = {\n            rgb: 7,\n            bt709: 2,\n            bt470bg: 1,\n            smpte170m: 3,\n        }[trackData.info.decoderConfig.colorSpace.matrix];\n        // The bitstream position is now at the start of the color space bits.\n        // We can use the global writeBits function here as requested.\n        writeBits(chunk.data, bitstream.pos, bitstream.pos + 3, colorSpaceID);\n    }\n    /** Converts a read-only external chunk into an internal one for easier use. */\n    createInternalChunk(data, timestamp, duration, type, additions = null) {\n        const internalChunk = {\n            data,\n            type,\n            timestamp,\n            duration,\n            additions,\n        };\n        return internalChunk;\n    }\n    /** Writes a block containing media data to the file. */\n    writeBlock(trackData, chunk) {\n        // Due to the interlacing algorithm, this code will be run once we've seen one chunk from every media track.\n        if (!this.segment) {\n            this.createTracks();\n            this.createSegment();\n        }\n        const msTimestamp = Math.round(1000 * chunk.timestamp);\n        // We wanna only finalize this cluster (and begin a new one) if we know that each track will be able to\n        // start the new one with a key frame.\n        const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData) => {\n            if (trackData === otherTrackData) {\n                return chunk.type === 'key';\n            }\n            const firstQueuedSample = otherTrackData.chunkQueue[0];\n            if (firstQueuedSample) {\n                return firstQueuedSample.type === 'key';\n            }\n            return otherTrackData.track.source._closed;\n        });\n        let shouldCreateNewCluster = false;\n        if (!this.currentCluster) {\n            shouldCreateNewCluster = true;\n        }\n        else {\n            assert(this.currentClusterStartMsTimestamp !== null);\n            assert(this.currentClusterMaxMsTimestamp !== null);\n            const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;\n            shouldCreateNewCluster = (keyFrameQueuedEverywhere\n                // This check is required because that means there is already a block with this timestamp in the\n                // CURRENT chunk, meaning that starting the next cluster at the same timestamp is forbidden (since\n                // the already-written block would belong into it instead).\n                && msTimestamp > this.currentClusterMaxMsTimestamp\n                && relativeTimestamp >= 1000 * (this.format._options.minimumClusterDuration ?? 1))\n                // The cluster would exceed its maximum allowed length. This puts us in an unfortunate position and forces\n                // us to begin the next cluster with a delta frame. Although this is undesirable, it is not forbidden by the\n                // spec and is supported by players.\n                || relativeTimestamp > MAX_CLUSTER_TIMESTAMP_MS;\n        }\n        if (shouldCreateNewCluster) {\n            this.createNewCluster(msTimestamp);\n        }\n        const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;\n        if (relativeTimestamp < MIN_CLUSTER_TIMESTAMP_MS) {\n            // The block lies too far in the past, it's not representable within this cluster\n            return;\n        }\n        const prelude = new Uint8Array(4);\n        const view = new DataView(prelude.buffer);\n        // 0x80 to indicate it's the last byte of a multi-byte number\n        view.setUint8(0, 0x80 | trackData.track.id);\n        view.setInt16(1, relativeTimestamp, false);\n        const msDuration = Math.round(1000 * chunk.duration);\n        if (msDuration === 0 && !chunk.additions) {\n            // No duration or additions, we can write out a SimpleBlock\n            view.setUint8(3, Number(chunk.type === 'key') << 7); // Flags (keyframe flag only present for SimpleBlock)\n            const simpleBlock = { id: EBMLId.SimpleBlock, data: [\n                    prelude,\n                    chunk.data,\n                ] };\n            this.ebmlWriter.writeEBML(simpleBlock);\n        }\n        else {\n            const blockGroup = { id: EBMLId.BlockGroup, data: [\n                    { id: EBMLId.Block, data: [\n                            prelude,\n                            chunk.data,\n                        ] },\n                    chunk.type === 'delta'\n                        ? {\n                            id: EBMLId.ReferenceBlock,\n                            data: new EBMLSignedInt(trackData.lastWrittenMsTimestamp - msTimestamp),\n                        }\n                        : null,\n                    chunk.additions\n                        ? { id: EBMLId.BlockAdditions, data: [\n                                { id: EBMLId.BlockMore, data: [\n                                        { id: EBMLId.BlockAdditional, data: chunk.additions },\n                                        { id: EBMLId.BlockAddID, data: 1 },\n                                    ] },\n                            ] }\n                        : null,\n                    msDuration > 0 ? { id: EBMLId.BlockDuration, data: msDuration } : null,\n                ] };\n            this.ebmlWriter.writeEBML(blockGroup);\n        }\n        this.duration = Math.max(this.duration, msTimestamp + msDuration);\n        trackData.lastWrittenMsTimestamp = msTimestamp;\n        if (!this.trackDatasInCurrentCluster.has(trackData)) {\n            this.trackDatasInCurrentCluster.set(trackData, {\n                firstMsTimestamp: msTimestamp,\n            });\n        }\n        this.currentClusterMaxMsTimestamp = Math.max(this.currentClusterMaxMsTimestamp, msTimestamp);\n    }\n    /** Creates a new Cluster element to contain media chunks. */\n    createNewCluster(msTimestamp) {\n        if (this.currentCluster) {\n            this.finalizeCurrentCluster();\n        }\n        if (this.format._options.onCluster) {\n            this.writer.startTrackingWrites();\n        }\n        this.currentCluster = {\n            id: EBMLId.Cluster,\n            size: this.format._options.appendOnly ? -1 : CLUSTER_SIZE_BYTES,\n            data: [\n                { id: EBMLId.Timestamp, data: msTimestamp },\n            ],\n        };\n        this.ebmlWriter.writeEBML(this.currentCluster);\n        this.currentClusterStartMsTimestamp = msTimestamp;\n        this.currentClusterMaxMsTimestamp = msTimestamp;\n        this.trackDatasInCurrentCluster.clear();\n    }\n    finalizeCurrentCluster() {\n        assert(this.currentCluster);\n        if (!this.format._options.appendOnly) {\n            const clusterSize = this.writer.getPos() - this.ebmlWriter.dataOffsets.get(this.currentCluster);\n            const endPos = this.writer.getPos();\n            // Write the size now that we know it\n            this.writer.seek(this.ebmlWriter.offsets.get(this.currentCluster) + 4);\n            this.ebmlWriter.writeVarInt(clusterSize, CLUSTER_SIZE_BYTES);\n            this.writer.seek(endPos);\n        }\n        if (this.format._options.onCluster) {\n            assert(this.currentClusterStartMsTimestamp !== null);\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onCluster(data, start, this.currentClusterStartMsTimestamp / 1000);\n        }\n        const clusterOffsetFromSegment = this.ebmlWriter.offsets.get(this.currentCluster) - this.segmentDataOffset;\n        // Group tracks by their first timestamp and create a CuePoint for each unique timestamp\n        const groupedByTimestamp = new Map();\n        for (const [trackData, { firstMsTimestamp }] of this.trackDatasInCurrentCluster) {\n            if (!groupedByTimestamp.has(firstMsTimestamp)) {\n                groupedByTimestamp.set(firstMsTimestamp, []);\n            }\n            groupedByTimestamp.get(firstMsTimestamp).push(trackData);\n        }\n        const groupedAndSortedByTimestamp = [...groupedByTimestamp.entries()].sort((a, b) => a[0] - b[0]);\n        // Add CuePoints to the Cues element for better seeking\n        for (const [msTimestamp, trackDatas] of groupedAndSortedByTimestamp) {\n            assert(this.cues);\n            this.cues.data.push({ id: EBMLId.CuePoint, data: [\n                    { id: EBMLId.CueTime, data: msTimestamp },\n                    // Create CueTrackPositions for each track that starts at this timestamp\n                    ...trackDatas.map((trackData) => {\n                        return { id: EBMLId.CueTrackPositions, data: [\n                                { id: EBMLId.CueTrack, data: trackData.track.id },\n                                { id: EBMLId.CueClusterPosition, data: clusterOffsetFromSegment },\n                            ] };\n                    }),\n                ] });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose() {\n        const release = await this.mutex.acquire();\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        // Since a track is now closed, we may be able to write out chunks that were previously waiting\n        await this.interleaveChunks();\n        release();\n    }\n    /** Finalizes the file, making it ready for use. Must be called after all media chunks have been added. */\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        if (!this.segment) {\n            this.createTracks();\n            this.createSegment();\n        }\n        // Flush any remaining queued chunks to the file\n        await this.interleaveChunks(true);\n        if (this.currentCluster) {\n            this.finalizeCurrentCluster();\n        }\n        assert(this.cues);\n        this.ebmlWriter.writeEBML(this.cues);\n        if (!this.format._options.appendOnly) {\n            const endPos = this.writer.getPos();\n            // Write the Segment size\n            const segmentSize = this.writer.getPos() - this.segmentDataOffset;\n            this.writer.seek(this.ebmlWriter.offsets.get(this.segment) + 4);\n            this.ebmlWriter.writeVarInt(segmentSize, SEGMENT_SIZE_BYTES);\n            // Write the duration of the media to the Segment\n            this.segmentDuration.data = new EBMLFloat64(this.duration);\n            this.writer.seek(this.ebmlWriter.offsets.get(this.segmentDuration));\n            this.ebmlWriter.writeEBML(this.segmentDuration);\n            // Fill in SeekHead position data and write it again\n            this.seekHead.data[0].data[1].data\n                = this.ebmlWriter.offsets.get(this.cues) - this.segmentDataOffset;\n            this.seekHead.data[1].data[1].data\n                = this.ebmlWriter.offsets.get(this.segmentInfo) - this.segmentDataOffset;\n            this.seekHead.data[2].data[1].data\n                = this.ebmlWriter.offsets.get(this.tracksElement) - this.segmentDataOffset;\n            this.writer.seek(this.ebmlWriter.offsets.get(this.seekHead));\n            this.ebmlWriter.writeEBML(this.seekHead);\n            this.writer.seek(endPos);\n        }\n        release();\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3571, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/mp3/mp3-writer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { computeMp3FrameSize, getXingOffset, MPEG_V1_BITRATES, MPEG_V2_BITRATES, SAMPLING_RATES, XING, } from '../../shared/mp3-misc.js';\nexport class Mp3Writer {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeXingFrame(data) {\n        const startPos = this.writer.getPos();\n        const firstByte = 0xff;\n        const secondByte = 0xe0 | (data.mpegVersionId << 3) | (data.layer << 1);\n        const bitrateGroup = data.mpegVersionId === 3 ? MPEG_V1_BITRATES : MPEG_V2_BITRATES;\n        const bitrates = bitrateGroup?.[data.layer];\n        if (!bitrates) {\n            throw new Error('Invalid MPEG version and layer combination.');\n        }\n        const sampleRate = SAMPLING_RATES[data.mpegVersionId]?.[data.frequencyIndex];\n        if (!sampleRate || sampleRate === -1) {\n            throw new Error('Invalid MPEG version and frequency index combination.');\n        }\n        const padding = 0;\n        const neededBytes = 155;\n        // Let's find the lowest bitrate for which the frame size is sufficiently large to fit all the data\n        const bitrateIndex = bitrates.findIndex((kbr) => {\n            return computeMp3FrameSize(data.layer, 1000 * kbr, sampleRate, padding) >= neededBytes;\n        });\n        if (bitrateIndex === -1) {\n            throw new Error('No suitable bitrate found.');\n        }\n        const thirdByte = (bitrateIndex << 4) | (data.frequencyIndex << 2) | padding << 1;\n        const fourthByte = (data.channel << 6)\n            | (data.modeExtension << 4)\n            | (data.copyright << 3)\n            | (data.original << 2)\n            | data.emphasis;\n        this.helper[0] = firstByte;\n        this.helper[1] = secondByte;\n        this.helper[2] = thirdByte;\n        this.helper[3] = fourthByte;\n        this.writer.write(this.helper.subarray(0, 4));\n        const xingOffset = getXingOffset(data.mpegVersionId, data.channel);\n        this.writer.seek(startPos + xingOffset);\n        this.writeU32(XING);\n        let flags = 0;\n        if (data.frameCount !== null) {\n            flags |= 1;\n        }\n        if (data.fileSize !== null) {\n            flags |= 2;\n        }\n        if (data.toc !== null) {\n            flags |= 4;\n        }\n        this.writeU32(flags);\n        this.writeU32(data.frameCount ?? 0);\n        this.writeU32(data.fileSize ?? 0);\n        this.writer.write(data.toc ?? new Uint8Array(100));\n        const frameSize = computeMp3FrameSize(data.layer, 1000 * bitrates[bitrateIndex], sampleRate, padding);\n        this.writer.seek(startPos + frameSize);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3650, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/mp3/mp3-muxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert, toDataView } from '../misc.js';\nimport { Muxer } from '../muxer.js';\nimport { getXingOffset, INFO, readFrameHeader, XING } from '../../shared/mp3-misc.js';\nimport { Mp3Writer } from './mp3-writer.js';\nexport class Mp3Muxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.xingFrameData = null;\n        this.frameCount = 0;\n        this.framePositions = [];\n        this.format = format;\n        this.writer = output._writer;\n        this.mp3Writer = new Mp3Writer(output._writer);\n    }\n    async start() {\n        // Nothing needed here\n    }\n    async getMimeType() {\n        return 'audio/mpeg';\n    }\n    async addEncodedVideoPacket() {\n        throw new Error('MP3 does not support video.');\n    }\n    async addEncodedAudioPacket(track, packet) {\n        const release = await this.mutex.acquire();\n        try {\n            const writeXingHeader = this.format._options.xingHeader !== false;\n            if (!this.xingFrameData && writeXingHeader) {\n                const view = toDataView(packet.data);\n                if (view.byteLength < 4) {\n                    throw new Error('Invalid MP3 header in sample.');\n                }\n                const word = view.getUint32(0, false);\n                const header = readFrameHeader(word, { pos: 0, fileSize: null });\n                if (!header) {\n                    throw new Error('Invalid MP3 header in sample.');\n                }\n                const xingOffset = getXingOffset(header.mpegVersionId, header.channel);\n                if (view.byteLength >= xingOffset + 4) {\n                    const word = view.getUint32(xingOffset, false);\n                    const isXing = word === XING || word === INFO;\n                    if (isXing) {\n                        // This is not a data frame, so let's completely ignore this sample\n                        return;\n                    }\n                }\n                this.xingFrameData = {\n                    mpegVersionId: header.mpegVersionId,\n                    layer: header.layer,\n                    frequencyIndex: header.frequencyIndex,\n                    channel: header.channel,\n                    modeExtension: header.modeExtension,\n                    copyright: header.copyright,\n                    original: header.original,\n                    emphasis: header.emphasis,\n                    frameCount: null,\n                    fileSize: null,\n                    toc: null,\n                };\n                // Write a Xing frame because this muxer doesn't make any bitrate constraints, meaning we don't know if\n                // this will be a constant or variable bitrate file. Therefore, always write the Xing frame.\n                this.mp3Writer.writeXingFrame(this.xingFrameData);\n                this.frameCount++;\n            }\n            this.validateAndNormalizeTimestamp(track, packet.timestamp, packet.type === 'key');\n            this.writer.write(packet.data);\n            this.frameCount++;\n            await this.writer.flush();\n            if (writeXingHeader) {\n                this.framePositions.push(this.writer.getPos());\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue() {\n        throw new Error('MP3 does not support subtitles.');\n    }\n    async finalize() {\n        if (!this.xingFrameData) {\n            return;\n        }\n        const release = await this.mutex.acquire();\n        const endPos = this.writer.getPos();\n        this.writer.seek(0);\n        const toc = new Uint8Array(100);\n        for (let i = 0; i < 100; i++) {\n            const index = Math.floor(this.framePositions.length * (i / 100));\n            assert(index !== -1 && index < this.framePositions.length);\n            const byteOffset = this.framePositions[index];\n            toc[i] = 256 * (byteOffset / endPos);\n        }\n        this.xingFrameData.frameCount = this.frameCount;\n        this.xingFrameData.fileSize = endPos;\n        this.xingFrameData.toc = toc;\n        if (this.format._options.onXingFrame) {\n            this.writer.startTrackingWrites();\n        }\n        this.mp3Writer.writeXingFrame(this.xingFrameData);\n        if (this.format._options.onXingFrame) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onXingFrame(data, start);\n        }\n        this.writer.seek(endPos);\n        release();\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3777, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/ogg/ogg-muxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { OPUS_INTERNAL_SAMPLE_RATE, validateAudioChunkMetadata } from '../codec.js';\nimport { parseModesFromVorbisSetupPacket, parseOpusIdentificationHeader } from '../codec-data.js';\nimport { assert, promiseWithResolvers, setInt64, toDataView, toUint8Array } from '../misc.js';\nimport { Muxer } from '../muxer.js';\nimport { buildOggMimeType, computeOggPageCrc, extractSampleMetadata, OGGS, } from './ogg-misc.js';\nimport { MAX_PAGE_SIZE } from './ogg-reader.js';\nconst PAGE_SIZE_TARGET = 8192;\nexport class OggMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.trackDatas = [];\n        this.bosPagesWritten = false;\n        this.allTracksKnown = promiseWithResolvers();\n        this.pageBytes = new Uint8Array(MAX_PAGE_SIZE);\n        this.pageView = new DataView(this.pageBytes.buffer);\n        this.format = format;\n        this.writer = output._writer;\n        this.writer.ensureMonotonicity = true; // Ogg is always monotonically written!\n    }\n    async start() {\n        // Nothin'\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        return buildOggMimeType({\n            codecStrings: this.trackDatas.map(x => x.codecInfo.codec),\n        });\n    }\n    addEncodedVideoPacket() {\n        throw new Error('Video tracks are not supported.');\n    }\n    getTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(td => td.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        // Give the track a unique random serial number\n        let serialNumber;\n        do {\n            serialNumber = Math.floor(2 ** 32 * Math.random());\n        } while (this.trackDatas.some(td => td.serialNumber === serialNumber));\n        assert(track.source._codec === 'vorbis' || track.source._codec === 'opus');\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const newTrackData = {\n            track,\n            serialNumber,\n            internalSampleRate: track.source._codec === 'opus'\n                ? OPUS_INTERNAL_SAMPLE_RATE\n                : meta.decoderConfig.sampleRate,\n            codecInfo: {\n                codec: track.source._codec,\n                vorbisInfo: null,\n                opusInfo: null,\n            },\n            vorbisLastBlocksize: null,\n            packetQueue: [],\n            currentTimestampInSamples: 0,\n            pagesWritten: 0,\n            currentGranulePosition: 0,\n            currentLacingValues: [],\n            currentPageData: [],\n            currentPageSize: 27,\n            currentPageStartsWithFreshPacket: true,\n        };\n        this.queueHeaderPackets(newTrackData, meta);\n        this.trackDatas.push(newTrackData);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    queueHeaderPackets(trackData, meta) {\n        assert(meta.decoderConfig);\n        if (trackData.track.source._codec === 'vorbis') {\n            assert(meta.decoderConfig.description);\n            const bytes = toUint8Array(meta.decoderConfig.description);\n            if (bytes[0] !== 2) {\n                throw new TypeError('First byte of Vorbis decoder description must be 2.');\n            }\n            let pos = 1;\n            const readPacketLength = () => {\n                let length = 0;\n                while (true) {\n                    const value = bytes[pos++];\n                    if (value === undefined) {\n                        throw new TypeError('Vorbis decoder description is too short.');\n                    }\n                    length += value;\n                    if (value < 255) {\n                        return length;\n                    }\n                }\n            };\n            const identificationHeaderLength = readPacketLength();\n            const commentHeaderLength = readPacketLength();\n            const setupHeaderLength = bytes.length - pos; // Setup header fills the remaining bytes\n            if (setupHeaderLength <= 0) {\n                throw new TypeError('Vorbis decoder description is too short.');\n            }\n            const identificationHeader = bytes.subarray(pos, pos += identificationHeaderLength);\n            const commentHeader = bytes.subarray(pos, pos += commentHeaderLength);\n            const setupHeader = bytes.subarray(pos);\n            trackData.packetQueue.push({\n                data: identificationHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true,\n            }, {\n                data: commentHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: false,\n            }, {\n                data: setupHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true, // The last header packet must flush the page\n            });\n            const view = toDataView(identificationHeader);\n            const blockSizeByte = view.getUint8(28);\n            trackData.codecInfo.vorbisInfo = {\n                blocksizes: [\n                    1 << (blockSizeByte & 0xf),\n                    1 << (blockSizeByte >> 4),\n                ],\n                modeBlockflags: parseModesFromVorbisSetupPacket(setupHeader).modeBlockflags,\n            };\n        }\n        else if (trackData.track.source._codec === 'opus') {\n            if (!meta.decoderConfig.description) {\n                throw new TypeError('For Ogg, Opus decoder description is required.');\n            }\n            const identificationHeader = toUint8Array(meta.decoderConfig.description);\n            const commentHeader = new Uint8Array(8 + 4 + 4);\n            const view = new DataView(commentHeader.buffer);\n            view.setUint32(0, 0x4f707573, false); // 'Opus'\n            view.setUint32(4, 0x54616773, false); // 'Tags'\n            view.setUint32(8, 0, true); // Vendor String Length\n            view.setUint32(12, 0, true); // User Comment List Length\n            trackData.packetQueue.push({\n                data: identificationHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true,\n            }, {\n                data: commentHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true, // The last header packet must flush the page\n            });\n            trackData.codecInfo.opusInfo = {\n                preSkip: parseOpusIdentificationHeader(identificationHeader).preSkip,\n            };\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getTrackData(track, meta);\n            this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const currentTimestampInSamples = trackData.currentTimestampInSamples;\n            const { durationInSamples, vorbisBlockSize } = extractSampleMetadata(packet.data, trackData.codecInfo, trackData.vorbisLastBlocksize);\n            trackData.currentTimestampInSamples += durationInSamples;\n            trackData.vorbisLastBlocksize = vorbisBlockSize;\n            trackData.packetQueue.push({\n                data: packet.data,\n                endGranulePosition: trackData.currentTimestampInSamples,\n                timestamp: currentTimestampInSamples / trackData.internalSampleRate,\n                forcePageFlush: false,\n            });\n            await this.interleavePages();\n        }\n        finally {\n            release();\n        }\n    }\n    addSubtitleCue() {\n        throw new Error('Subtitle tracks are not supported.');\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async interleavePages(isFinalCall = false) {\n        if (!this.bosPagesWritten) {\n            if (!this.allTracksAreKnown()) {\n                return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n            }\n            // Write the header page for all bitstreams\n            for (const trackData of this.trackDatas) {\n                while (trackData.packetQueue.length > 0) {\n                    const packet = trackData.packetQueue.shift();\n                    this.writePacket(trackData, packet, false);\n                    if (packet.forcePageFlush) {\n                        // We say the header page ends once the first packet is encountered that forces a page flush\n                        break;\n                    }\n                }\n            }\n            this.bosPagesWritten = true;\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall\n                    && trackData.packetQueue.length <= 1 // Limit is 1, not 0, for correct EOS flag logic\n                    && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.packetQueue.length > 0\n                    && trackData.packetQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.packetQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const packet = trackWithMinTimestamp.packetQueue.shift();\n            const isFinalPacket = trackWithMinTimestamp.packetQueue.length === 0;\n            this.writePacket(trackWithMinTimestamp, packet, isFinalPacket);\n        }\n        if (!isFinalCall) {\n            await this.writer.flush();\n        }\n    }\n    writePacket(trackData, packet, isFinalPacket) {\n        let remainingLength = packet.data.length;\n        let dataStartOffset = 0;\n        let dataOffset = 0;\n        while (true) {\n            if (trackData.currentLacingValues.length === 0 && dataStartOffset > 0) {\n                // This is a packet spanning multiple pages\n                trackData.currentPageStartsWithFreshPacket = false;\n            }\n            const segmentSize = Math.min(255, remainingLength);\n            trackData.currentLacingValues.push(segmentSize);\n            trackData.currentPageSize++;\n            dataOffset += segmentSize;\n            const segmentIsLastOfPacket = remainingLength < 255;\n            if (trackData.currentLacingValues.length === 255) {\n                // The page is full, we need to add part of the packet data and then flush the page\n                const slice = packet.data.subarray(dataStartOffset, dataOffset);\n                dataStartOffset = dataOffset;\n                trackData.currentPageData.push(slice);\n                trackData.currentPageSize += slice.length;\n                this.writePage(trackData, isFinalPacket && segmentIsLastOfPacket);\n                if (segmentIsLastOfPacket) {\n                    return;\n                }\n            }\n            if (segmentIsLastOfPacket) {\n                break;\n            }\n            remainingLength -= 255;\n        }\n        const slice = packet.data.subarray(dataStartOffset);\n        trackData.currentPageData.push(slice);\n        trackData.currentPageSize += slice.length;\n        trackData.currentGranulePosition = packet.endGranulePosition;\n        if (trackData.currentPageSize >= PAGE_SIZE_TARGET || packet.forcePageFlush) {\n            this.writePage(trackData, isFinalPacket);\n        }\n    }\n    writePage(trackData, isEos) {\n        this.pageView.setUint32(0, OGGS, true); // Capture pattern\n        this.pageView.setUint8(4, 0); // Version\n        let headerType = 0;\n        if (!trackData.currentPageStartsWithFreshPacket) {\n            headerType |= 1;\n        }\n        if (trackData.pagesWritten === 0) {\n            headerType |= 2; // Beginning of stream\n        }\n        if (isEos) {\n            headerType |= 4; // End of stream\n        }\n        this.pageView.setUint8(5, headerType); // Header type\n        const granulePosition = trackData.currentLacingValues.every(x => x === 255)\n            ? -1 // No packets end on this page\n            : trackData.currentGranulePosition;\n        setInt64(this.pageView, 6, granulePosition, true); // Granule position\n        this.pageView.setUint32(14, trackData.serialNumber, true); // Serial number\n        this.pageView.setUint32(18, trackData.pagesWritten, true); // Page sequence number\n        this.pageView.setUint32(22, 0, true); // Checksum placeholder\n        this.pageView.setUint8(26, trackData.currentLacingValues.length); // Number of page segments\n        this.pageBytes.set(trackData.currentLacingValues, 27);\n        let pos = 27 + trackData.currentLacingValues.length;\n        for (const data of trackData.currentPageData) {\n            this.pageBytes.set(data, pos);\n            pos += data.length;\n        }\n        const slice = this.pageBytes.subarray(0, pos);\n        const crc = computeOggPageCrc(slice);\n        this.pageView.setUint32(22, crc, true); // Checksum\n        trackData.pagesWritten++;\n        trackData.currentLacingValues.length = 0;\n        trackData.currentPageData.length = 0;\n        trackData.currentPageSize = 27;\n        trackData.currentPageStartsWithFreshPacket = true;\n        if (this.format._options.onPage) {\n            this.writer.startTrackingWrites();\n        }\n        this.writer.write(slice);\n        if (this.format._options.onPage) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onPage(data, start, trackData.track.source);\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose() {\n        const release = await this.mutex.acquire();\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        // Since a track is now closed, we may be able to write out chunks that were previously waiting\n        await this.interleavePages();\n        release();\n    }\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        await this.interleavePages(true);\n        for (const trackData of this.trackDatas) {\n            if (trackData.currentLacingValues.length > 0) {\n                this.writePage(trackData, true);\n            }\n        }\n        release();\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4127, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/wave/riff-writer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport class RiffWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n    }\n    writeU16(value) {\n        this.helperView.setUint16(0, value, true);\n        this.writer.write(this.helper.subarray(0, 2));\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, true);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeU64(value) {\n        this.helperView.setUint32(0, value, true);\n        this.helperView.setUint32(4, Math.floor(value / 2 ** 32), true);\n        this.writer.write(this.helper);\n    }\n    writeAscii(text) {\n        this.writer.write(new TextEncoder().encode(text));\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;AACM,MAAM;IAMT,SAAS,KAAK,EAAE;QACZ,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,OAAO;QACpC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG;IAC9C;IACA,SAAS,KAAK,EAAE;QACZ,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,OAAO;QACpC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG;IAC9C;IACA,SAAS,KAAK,EAAE;QACZ,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,OAAO;QACpC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,GAAG,KAAK,KAAK,CAAC,QAAQ,KAAK,KAAK;QAC1D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM;IACjC;IACA,WAAW,IAAI,EAAE;QACb,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,cAAc,MAAM,CAAC;IAC/C;IApBA,YAAY,MAAM,CAAE;QAChB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG,IAAI,WAAW;QAC7B,IAAI,CAAC,UAAU,GAAG,IAAI,SAAS,IAAI,CAAC,MAAM,CAAC,MAAM;IACrD;AAiBJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4163, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/wave/wave-muxer.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Muxer } from '../muxer.js';\nimport { parsePcmCodec, validateAudioChunkMetadata } from '../codec.js';\nimport { WaveFormat } from './wave-demuxer.js';\nimport { RiffWriter } from './riff-writer.js';\nimport { assert } from '../misc.js';\nexport class WaveMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.headerWritten = false;\n        this.dataSize = 0;\n        this.sampleRate = null;\n        this.sampleCount = 0;\n        this.format = format;\n        this.writer = output._writer;\n        this.riffWriter = new RiffWriter(output._writer);\n        this.isRf64 = !!format._options.large;\n    }\n    async start() {\n        // Nothing needed here - we'll write the header with the first sample\n    }\n    async getMimeType() {\n        return 'audio/wav';\n    }\n    async addEncodedVideoPacket() {\n        throw new Error('WAVE does not support video.');\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            if (!this.headerWritten) {\n                validateAudioChunkMetadata(meta);\n                assert(meta);\n                assert(meta.decoderConfig);\n                this.writeHeader(track, meta.decoderConfig);\n                this.sampleRate = meta.decoderConfig.sampleRate;\n                this.headerWritten = true;\n            }\n            this.validateAndNormalizeTimestamp(track, packet.timestamp, packet.type === 'key');\n            if (!this.isRf64 && this.writer.getPos() + packet.data.byteLength >= 2 ** 32) {\n                throw new Error('Adding more audio data would exceed the maximum RIFF size of 4 GiB. To write larger files, use'\n                    + ' RF64 by setting `large: true` in the WavOutputFormatOptions.');\n            }\n            this.writer.write(packet.data);\n            this.dataSize += packet.data.byteLength;\n            this.sampleCount += Math.round(packet.duration * this.sampleRate);\n            await this.writer.flush();\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue() {\n        throw new Error('WAVE does not support subtitles.');\n    }\n    writeHeader(track, config) {\n        if (this.format._options.onHeader) {\n            this.writer.startTrackingWrites();\n        }\n        let format;\n        const codec = track.source._codec;\n        const pcmInfo = parsePcmCodec(codec);\n        if (pcmInfo.dataType === 'ulaw') {\n            format = WaveFormat.MULAW;\n        }\n        else if (pcmInfo.dataType === 'alaw') {\n            format = WaveFormat.ALAW;\n        }\n        else if (pcmInfo.dataType === 'float') {\n            format = WaveFormat.IEEE_FLOAT;\n        }\n        else {\n            format = WaveFormat.PCM;\n        }\n        const channels = config.numberOfChannels;\n        const sampleRate = config.sampleRate;\n        const blockSize = pcmInfo.sampleSize * channels;\n        // RIFF header\n        this.riffWriter.writeAscii(this.isRf64 ? 'RF64' : 'RIFF');\n        if (this.isRf64) {\n            this.riffWriter.writeU32(0xffffffff); // Not used in RF64\n        }\n        else {\n            this.riffWriter.writeU32(0); // File size placeholder\n        }\n        this.riffWriter.writeAscii('WAVE');\n        if (this.isRf64) {\n            this.riffWriter.writeAscii('ds64');\n            this.riffWriter.writeU32(28); // Chunk size\n            this.riffWriter.writeU64(0); // RIFF size placeholder\n            this.riffWriter.writeU64(0); // Data size placeholder\n            this.riffWriter.writeU64(0); // Sample count placeholder\n            this.riffWriter.writeU32(0); // Table length\n            // Empty table\n        }\n        // fmt chunk\n        this.riffWriter.writeAscii('fmt ');\n        this.riffWriter.writeU32(16); // Chunk size\n        this.riffWriter.writeU16(format);\n        this.riffWriter.writeU16(channels);\n        this.riffWriter.writeU32(sampleRate);\n        this.riffWriter.writeU32(sampleRate * blockSize); // Bytes per second\n        this.riffWriter.writeU16(blockSize);\n        this.riffWriter.writeU16(8 * pcmInfo.sampleSize);\n        // data chunk\n        this.riffWriter.writeAscii('data');\n        if (this.isRf64) {\n            this.riffWriter.writeU32(0xffffffff); // Not used in RF64\n        }\n        else {\n            this.riffWriter.writeU32(0); // Data size placeholder\n        }\n        if (this.format._options.onHeader) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onHeader(data, start);\n        }\n    }\n    async finalize() {\n        const release = await this.mutex.acquire();\n        const endPos = this.writer.getPos();\n        if (this.isRf64) {\n            // Write riff size\n            this.writer.seek(20);\n            this.riffWriter.writeU64(endPos - 8);\n            // Write data size\n            this.writer.seek(28);\n            this.riffWriter.writeU64(this.dataSize);\n            // Write sample count\n            this.writer.seek(36);\n            this.riffWriter.writeU64(this.sampleCount);\n        }\n        else {\n            // Write file size\n            this.writer.seek(4);\n            this.riffWriter.writeU32(endPos - 8);\n            // Write data chunk size\n            this.writer.seek(40);\n            this.riffWriter.writeU32(this.dataSize);\n        }\n        this.writer.seek(endPos);\n        release();\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4315, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/output-format.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AdtsMuxer } from './adts/adts-muxer.js';\nimport { AUDIO_CODECS, NON_PCM_AUDIO_CODECS, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { IsobmffMuxer } from './isobmff/isobmff-muxer.js';\nimport { MatroskaMuxer } from './matroska/matroska-muxer.js';\nimport { Mp3Muxer } from './mp3/mp3-muxer.js';\nimport { OggMuxer } from './ogg/ogg-muxer.js';\nimport { WaveMuxer } from './wave/wave-muxer.js';\n/**\n * Base class representing an output media file format.\n * @public\n */\nexport class OutputFormat {\n    /** Returns a list of video codecs that this output format can contain. */\n    getSupportedVideoCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => VIDEO_CODECS.includes(codec));\n    }\n    /** Returns a list of audio codecs that this output format can contain. */\n    getSupportedAudioCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => AUDIO_CODECS.includes(codec));\n    }\n    /** Returns a list of subtitle codecs that this output format can contain. */\n    getSupportedSubtitleCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => SUBTITLE_CODECS.includes(codec));\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _codecUnsupportedHint(codec) {\n        return '';\n    }\n}\n/**\n * Format representing files compatible with the ISO base media file format (ISOBMFF), like MP4 or MOV files.\n * @public\n */\nexport class IsobmffOutputFormat extends OutputFormat {\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.fastStart !== undefined && ![false, 'in-memory', 'fragmented'].includes(options.fastStart)) {\n            throw new TypeError('options.fastStart, when provided, must be false, \"in-memory\", or \"fragmented\".');\n        }\n        if (options.minimumFragmentDuration !== undefined\n            && (!Number.isFinite(options.minimumFragmentDuration) || options.minimumFragmentDuration < 0)) {\n            throw new TypeError('options.minimumFragmentDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onFtyp !== undefined && typeof options.onFtyp !== 'function') {\n            throw new TypeError('options.onFtyp, when provided, must be a function.');\n        }\n        if (options.onMoov !== undefined && typeof options.onMoov !== 'function') {\n            throw new TypeError('options.onMoov, when provided, must be a function.');\n        }\n        if (options.onMdat !== undefined && typeof options.onMdat !== 'function') {\n            throw new TypeError('options.onMdat, when provided, must be a function.');\n        }\n        if (options.onMoof !== undefined && typeof options.onMoof !== 'function') {\n            throw new TypeError('options.onMoof, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: Infinity },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: Infinity },\n            total: { min: 1, max: 2 ** 32 - 1 }, // Have fun reaching this one\n        };\n    }\n    get supportsVideoRotationMetadata() {\n        return true;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new IsobmffMuxer(output, this);\n    }\n}\n/**\n * MPEG-4 Part 14 (MP4) file format. Supports all codecs except PCM audio codecs.\n * @public\n */\nexport class Mp4OutputFormat extends IsobmffOutputFormat {\n    /** @internal */\n    get _name() {\n        return 'MP4';\n    }\n    get fileExtension() {\n        return '.mp4';\n    }\n    get mimeType() {\n        return 'video/mp4';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...NON_PCM_AUDIO_CODECS,\n            // These are supported via ISO/IEC 23003-5\n            'pcm-s16',\n            'pcm-s16be',\n            'pcm-s24',\n            'pcm-s24be',\n            'pcm-s32',\n            'pcm-s32be',\n            'pcm-f32',\n            'pcm-f32be',\n            'pcm-f64',\n            'pcm-f64be',\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MovOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MOV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * QuickTime File Format (QTFF), often called MOV. Supports all video and audio codecs, but not subtitle codecs.\n * @public\n */\nexport class MovOutputFormat extends IsobmffOutputFormat {\n    /** @internal */\n    get _name() {\n        return 'MOV';\n    }\n    get fileExtension() {\n        return '.mov';\n    }\n    get mimeType() {\n        return 'video/quicktime';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...AUDIO_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new Mp4OutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MP4 will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * Matroska file format.\n * @public\n */\nexport class MkvOutputFormat extends OutputFormat {\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.appendOnly !== undefined && typeof options.appendOnly !== 'boolean') {\n            throw new TypeError('options.appendOnly, when provided, must be a boolean.');\n        }\n        if (options.minimumClusterDuration !== undefined\n            && (!Number.isFinite(options.minimumClusterDuration) || options.minimumClusterDuration < 0)) {\n            throw new TypeError('options.minimumClusterDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onEbmlHeader !== undefined && typeof options.onEbmlHeader !== 'function') {\n            throw new TypeError('options.onEbmlHeader, when provided, must be a function.');\n        }\n        if (options.onSegmentHeader !== undefined && typeof options.onSegmentHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        if (options.onCluster !== undefined && typeof options.onCluster !== 'function') {\n            throw new TypeError('options.onCluster, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new MatroskaMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Matroska';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: Infinity },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: Infinity },\n            total: { min: 1, max: 127 },\n        };\n    }\n    get fileExtension() {\n        return '.mkv';\n    }\n    get mimeType() {\n        return 'video/x-matroska';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...NON_PCM_AUDIO_CODECS,\n            ...PCM_AUDIO_CODECS.filter(codec => !['pcm-s8', 'pcm-f32be', 'pcm-f64be', 'ulaw', 'alaw'].includes(codec)),\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        // While it technically does support it with ProjectionPoseRoll, many players appear to ignore this value\n        return false;\n    }\n}\n/**\n * WebM file format, based on Matroska.\n * @public\n */\nexport class WebMOutputFormat extends MkvOutputFormat {\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS.filter(codec => ['vp8', 'vp9', 'av1'].includes(codec)),\n            ...AUDIO_CODECS.filter(codec => ['opus', 'vorbis'].includes(codec)),\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    get _name() {\n        return 'WebM';\n    }\n    get fileExtension() {\n        return '.webm';\n    }\n    get mimeType() {\n        return 'video/webm';\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MkvOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MKV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * MP3 file format.\n * @public\n */\nexport class Mp3OutputFormat extends OutputFormat {\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.xingHeader !== undefined && typeof options.xingHeader !== 'boolean') {\n            throw new TypeError('options.xingHeader, when provided, must be a boolean.');\n        }\n        if (options.onXingFrame !== undefined && typeof options.onXingFrame !== 'function') {\n            throw new TypeError('options.onXingFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new Mp3Muxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'MP3';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.mp3';\n    }\n    get mimeType() {\n        return 'audio/mpeg';\n    }\n    getSupportedCodecs() {\n        return ['mp3'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * WAVE file format, based on RIFF.\n * @public\n */\nexport class WavOutputFormat extends OutputFormat {\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.large !== undefined && typeof options.large !== 'boolean') {\n            throw new TypeError('options.large, when provided, must be a boolean.');\n        }\n        if (options.onHeader !== undefined && typeof options.onHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new WaveMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'WAVE';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.wav';\n    }\n    get mimeType() {\n        return 'audio/wav';\n    }\n    getSupportedCodecs() {\n        return [\n            ...PCM_AUDIO_CODECS.filter(codec => ['pcm-s16', 'pcm-s24', 'pcm-s32', 'pcm-f32', 'pcm-u8', 'ulaw', 'alaw'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * Ogg file format.\n * @public\n */\nexport class OggOutputFormat extends OutputFormat {\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onPage !== undefined && typeof options.onPage !== 'function') {\n            throw new TypeError('options.onPage, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new OggMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Ogg';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 2 ** 32 },\n        };\n    }\n    get fileExtension() {\n        return '.ogg';\n    }\n    get mimeType() {\n        return 'application/ogg';\n    }\n    getSupportedCodecs() {\n        return [\n            ...AUDIO_CODECS.filter(codec => ['vorbis', 'opus'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * ADTS file format.\n * @public\n */\nexport class AdtsOutputFormat extends OutputFormat {\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onFrame !== undefined && typeof options.onFrame !== 'function') {\n            throw new TypeError('options.onFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new AdtsMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'ADTS';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.aac';\n    }\n    get mimeType() {\n        return 'audio/aac';\n    }\n    getSupportedCodecs() {\n        return ['aac'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4811, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/media-source.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AUDIO_CODECS, buildAudioCodecString, buildVideoCodecString, getAudioEncoderConfigExtension, getVideoEncoderConfigExtension, inferCodecFromCodecString, parsePcmCodec, PCM_AUDIO_CODECS, Quality, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { assert, assertNever, CallSerializer, clamp, promiseWithResolvers, setInt24, setUint24 } from './misc.js';\nimport { SubtitleParser } from './subtitles.js';\nimport { toAlaw, toUlaw } from './pcm.js';\nimport { customVideoEncoders, customAudioEncoders, } from './custom-coder.js';\nimport { EncodedPacket } from './packet.js';\nimport { AudioSample, VideoSample } from './sample.js';\n/**\n * Base class for media sources. Media sources are used to add media samples to an output file.\n * @public\n */\nexport class MediaSource {\n    constructor() {\n        /** @internal */\n        this._connectedTrack = null;\n        /** @internal */\n        this._closingPromise = null;\n        /** @internal */\n        this._closed = false;\n        /**\n         * @internal\n         * A time offset in seconds that is added to all timestamps generated by this source.\n         */\n        this._timestampOffset = 0;\n    }\n    /** @internal */\n    _ensureValidAdd() {\n        if (!this._connectedTrack) {\n            throw new Error('Source is not connected to an output track.');\n        }\n        if (this._connectedTrack.output.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._connectedTrack.output.state === 'finalizing' || this._connectedTrack.output.state === 'finalized') {\n            throw new Error('Output has been finalized.');\n        }\n        if (this._connectedTrack.output.state === 'pending') {\n            throw new Error('Output has not started.');\n        }\n        if (this._closed) {\n            throw new Error('Source is closed.');\n        }\n    }\n    /** @internal */\n    async _start() { }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async _flushAndClose(forceClose) { }\n    /**\n     * Closes this source. This prevents future samples from being added and signals to the output file that no further\n     * samples will come in for this track. Calling `.close()` is optional but recommended after adding the\n     * last sample - for improved performance and reduced memory usage.\n     */\n    close() {\n        if (this._closingPromise) {\n            return;\n        }\n        const connectedTrack = this._connectedTrack;\n        if (!connectedTrack) {\n            throw new Error('Cannot call close without connecting the source to an output track.');\n        }\n        if (connectedTrack.output.state === 'pending') {\n            throw new Error('Cannot call close before output has been started.');\n        }\n        this._closingPromise = (async () => {\n            await this._flushAndClose(false);\n            this._closed = true;\n            if (connectedTrack.output.state === 'finalizing' || connectedTrack.output.state === 'finalized') {\n                return;\n            }\n            connectedTrack.output._muxer.onTrackClose(connectedTrack);\n        })();\n    }\n    /** @internal */\n    async _flushOrWaitForOngoingClose(forceClose) {\n        if (this._closingPromise) {\n            // Since closing also flushes, we don't want to do it twice\n            return this._closingPromise;\n        }\n        else {\n            return this._flushAndClose(forceClose);\n        }\n    }\n}\n/**\n * Base class for video sources - sources for video tracks.\n * @public\n */\nexport class VideoSource extends MediaSource {\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!VIDEO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid video codec '${codec}'. Must be one of: ${VIDEO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic video source; can be used to directly pipe encoded packets into the output file.\n * @public\n */\nexport class EncodedVideoPacketSource extends VideoSource {\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output video track. Packets must be added in *decode order*, while a packet's\n     * timestamp must be its *presentation timestamp*. B-frames are handled automatically.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack, packet, meta);\n    }\n}\nconst validateVideoEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!VIDEO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid video codec '${config.codec}'. Must be one of: ${VIDEO_CODECS.join(', ')}.`);\n    }\n    if (!(config.bitrate instanceof Quality) && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate must be a positive integer or a quality.');\n    }\n    if (config.latencyMode !== undefined && !['quality', 'realtime'].includes(config.latencyMode)) {\n        throw new TypeError('config.latencyMode, when provided, must be \\'quality\\' or \\'realtime\\'.');\n    }\n    if (config.keyFrameInterval !== undefined\n        && (!Number.isFinite(config.keyFrameInterval) || config.keyFrameInterval < 0)) {\n        throw new TypeError('config.keyFrameInterval, when provided, must be a non-negative number.');\n    }\n    if (config.fullCodecString !== undefined && typeof config.fullCodecString !== 'string') {\n        throw new TypeError('config.fullCodecString, when provided, must be a string.');\n    }\n    if (config.fullCodecString !== undefined && inferCodecFromCodecString(config.fullCodecString) !== config.codec) {\n        throw new TypeError(`config.fullCodecString, when provided, must be a string that matches the specified codec`\n            + ` (${config.codec}).`);\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n};\nclass VideoEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastMultipleOfKeyFrameInterval = -1;\n        this.lastWidth = null;\n        this.lastHeight = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new CallSerializer();\n        this.customEncoderQueueSize = 0;\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.encoderError = null;\n    }\n    async add(videoSample, shouldClose, encodeOptions) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure video sample size remains constant\n            if (this.lastWidth !== null && this.lastHeight !== null) {\n                if (videoSample.codedWidth !== this.lastWidth || videoSample.codedHeight !== this.lastHeight) {\n                    throw new Error(`Video sample size must remain constant. Expected ${this.lastWidth}x${this.lastHeight},`\n                        + ` got ${videoSample.codedWidth}x${videoSample.codedHeight}.`);\n                }\n            }\n            else {\n                this.lastWidth = videoSample.codedWidth;\n                this.lastHeight = videoSample.codedHeight;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    void this.ensureEncoder(videoSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            assert(this.encoderInitialized);\n            const keyFrameInterval = this.encodingConfig.keyFrameInterval ?? 5;\n            const multipleOfKeyFrameInterval = Math.floor(videoSample.timestamp / keyFrameInterval);\n            // Ensure a key frame every keyFrameInterval seconds. It is important that all video tracks follow the same\n            // \"key frame\" rhythm, because aligned key frames are required to start new fragments in ISOBMFF or clusters\n            // in Matroska (or at least desirable).\n            const finalEncodeOptions = {\n                ...encodeOptions,\n                keyFrame: encodeOptions?.keyFrame\n                    || keyFrameInterval === 0\n                    || multipleOfKeyFrameInterval !== this.lastMultipleOfKeyFrameInterval,\n            };\n            this.lastMultipleOfKeyFrameInterval = multipleOfKeyFrameInterval;\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = videoSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample, finalEncodeOptions))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.encoderError ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `videoSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n            }\n            else {\n                assert(this.encoder);\n                const videoFrame = videoSample.toVideoFrame();\n                this.encoder.encode(videoFrame, finalEncodeOptions);\n                videoFrame.close();\n                if (shouldClose) {\n                    videoSample.close();\n                }\n                // We need to do this after sending the frame to the encoder as the frame otherwise might be closed\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n            }\n            await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                videoSample.close();\n            }\n        }\n    }\n    async ensureEncoder(videoSample) {\n        if (this.encoder) {\n            return;\n        }\n        return this.ensureEncoderPromise = (async () => {\n            const width = videoSample.codedWidth;\n            const height = videoSample.codedHeight;\n            const bitrate = this.encodingConfig.bitrate instanceof Quality\n                ? this.encodingConfig.bitrate._toVideoBitrate(this.encodingConfig.codec, width, height)\n                : this.encodingConfig.bitrate;\n            const encoderConfig = {\n                codec: this.encodingConfig.fullCodecString ?? buildVideoCodecString(this.encodingConfig.codec, width, height, bitrate),\n                width,\n                height,\n                bitrate,\n                framerate: this.source._connectedTrack?.metadata.frameRate,\n                latencyMode: this.encodingConfig.latencyMode,\n                ...getVideoEncoderConfigExtension(this.encodingConfig.codec),\n            };\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = customVideoEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class 🤓\"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta);\n                };\n                await this.customEncoder.init();\n            }\n            else {\n                if (typeof VideoEncoder === 'undefined') {\n                    throw new Error('VideoEncoder is not supported by this browser.');\n                }\n                const support = await VideoEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.width}x${encoderConfig.height}) is not supported by this browser. Consider`\n                        + ` using another codec or changing your video parameters.`);\n                }\n                this.encoder = new VideoEncoder({\n                    output: (chunk, meta) => {\n                        const packet = EncodedPacket.fromEncodedChunk(chunk);\n                        this.encodingConfig.onEncodedPacket?.(packet, meta);\n                        void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta);\n                    },\n                    error: (error) => {\n                        error.stack = new Error().stack; // Provide a more useful stack trace\n                        this.encoderError ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n            }\n            assert(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    async flushAndClose(forceClose) {\n        this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                await this.encoder.flush();\n            }\n            this.encoder.close();\n        }\n        this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else {\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.encoderError) {\n            throw this.encoderError;\n        }\n    }\n}\n/**\n * This source can be used to add raw, unencoded video samples (frames) to an output video track. These frames will\n * automatically be encoded and then piped into the output.\n * @public\n */\nexport class VideoSampleSource extends VideoSource {\n    constructor(encodingConfig) {\n        validateVideoEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes a video sample (frame) and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(videoSample, encodeOptions) {\n        if (!(videoSample instanceof VideoSample)) {\n            throw new TypeError('videoSample must be a VideoSample.');\n        }\n        return this._encoder.add(videoSample, false, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add video frames to the output track from a fixed canvas element. Since canvases are often\n * used for rendering, this source provides a convenient wrapper around VideoSampleSource.\n * @public\n */\nexport class CanvasSource extends VideoSource {\n    constructor(canvas, encodingConfig) {\n        if (!(typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement)\n            && !(typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n            throw new TypeError('canvas must be an HTMLCanvasElement or OffscreenCanvas.');\n        }\n        validateVideoEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._canvas = canvas;\n    }\n    /**\n     * Captures the current canvas state as a video sample (frame), encodes it and adds it to the output.\n     *\n     * @param timestamp - The timestamp of the sample, in seconds.\n     * @param duration - The duration of the sample, in seconds.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(timestamp, duration = 0, encodeOptions) {\n        if (!Number.isFinite(timestamp) || timestamp < 0) {\n            throw new TypeError('timestamp must be a non-negative number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        const sample = new VideoSample(this._canvas, { timestamp, duration });\n        return this._encoder.add(sample, true, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Video source that encodes the frames of a MediaStreamVideoTrack and pipes them into the output. This is useful for\n * capturing live or real-time data such as webcams or screen captures. Frames will automatically start being captured\n * once the connected Output is started, and will keep being captured until the Output is finalized or this source\n * is closed.\n * @public\n */\nexport class MediaStreamVideoTrackSource extends VideoSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'video') {\n            throw new TypeError('track must be a video MediaStreamTrack.');\n        }\n        validateVideoEncodingConfig(encodingConfig);\n        encodingConfig = {\n            ...encodingConfig,\n            latencyMode: 'realtime',\n        };\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._workerTrackId = null;\n        /** @internal */\n        this._workerListener = null;\n        /** @internal */\n        this._promiseWithResolvers = promiseWithResolvers();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        let firstVideoFrameTimestamp = null;\n        let errored = false;\n        const onVideoFrame = (videoFrame) => {\n            if (errored) {\n                videoFrame.close();\n                return;\n            }\n            if (firstVideoFrameTimestamp === null) {\n                firstVideoFrameTimestamp = videoFrame.timestamp / 1e6;\n                const muxer = this._connectedTrack.output._muxer;\n                if (muxer.firstMediaStreamTimestamp === null) {\n                    muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                    this._timestampOffset = -firstVideoFrameTimestamp;\n                }\n                else {\n                    this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                        - firstVideoFrameTimestamp;\n                }\n            }\n            if (this._encoder.getQueueSize() >= 4) {\n                // Drop frames if the encoder is overloaded\n                videoFrame.close();\n                return;\n            }\n            void this._encoder.add(new VideoSample(videoFrame), true)\n                .catch((error) => {\n                errored = true;\n                this._abortController?.abort();\n                this._promiseWithResolvers.reject(error);\n                if (this._workerTrackId !== null) {\n                    // Tell the worker to stop the track\n                    sendMessageToMediaStreamTrackProcessorWorker({\n                        type: 'stopTrack',\n                        trackId: this._workerTrackId,\n                    });\n                }\n            });\n        };\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // We can do it here directly, perfect\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({ write: onVideoFrame });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // It might still be supported in a worker, so let's check that\n            const supportedInWorker = await mediaStreamTrackProcessorIsSupportedInWorker();\n            if (supportedInWorker) {\n                this._workerTrackId = nextMediaStreamTrackProcessorWorkerId++;\n                sendMessageToMediaStreamTrackProcessorWorker({\n                    type: 'videoTrack',\n                    trackId: this._workerTrackId,\n                    track: this._track,\n                }, [this._track]);\n                this._workerListener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'videoFrame' && message.trackId === this._workerTrackId) {\n                        onVideoFrame(message.videoFrame);\n                    }\n                    else if (message.type === 'error' && message.trackId === this._workerTrackId) {\n                        this._promiseWithResolvers.reject(message.error);\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', this._workerListener);\n            }\n            else {\n                throw new Error('MediaStreamTrackProcessor is required but not supported by this browser.');\n            }\n        }\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._workerTrackId !== null) {\n            assert(this._workerListener);\n            sendMessageToMediaStreamTrackProcessorWorker({\n                type: 'stopTrack',\n                trackId: this._workerTrackId,\n            });\n            // Wait for the worker to stop the track\n            await new Promise((resolve) => {\n                const listener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'trackStopped' && message.trackId === this._workerTrackId) {\n                        assert(this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                        resolve();\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n            });\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Base class for audio sources - sources for audio tracks.\n * @public\n */\nexport class AudioSource extends MediaSource {\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!AUDIO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid audio codec '${codec}'. Must be one of: ${AUDIO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic audio source; can be used to directly pipe encoded packets into the output file.\n * @public\n */\nexport class EncodedAudioPacketSource extends AudioSource {\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output audio track. Packets must be added in *decode order*.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack, packet, meta);\n    }\n}\nconst validateAudioEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!AUDIO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid audio codec '${config.codec}'. Must be one of: ${AUDIO_CODECS.join(', ')}.`);\n    }\n    if (config.bitrate === undefined\n        && (!PCM_AUDIO_CODECS.includes(config.codec) || config.codec === 'flac')) {\n        throw new TypeError('config.bitrate must be provided for compressed audio codecs.');\n    }\n    if (config.bitrate !== undefined\n        && !(config.bitrate instanceof Quality)\n        && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate, when provided, must be a positive integer or a quality.');\n    }\n    if (config.fullCodecString !== undefined && typeof config.fullCodecString !== 'string') {\n        throw new TypeError('config.fullCodecString, when provided, must be a string.');\n    }\n    if (config.fullCodecString !== undefined && inferCodecFromCodecString(config.fullCodecString) !== config.codec) {\n        throw new TypeError(`config.fullCodecString, when provided, must be a string that matches the specified codec`\n            + ` (${config.codec}).`);\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n};\nclass AudioEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastNumberOfChannels = null;\n        this.lastSampleRate = null;\n        this.isPcmEncoder = false;\n        this.outputSampleSize = null;\n        this.writeOutputValue = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new CallSerializer();\n        this.customEncoderQueueSize = 0;\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.encoderError = null;\n    }\n    async add(audioSample, shouldClose) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure audio parameters remain constant\n            if (this.lastNumberOfChannels !== null && this.lastSampleRate !== null) {\n                if (audioSample.numberOfChannels !== this.lastNumberOfChannels\n                    || audioSample.sampleRate !== this.lastSampleRate) {\n                    throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at`\n                        + ` ${this.lastSampleRate} Hz, got ${audioSample.numberOfChannels} channels at`\n                        + ` ${audioSample.sampleRate} Hz.`);\n                }\n            }\n            else {\n                this.lastNumberOfChannels = audioSample.numberOfChannels;\n                this.lastSampleRate = audioSample.sampleRate;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    void this.ensureEncoder(audioSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            assert(this.encoderInitialized);\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = audioSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.encoderError ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `audioSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n            else if (this.isPcmEncoder) {\n                await this.doPcmEncoding(audioSample, shouldClose);\n            }\n            else {\n                assert(this.encoder);\n                const audioData = audioSample.toAudioData();\n                this.encoder.encode(audioData);\n                audioData.close();\n                if (shouldClose) {\n                    audioSample.close();\n                }\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                audioSample.close();\n            }\n        }\n    }\n    async doPcmEncoding(audioSample, shouldClose) {\n        assert(this.outputSampleSize);\n        assert(this.writeOutputValue);\n        // Need to extract data from the audio data before we close it\n        const { numberOfChannels, numberOfFrames, sampleRate, timestamp } = audioSample;\n        const CHUNK_SIZE = 2048;\n        const outputs = [];\n        // Prepare all of the output buffers, each being bounded by CHUNK_SIZE so we don't generate huge packets\n        for (let frame = 0; frame < numberOfFrames; frame += CHUNK_SIZE) {\n            const frameCount = Math.min(CHUNK_SIZE, audioSample.numberOfFrames - frame);\n            const outputSize = frameCount * numberOfChannels * this.outputSampleSize;\n            const outputBuffer = new ArrayBuffer(outputSize);\n            const outputView = new DataView(outputBuffer);\n            outputs.push({ frameCount, view: outputView });\n        }\n        const allocationSize = audioSample.allocationSize(({ planeIndex: 0, format: 'f32-planar' }));\n        const floats = new Float32Array(allocationSize / Float32Array.BYTES_PER_ELEMENT);\n        for (let i = 0; i < numberOfChannels; i++) {\n            audioSample.copyTo(floats, { planeIndex: i, format: 'f32-planar' });\n            for (let j = 0; j < outputs.length; j++) {\n                const { frameCount, view } = outputs[j];\n                for (let k = 0; k < frameCount; k++) {\n                    this.writeOutputValue(view, (k * numberOfChannels + i) * this.outputSampleSize, floats[j * CHUNK_SIZE + k]);\n                }\n            }\n        }\n        if (shouldClose) {\n            audioSample.close();\n        }\n        const meta = {\n            decoderConfig: {\n                codec: this.encodingConfig.codec,\n                numberOfChannels,\n                sampleRate,\n            },\n        };\n        for (let i = 0; i < outputs.length; i++) {\n            const { frameCount, view } = outputs[i];\n            const outputBuffer = view.buffer;\n            const startFrame = i * CHUNK_SIZE;\n            const packet = new EncodedPacket(new Uint8Array(outputBuffer), 'key', timestamp + startFrame / sampleRate, frameCount / sampleRate);\n            this.encodingConfig.onEncodedPacket?.(packet, meta);\n            await this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta); // With backpressure\n        }\n    }\n    ensureEncoder(audioSample) {\n        if (this.encoderInitialized) {\n            return;\n        }\n        return this.ensureEncoderPromise = (async () => {\n            const { numberOfChannels, sampleRate } = audioSample;\n            const bitrate = this.encodingConfig.bitrate instanceof Quality\n                ? this.encodingConfig.bitrate._toAudioBitrate(this.encodingConfig.codec)\n                : this.encodingConfig.bitrate;\n            const encoderConfig = {\n                codec: this.encodingConfig.fullCodecString ?? buildAudioCodecString(this.encodingConfig.codec, numberOfChannels, sampleRate),\n                numberOfChannels,\n                sampleRate,\n                bitrate,\n                ...getAudioEncoderConfigExtension(this.encodingConfig.codec),\n            };\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = customAudioEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class 🤓\"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta);\n                };\n                await this.customEncoder.init();\n            }\n            else if (PCM_AUDIO_CODECS.includes(this.encodingConfig.codec)) {\n                this.initPcmEncoder();\n            }\n            else {\n                if (typeof AudioEncoder === 'undefined') {\n                    throw new Error('AudioEncoder is not supported by this browser.');\n                }\n                const support = await AudioEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.numberOfChannels} channels, ${encoderConfig.sampleRate} Hz) is not`\n                        + ` supported by this browser. Consider using another codec or changing your audio parameters.`);\n                }\n                this.encoder = new AudioEncoder({\n                    output: (chunk, meta) => {\n                        const packet = EncodedPacket.fromEncodedChunk(chunk);\n                        this.encodingConfig.onEncodedPacket?.(packet, meta);\n                        void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta);\n                    },\n                    error: (error) => {\n                        error.stack = new Error().stack; // Provide a more useful stack trace\n                        this.encoderError ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n            }\n            assert(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    initPcmEncoder() {\n        this.isPcmEncoder = true;\n        const codec = this.encodingConfig.codec;\n        const { dataType, sampleSize, littleEndian } = parsePcmCodec(codec);\n        this.outputSampleSize = sampleSize;\n        // All these functions receive a float sample as input and map it into the desired format\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint8(byteOffset, clamp((value + 1) * 127.5, 0, 255));\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            view.setInt8(byteOffset, clamp(Math.round(value * 128), -128, 127));\n                        };\n                    }\n                    else if (dataType === 'ulaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = clamp(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, toUlaw(int16));\n                        };\n                    }\n                    else if (dataType === 'alaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = clamp(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, toAlaw(int16));\n                        };\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint16(byteOffset, clamp((value + 1) * 32767.5, 0, 65535), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, clamp(Math.round(value * 32767), -32768, 32767), littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 3:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => setUint24(view, byteOffset, clamp((value + 1) * 8388607.5, 0, 16777215), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => setInt24(view, byteOffset, clamp(Math.round(value * 8388607), -8388608, 8388607), littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 4:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint32(byteOffset, clamp((value + 1) * 2147483647.5, 0, 4294967295), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, clamp(Math.round(value * 2147483647), -2147483648, 2147483647), littleEndian);\n                    }\n                    else if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat64(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            default:\n                {\n                    assertNever(sampleSize);\n                    assert(false);\n                }\n                ;\n        }\n    }\n    async flushAndClose(forceClose) {\n        this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                await this.encoder.flush();\n            }\n            this.encoder.close();\n        }\n        this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else if (this.isPcmEncoder) {\n            return 0;\n        }\n        else {\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.encoderError) {\n            throw this.encoderError;\n        }\n    }\n}\n/**\n * This source can be used to add raw, unencoded audio samples to an output audio track. These samples will\n * automatically be encoded and then piped into the output.\n * @public\n */\nexport class AudioSampleSource extends AudioSource {\n    constructor(encodingConfig) {\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes an audio sample and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(audioSample) {\n        if (!(audioSample instanceof AudioSample)) {\n            throw new TypeError('audioSample must be an AudioSample.');\n        }\n        return this._encoder.add(audioSample, false);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add audio data from an AudioBuffer to the output track. This is useful when working with\n * the Web Audio API.\n * @public\n */\nexport class AudioBufferSource extends AudioSource {\n    constructor(encodingConfig) {\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._accumulatedTime = 0;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Converts an AudioBuffer to audio samples, encodes them and adds them to the output. The first AudioBuffer will\n     * be played at timestamp 0, and any subsequent AudioBuffer will have a timestamp equal to the total duration of\n     * all previous AudioBuffers.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    async add(audioBuffer) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const iterator = AudioSample._fromAudioBuffer(audioBuffer, this._accumulatedTime);\n        this._accumulatedTime += audioBuffer.duration;\n        for (const audioSample of iterator) {\n            await this._encoder.add(audioSample, true);\n        }\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Audio source that encodes the data of a MediaStreamAudioTrack and pipes it into the output. This is useful for\n * capturing live or real-time audio such as microphones or audio from other media elements. Audio will automatically\n * start being captured once the connected Output is started, and will keep being captured until the Output is\n * finalized or this source is closed.\n * @public\n */\nexport class MediaStreamAudioTrackSource extends AudioSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'audio') {\n            throw new TypeError('track must be an audio MediaStreamTrack.');\n        }\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._audioContext = null;\n        /** @internal */\n        this._scriptProcessorNode = null; // Deprecated but goated\n        /** @internal */\n        this._promiseWithResolvers = promiseWithResolvers();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // Great, MediaStreamTrackProcessor is supported, this is the preferred way of doing things\n            let firstAudioDataTimestamp = null;\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({\n                write: (audioData) => {\n                    if (firstAudioDataTimestamp === null) {\n                        firstAudioDataTimestamp = audioData.timestamp / 1e6;\n                        const muxer = this._connectedTrack.output._muxer;\n                        if (muxer.firstMediaStreamTimestamp === null) {\n                            muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                            this._timestampOffset = -firstAudioDataTimestamp;\n                        }\n                        else {\n                            this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                                - firstAudioDataTimestamp;\n                        }\n                    }\n                    if (this._encoder.getQueueSize() >= 4) {\n                        // Drop data if the encoder is overloaded\n                        audioData.close();\n                        return;\n                    }\n                    void this._encoder.add(new AudioSample(audioData), true)\n                        .catch((error) => {\n                        this._abortController?.abort();\n                        this._promiseWithResolvers.reject(error);\n                    });\n                },\n            });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // Let's fall back to an AudioContext approach\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n            const AudioContext = window.AudioContext || window.webkitAudioContext;\n            this._audioContext = new AudioContext({ sampleRate: this._track.getSettings().sampleRate });\n            const sourceNode = this._audioContext.createMediaStreamSource(new MediaStream([this._track]));\n            this._scriptProcessorNode = this._audioContext.createScriptProcessor(4096);\n            if (this._audioContext.state === 'suspended') {\n                await this._audioContext.resume();\n            }\n            sourceNode.connect(this._scriptProcessorNode);\n            this._scriptProcessorNode.connect(this._audioContext.destination);\n            let audioReceived = false;\n            let totalDuration = 0;\n            this._scriptProcessorNode.onaudioprocess = (event) => {\n                const iterator = AudioSample._fromAudioBuffer(event.inputBuffer, totalDuration);\n                totalDuration += event.inputBuffer.duration;\n                for (const audioSample of iterator) {\n                    if (!audioReceived) {\n                        audioReceived = true;\n                        const muxer = this._connectedTrack.output._muxer;\n                        if (muxer.firstMediaStreamTimestamp === null) {\n                            muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                        }\n                        else {\n                            this._timestampOffset = performance.now() / 1000 - muxer.firstMediaStreamTimestamp;\n                        }\n                    }\n                    if (this._encoder.getQueueSize() >= 4) {\n                        // Drop data if the encoder is overloaded\n                        audioSample.close();\n                        continue;\n                    }\n                    void this._encoder.add(audioSample, true)\n                        .catch((error) => {\n                        void this._audioContext.suspend();\n                        this._promiseWithResolvers.reject(error);\n                    });\n                }\n            };\n        }\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._audioContext) {\n            assert(this._scriptProcessorNode);\n            this._scriptProcessorNode.disconnect();\n            await this._audioContext.suspend();\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\nconst mediaStreamTrackProcessorWorkerCode = () => {\n    const sendMessage = (message, transfer) => {\n        if (transfer) {\n            self.postMessage(message, { transfer });\n        }\n        else {\n            self.postMessage(message);\n        }\n    };\n    // Immediately send a message to the main thread, letting them know of the support\n    sendMessage({\n        type: 'support',\n        supported: typeof MediaStreamTrackProcessor !== 'undefined',\n    });\n    const abortControllers = new Map();\n    const stoppedTracks = new Set();\n    self.addEventListener('message', (event) => {\n        const message = event.data;\n        switch (message.type) {\n            case 'videoTrack':\n                {\n                    const processor = new MediaStreamTrackProcessor({ track: message.track });\n                    const consumer = new WritableStream({\n                        write: (videoFrame) => {\n                            if (stoppedTracks.has(message.trackId)) {\n                                videoFrame.close();\n                                return;\n                            }\n                            // Send it to the main thread\n                            sendMessage({\n                                type: 'videoFrame',\n                                trackId: message.trackId,\n                                videoFrame,\n                            }, [videoFrame]);\n                        },\n                    });\n                    const abortController = new AbortController();\n                    abortControllers.set(message.trackId, abortController);\n                    processor.readable.pipeTo(consumer, {\n                        signal: abortController.signal,\n                    }).catch((error) => {\n                        // Handle AbortError silently\n                        if (error instanceof DOMException && error.name === 'AbortError')\n                            return;\n                        sendMessage({\n                            type: 'error',\n                            trackId: message.trackId,\n                            error,\n                        });\n                    });\n                }\n                ;\n                break;\n            case 'stopTrack':\n                {\n                    const abortController = abortControllers.get(message.trackId);\n                    if (abortController) {\n                        abortController.abort();\n                        abortControllers.delete(message.trackId);\n                    }\n                    stoppedTracks.add(message.trackId);\n                    sendMessage({\n                        type: 'trackStopped',\n                        trackId: message.trackId,\n                    });\n                }\n                ;\n                break;\n            default: assertNever(message);\n        }\n    });\n};\nlet nextMediaStreamTrackProcessorWorkerId = 0;\nlet mediaStreamTrackProcessorWorker = null;\nconst initMediaStreamTrackProcessorWorker = () => {\n    const blob = new Blob([`(${mediaStreamTrackProcessorWorkerCode.toString()})()`], { type: 'application/javascript' });\n    const url = URL.createObjectURL(blob);\n    mediaStreamTrackProcessorWorker = new Worker(url);\n};\nlet mediaStreamTrackProcessorIsSupportedInWorkerCache = null;\nconst mediaStreamTrackProcessorIsSupportedInWorker = async () => {\n    if (mediaStreamTrackProcessorIsSupportedInWorkerCache !== null) {\n        return mediaStreamTrackProcessorIsSupportedInWorkerCache;\n    }\n    if (!mediaStreamTrackProcessorWorker) {\n        initMediaStreamTrackProcessorWorker();\n    }\n    return new Promise((resolve) => {\n        assert(mediaStreamTrackProcessorWorker);\n        const listener = (event) => {\n            const message = event.data;\n            if (message.type === 'support') {\n                mediaStreamTrackProcessorIsSupportedInWorkerCache = message.supported;\n                mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                resolve(message.supported);\n            }\n        };\n        mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n    });\n};\nconst sendMessageToMediaStreamTrackProcessorWorker = (message, transfer) => {\n    assert(mediaStreamTrackProcessorWorker);\n    if (transfer) {\n        mediaStreamTrackProcessorWorker.postMessage(message, transfer);\n    }\n    else {\n        mediaStreamTrackProcessorWorker.postMessage(message);\n    }\n};\n/**\n * Base class for subtitle sources - sources for subtitle tracks.\n * @public\n */\nexport class SubtitleSource extends MediaSource {\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!SUBTITLE_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid subtitle codec '${codec}'. Must be one of: ${SUBTITLE_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * This source can be used to add subtitles from a subtitle text file.\n * @public\n */\nexport class TextSubtitleSource extends SubtitleSource {\n    constructor(codec) {\n        super(codec);\n        this._parser = new SubtitleParser({\n            codec,\n            output: (cue, metadata) => this._connectedTrack?.output._muxer.addSubtitleCue(this._connectedTrack, cue, metadata),\n        });\n    }\n    /**\n     * Parses the subtitle text according to the specified codec and adds it to the output track. You don't have to\n     * add the entire subtitle file at once here; you can provide it in chunks.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(text) {\n        if (typeof text !== 'string') {\n            throw new TypeError('text must be a string.');\n        }\n        this._ensureValidAdd();\n        this._parser.parse(text);\n        return this._connectedTrack.output._muxer.mutex.currentPromise;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6078, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/node_modules/.bun/mediabunny%401.9.3/node_modules/mediabunny/dist/modules/src/output.js"],"sourcesContent":["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AsyncMutex, isIso639Dash2LanguageCode } from './misc.js';\nimport { OutputFormat } from './output-format.js';\nimport { AudioSource, SubtitleSource, VideoSource } from './media-source.js';\nimport { Target } from './target.js';\n/**\n * List of all track types.\n * @public\n */\nexport const ALL_TRACK_TYPES = ['video', 'audio', 'subtitle'];\nconst validateBaseTrackMetadata = (metadata) => {\n    if (!metadata || typeof metadata !== 'object') {\n        throw new TypeError('metadata must be an object.');\n    }\n    if (metadata.languageCode !== undefined && !isIso639Dash2LanguageCode(metadata.languageCode)) {\n        throw new TypeError('metadata.languageCode must be a three-letter, ISO 639-2/T language code.');\n    }\n};\n/**\n * Main class orchestrating the creation of a new media file.\n * @public\n */\nexport class Output {\n    constructor(options) {\n        /** The current state of the output. */\n        this.state = 'pending';\n        /** @internal */\n        this._tracks = [];\n        /** @internal */\n        this._startPromise = null;\n        /** @internal */\n        this._cancelPromise = null;\n        /** @internal */\n        this._finalizePromise = null;\n        /** @internal */\n        this._mutex = new AsyncMutex();\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!(options.format instanceof OutputFormat)) {\n            throw new TypeError('options.format must be an OutputFormat.');\n        }\n        if (!(options.target instanceof Target)) {\n            throw new TypeError('options.target must be a Target.');\n        }\n        if (options.target._output) {\n            throw new Error('Target is already used for another output.');\n        }\n        options.target._output = this;\n        this.format = options.format;\n        this.target = options.target;\n        this._writer = options.target._createWriter();\n        this._muxer = options.format._createMuxer(this);\n    }\n    /** Adds a video track to the output with the given source. Must be called before output is started. */\n    addVideoTrack(source, metadata = {}) {\n        if (!(source instanceof VideoSource)) {\n            throw new TypeError('source must be a VideoSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        if (metadata.rotation !== undefined && ![0, 90, 180, 270].includes(metadata.rotation)) {\n            throw new TypeError(`Invalid video rotation: ${metadata.rotation}. Has to be 0, 90, 180 or 270.`);\n        }\n        if (!this.format.supportsVideoRotationMetadata && metadata.rotation) {\n            throw new Error(`${this.format._name} does not support video rotation metadata.`);\n        }\n        if (metadata.frameRate !== undefined\n            && (!Number.isFinite(metadata.frameRate) || metadata.frameRate <= 0)) {\n            throw new TypeError(`Invalid video frame rate: ${metadata.frameRate}. Must be a positive number.`);\n        }\n        this._addTrack('video', source, metadata);\n    }\n    /** Adds an audio track to the output with the given source. Must be called before output is started. */\n    addAudioTrack(source, metadata = {}) {\n        if (!(source instanceof AudioSource)) {\n            throw new TypeError('source must be an AudioSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('audio', source, metadata);\n    }\n    /** Adds a subtitle track to the output with the given source. Must be called before output is started. */\n    addSubtitleTrack(source, metadata = {}) {\n        if (!(source instanceof SubtitleSource)) {\n            throw new TypeError('source must be a SubtitleSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('subtitle', source, metadata);\n    }\n    /** @internal */\n    _addTrack(type, source, metadata) {\n        if (this.state !== 'pending') {\n            throw new Error('Cannot add track after output has been started or canceled.');\n        }\n        if (source._connectedTrack) {\n            throw new Error('Source is already used for a track.');\n        }\n        // Verify maximum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === type ? 1 : 0), 0);\n        const maxCount = supportedTrackCounts[type].max;\n        if (presentTracksOfThisType === maxCount) {\n            throw new Error(maxCount === 0\n                ? `${this.format._name} does not support ${type} tracks.`\n                : (`${this.format._name} does not support more than ${maxCount} ${type} track`\n                    + `${maxCount === 1 ? '' : 's'}.`));\n        }\n        const maxTotalCount = supportedTrackCounts.total.max;\n        if (this._tracks.length === maxTotalCount) {\n            throw new Error(`${this.format._name} does not support more than ${maxTotalCount} tracks`\n                + `${maxTotalCount === 1 ? '' : 's'} in total.`);\n        }\n        const track = {\n            id: this._tracks.length + 1,\n            output: this,\n            type,\n            source: source,\n            metadata,\n        };\n        if (track.type === 'video') {\n            const supportedVideoCodecs = this.format.getSupportedVideoCodecs();\n            if (supportedVideoCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support video tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedVideoCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` video codecs are: ${supportedVideoCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'audio') {\n            const supportedAudioCodecs = this.format.getSupportedAudioCodecs();\n            if (supportedAudioCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support audio tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedAudioCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` audio codecs are: ${supportedAudioCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'subtitle') {\n            const supportedSubtitleCodecs = this.format.getSupportedSubtitleCodecs();\n            if (supportedSubtitleCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support subtitle tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedSubtitleCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` subtitle codecs are: ${supportedSubtitleCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        this._tracks.push(track);\n        source._connectedTrack = track;\n    }\n    /**\n     * Starts the creation of the output file. This method should be called after all tracks have been added. Only after\n     * the output has started can media samples be added to the tracks.\n     *\n     * @returns A promise that resolves when the output has successfully started and is ready to receive media samples.\n     */\n    async start() {\n        // Verify minimum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        for (const trackType of ALL_TRACK_TYPES) {\n            const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === trackType ? 1 : 0), 0);\n            const minCount = supportedTrackCounts[trackType].min;\n            if (presentTracksOfThisType < minCount) {\n                throw new Error(minCount === supportedTrackCounts[trackType].max\n                    ? (`${this.format._name} requires exactly ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`)\n                    : (`${this.format._name} requires at least ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`));\n            }\n        }\n        const totalMinCount = supportedTrackCounts.total.min;\n        if (this._tracks.length < totalMinCount) {\n            throw new Error(totalMinCount === supportedTrackCounts.total.max\n                ? (`${this.format._name} requires exactly ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`)\n                : (`${this.format._name} requires at least ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`));\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._startPromise) {\n            console.warn('Output has already been started.');\n            return this._startPromise;\n        }\n        return this._startPromise = (async () => {\n            this.state = 'started';\n            this._writer.start();\n            const release = await this._mutex.acquire();\n            await this._muxer.start();\n            const promises = this._tracks.map(track => track.source._start());\n            await Promise.all(promises);\n            release();\n        })();\n    }\n    /**\n     * Resolves with the full MIME type of the output file, including track codecs.\n     *\n     * The returned promise will resolve only once the precise codec strings of all tracks are known.\n     */\n    getMimeType() {\n        return this._muxer.getMimeType();\n    }\n    /**\n     * Cancels the creation of the output file, releasing internal resources like encoders and preventing further\n     * samples from being added.\n     *\n     * @returns A promise that resolves once all internal resources have been released.\n     */\n    async cancel() {\n        if (this._cancelPromise) {\n            console.warn('Output has already been canceled.');\n            return this._cancelPromise;\n        }\n        else if (this.state === 'finalizing' || this.state === 'finalized') {\n            console.warn('Output has already been finalized.');\n            return;\n        }\n        return this._cancelPromise = (async () => {\n            this.state = 'canceled';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(true)); // Force close\n            await Promise.all(promises);\n            await this._writer.close();\n            release();\n        })();\n    }\n    /**\n     * Finalizes the output file. This method must be called after all media samples across all tracks have been added.\n     * Once the Promise returned by this method completes, the output file is ready.\n     */\n    async finalize() {\n        if (this.state === 'pending') {\n            throw new Error('Cannot finalize before starting.');\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Cannot finalize after canceling.');\n        }\n        if (this._finalizePromise) {\n            console.warn('Output has already been finalized.');\n            return this._finalizePromise;\n        }\n        return this._finalizePromise = (async () => {\n            this.state = 'finalizing';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(false));\n            await Promise.all(promises);\n            await this._muxer.finalize();\n            await this._writer.flush();\n            await this._writer.finalize();\n            this.state = 'finalized';\n            release();\n        })();\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}