{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 13, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/components/ui/sonner.tsx"],"sourcesContent":["\"use client\";\n\nimport { useTheme } from \"next-themes\";\nimport { Toaster as Sonner } from \"sonner\";\n\ntype ToasterProps = React.ComponentProps<typeof Sonner>;\n\nconst Toaster = ({ ...props }: ToasterProps) => {\n  const { theme = \"system\" } = useTheme();\n\n  return (\n    <Sonner\n      theme={theme as ToasterProps[\"theme\"]}\n      className=\"toaster group\"\n      position=\"top-center\"\n      offset={20}\n      toastOptions={{\n        classNames: {\n          toast:\n            \"group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg\",\n          description: \"group-[.toast]:text-muted-foreground\",\n          actionButton:\n            \"group-[.toast]:bg-primary group-[.toast]:text-primary-foreground\",\n          cancelButton:\n            \"group-[.toast]:bg-muted group-[.toast]:text-muted-foreground\",\n        },\n      }}\n      expand={false}\n      richColors\n      {...props}\n    />\n  );\n};\n\nexport { Toaster };\n"],"names":[],"mappings":";;;;AAEA;AACA;AAHA;;;;AAOA,MAAM,UAAU,CAAC,EAAE,GAAG,OAAqB;IACzC,MAAM,EAAE,QAAQ,QAAQ,EAAE,GAAG,CAAA,GAAA,8NAAA,CAAA,WAAQ,AAAD;IAEpC,qBACE,mTAAC,8MAAA,CAAA,UAAM;QACL,OAAO;QACP,WAAU;QACV,UAAS;QACT,QAAQ;QACR,cAAc;YACZ,YAAY;gBACV,OACE;gBACF,aAAa;gBACb,cACE;gBACF,cACE;YACJ;QACF;QACA,QAAQ;QACR,UAAU;QACT,GAAG,KAAK;;;;;;AAGf","debugId":null}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/storage/indexeddb-adapter.ts"],"sourcesContent":["import { StorageAdapter } from \"./types\";\n\nexport class IndexedDBAdapter<T> implements StorageAdapter<T> {\n  private dbName: string;\n  private storeName: string;\n  private version: number;\n\n  constructor(dbName: string, storeName: string, version = 1) {\n    this.dbName = dbName;\n    this.storeName = storeName;\n    this.version = version;\n  }\n\n  private async getDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName, { keyPath: \"id\" });\n        }\n      };\n    });\n  }\n\n  async get(key: string): Promise<T | null> {\n    const db = await this.getDB();\n    const transaction = db.transaction([this.storeName], \"readonly\");\n    const store = transaction.objectStore(this.storeName);\n\n    return new Promise((resolve, reject) => {\n      const request = store.get(key);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result || null);\n    });\n  }\n\n  async set(key: string, value: T): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction([this.storeName], \"readwrite\");\n    const store = transaction.objectStore(this.storeName);\n\n    return new Promise((resolve, reject) => {\n      const request = store.put({ id: key, ...value });\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async remove(key: string): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction([this.storeName], \"readwrite\");\n    const store = transaction.objectStore(this.storeName);\n\n    return new Promise((resolve, reject) => {\n      const request = store.delete(key);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async list(): Promise<string[]> {\n    const db = await this.getDB();\n    const transaction = db.transaction([this.storeName], \"readonly\");\n    const store = transaction.objectStore(this.storeName);\n\n    return new Promise((resolve, reject) => {\n      const request = store.getAllKeys();\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result as string[]);\n    });\n  }\n\n  async clear(): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction([this.storeName], \"readwrite\");\n    const store = transaction.objectStore(this.storeName);\n\n    return new Promise((resolve, reject) => {\n      const request = store.clear();\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 147, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/storage/opfs-adapter.ts"],"sourcesContent":["import { StorageAdapter } from \"./types\";\n\nexport class OPFSAdapter implements StorageAdapter<File> {\n  private directoryName: string;\n\n  constructor(directoryName = \"media\") {\n    this.directoryName = directoryName;\n  }\n\n  private async getDirectory(): Promise<FileSystemDirectoryHandle> {\n    const opfsRoot = await navigator.storage.getDirectory();\n    return await opfsRoot.getDirectoryHandle(this.directoryName, {\n      create: true,\n    });\n  }\n\n  async get(key: string): Promise<File | null> {\n    try {\n      const directory = await this.getDirectory();\n      const fileHandle = await directory.getFileHandle(key);\n      return await fileHandle.getFile();\n    } catch (error) {\n      if ((error as Error).name === \"NotFoundError\") {\n        return null;\n      }\n      throw error;\n    }\n  }\n\n  async set(key: string, file: File): Promise<void> {\n    const directory = await this.getDirectory();\n    const fileHandle = await directory.getFileHandle(key, { create: true });\n    const writable = await fileHandle.createWritable();\n\n    await writable.write(file);\n    await writable.close();\n  }\n\n  async remove(key: string): Promise<void> {\n    try {\n      const directory = await this.getDirectory();\n      await directory.removeEntry(key);\n    } catch (error) {\n      if ((error as Error).name !== \"NotFoundError\") {\n        throw error;\n      }\n    }\n  }\n\n  async list(): Promise<string[]> {\n    const directory = await this.getDirectory();\n    const keys: string[] = [];\n\n    for await (const name of directory.keys()) {\n      keys.push(name);\n    }\n\n    return keys;\n  }\n\n  async clear(): Promise<void> {\n    const directory = await this.getDirectory();\n\n    for await (const name of directory.keys()) {\n      await directory.removeEntry(name);\n    }\n  }\n\n  // Helper method to check OPFS support\n  static isSupported(): boolean {\n    return \"storage\" in navigator && \"getDirectory\" in navigator.storage;\n  }\n}\n"],"names":[],"mappings":";;;AAEO,MAAM;IACH,cAAsB;IAE9B,YAAY,gBAAgB,OAAO,CAAE;QACnC,IAAI,CAAC,aAAa,GAAG;IACvB;IAEA,MAAc,eAAmD;QAC/D,MAAM,WAAW,MAAM,UAAU,OAAO,CAAC,YAAY;QACrD,OAAO,MAAM,SAAS,kBAAkB,CAAC,IAAI,CAAC,aAAa,EAAE;YAC3D,QAAQ;QACV;IACF;IAEA,MAAM,IAAI,GAAW,EAAwB;QAC3C,IAAI;YACF,MAAM,YAAY,MAAM,IAAI,CAAC,YAAY;YACzC,MAAM,aAAa,MAAM,UAAU,aAAa,CAAC;YACjD,OAAO,MAAM,WAAW,OAAO;QACjC,EAAE,OAAO,OAAO;YACd,IAAI,AAAC,MAAgB,IAAI,KAAK,iBAAiB;gBAC7C,OAAO;YACT;YACA,MAAM;QACR;IACF;IAEA,MAAM,IAAI,GAAW,EAAE,IAAU,EAAiB;QAChD,MAAM,YAAY,MAAM,IAAI,CAAC,YAAY;QACzC,MAAM,aAAa,MAAM,UAAU,aAAa,CAAC,KAAK;YAAE,QAAQ;QAAK;QACrE,MAAM,WAAW,MAAM,WAAW,cAAc;QAEhD,MAAM,SAAS,KAAK,CAAC;QACrB,MAAM,SAAS,KAAK;IACtB;IAEA,MAAM,OAAO,GAAW,EAAiB;QACvC,IAAI;YACF,MAAM,YAAY,MAAM,IAAI,CAAC,YAAY;YACzC,MAAM,UAAU,WAAW,CAAC;QAC9B,EAAE,OAAO,OAAO;YACd,IAAI,AAAC,MAAgB,IAAI,KAAK,iBAAiB;gBAC7C,MAAM;YACR;QACF;IACF;IAEA,MAAM,OAA0B;QAC9B,MAAM,YAAY,MAAM,IAAI,CAAC,YAAY;QACzC,MAAM,OAAiB,EAAE;QAEzB,WAAW,MAAM,QAAQ,UAAU,IAAI,GAAI;YACzC,KAAK,IAAI,CAAC;QACZ;QAEA,OAAO;IACT;IAEA,MAAM,QAAuB;QAC3B,MAAM,YAAY,MAAM,IAAI,CAAC,YAAY;QAEzC,WAAW,MAAM,QAAQ,UAAU,IAAI,GAAI;YACzC,MAAM,UAAU,WAAW,CAAC;QAC9B;IACF;IAEA,sCAAsC;IACtC,OAAO,cAAuB;QAC5B,OAAO,aAAa,aAAa,kBAAkB,UAAU,OAAO;IACtE;AACF","debugId":null}},
    {"offset": {"line": 215, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/storage/storage-service.ts"],"sourcesContent":["import { TProject } from \"@/types/project\";\nimport { MediaFile } from \"@/types/media\";\nimport { IndexedDBAdapter } from \"./indexeddb-adapter\";\nimport { OPFSAdapter } from \"./opfs-adapter\";\nimport {\n  MediaFileData,\n  StorageConfig,\n  SerializedProject,\n  SerializedScene,\n  TimelineData,\n} from \"./types\";\nimport { TimelineTrack } from \"@/types/timeline\";\nimport { SavedSoundsData, SavedSound, SoundEffect } from \"@/types/sounds\";\n\nclass StorageService {\n  private projectsAdapter: IndexedDBAdapter<SerializedProject>;\n  private savedSoundsAdapter: IndexedDBAdapter<SavedSoundsData>;\n  private config: StorageConfig;\n\n  constructor() {\n    this.config = {\n      projectsDb: \"video-editor-projects\",\n      mediaDb: \"video-editor-media\",\n      timelineDb: \"video-editor-timelines\",\n      savedSoundsDb: \"video-editor-saved-sounds\",\n      version: 1,\n    };\n\n    this.projectsAdapter = new IndexedDBAdapter<SerializedProject>(\n      this.config.projectsDb,\n      \"projects\",\n      this.config.version\n    );\n\n    this.savedSoundsAdapter = new IndexedDBAdapter<SavedSoundsData>(\n      this.config.savedSoundsDb,\n      \"saved-sounds\",\n      this.config.version\n    );\n  }\n\n  // Helper to get project-specific media adapters\n  private getProjectMediaAdapters({ projectId }: { projectId: string }) {\n    const mediaMetadataAdapter = new IndexedDBAdapter<MediaFileData>(\n      `${this.config.mediaDb}-${projectId}`,\n      \"media-metadata\",\n      this.config.version\n    );\n\n    const mediaFilesAdapter = new OPFSAdapter(`media-files-${projectId}`);\n\n    return { mediaMetadataAdapter, mediaFilesAdapter };\n  }\n\n  // Helper to get project-specific timeline adapter\n  private getProjectTimelineAdapter({\n    projectId,\n    sceneId,\n  }: {\n    projectId: string;\n    sceneId?: string;\n  }) {\n    const dbName = sceneId\n      ? `${this.config.timelineDb}-${projectId}-${sceneId}`\n      : `${this.config.timelineDb}-${projectId}`;\n\n    return new IndexedDBAdapter<TimelineData>(\n      dbName,\n      \"timeline\",\n      this.config.version\n    );\n  }\n\n  // Project operations\n  async saveProject({ project }: { project: TProject }): Promise<void> {\n    // Convert TProject to serializable format\n    const serializedScenes: SerializedScene[] = project.scenes.map((scene) => ({\n      id: scene.id,\n      name: scene.name,\n      isMain: scene.isMain,\n      createdAt: scene.createdAt.toISOString(),\n      updatedAt: scene.updatedAt.toISOString(),\n    }));\n\n    const serializedProject: SerializedProject = {\n      id: project.id,\n      name: project.name,\n      thumbnail: project.thumbnail,\n      createdAt: project.createdAt.toISOString(),\n      updatedAt: project.updatedAt.toISOString(),\n      scenes: serializedScenes,\n      currentSceneId: project.currentSceneId,\n      backgroundColor: project.backgroundColor,\n      backgroundType: project.backgroundType,\n      blurIntensity: project.blurIntensity,\n      bookmarks: project.bookmarks,\n      fps: project.fps,\n      canvasSize: project.canvasSize,\n      canvasMode: project.canvasMode,\n    };\n\n    await this.projectsAdapter.set(project.id, serializedProject);\n  }\n\n  async loadProject({ id }: { id: string }): Promise<TProject | null> {\n    const serializedProject = await this.projectsAdapter.get(id);\n\n    if (!serializedProject) return null;\n\n    // Now convert serialized scenes back to Scene objects\n    const scenes =\n      serializedProject.scenes?.map((scene) => ({\n        id: scene.id,\n        name: scene.name,\n        isMain: scene.isMain,\n        createdAt: new Date(scene.createdAt),\n        updatedAt: new Date(scene.updatedAt),\n      })) || [];\n\n    // Convert back to TProject format\n    const project = {\n      id: serializedProject.id,\n      name: serializedProject.name,\n      thumbnail: serializedProject.thumbnail,\n      createdAt: new Date(serializedProject.createdAt),\n      updatedAt: new Date(serializedProject.updatedAt),\n      scenes,\n      currentSceneId: serializedProject.currentSceneId || \"\",\n      backgroundColor: serializedProject.backgroundColor,\n      backgroundType: serializedProject.backgroundType,\n      blurIntensity: serializedProject.blurIntensity,\n      bookmarks: serializedProject.bookmarks,\n      fps: serializedProject.fps,\n      canvasSize: serializedProject.canvasSize,\n      canvasMode: serializedProject.canvasMode,\n    };\n    return project;\n  }\n\n  async loadAllProjects(): Promise<TProject[]> {\n    const projectIds = await this.projectsAdapter.list();\n    const projects: TProject[] = [];\n\n    for (const id of projectIds) {\n      const project = await this.loadProject({ id });\n      if (project) {\n        projects.push(project);\n      }\n    }\n\n    // Sort by last updated (most recent first)\n    return projects.sort(\n      (a, b) => b.updatedAt.getTime() - a.updatedAt.getTime()\n    );\n  }\n\n  async deleteProject({ id }: { id: string }): Promise<void> {\n    await this.projectsAdapter.remove(id);\n  }\n\n  // Media operations\n  async saveMediaFile({\n    projectId,\n    mediaItem,\n  }: {\n    projectId: string;\n    mediaItem: MediaFile;\n  }): Promise<void> {\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\n      this.getProjectMediaAdapters({ projectId });\n\n    // Save file to project-specific OPFS\n    await mediaFilesAdapter.set(mediaItem.id, mediaItem.file);\n\n    // Save metadata to project-specific IndexedDB\n    const metadata: MediaFileData = {\n      id: mediaItem.id,\n      name: mediaItem.name,\n      type: mediaItem.type,\n      size: mediaItem.file.size,\n      lastModified: mediaItem.file.lastModified,\n      width: mediaItem.width,\n      height: mediaItem.height,\n      duration: mediaItem.duration,\n      ephemeral: mediaItem.ephemeral,\n    };\n\n    await mediaMetadataAdapter.set(mediaItem.id, metadata);\n  }\n\n  async loadMediaFile({\n    projectId,\n    id,\n  }: {\n    projectId: string;\n    id: string;\n  }): Promise<MediaFile | null> {\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\n      this.getProjectMediaAdapters({ projectId });\n\n    const [file, metadata] = await Promise.all([\n      mediaFilesAdapter.get(id),\n      mediaMetadataAdapter.get(id),\n    ]);\n\n    if (!file || !metadata) return null;\n\n    let url: string;\n    if (metadata.type === \"image\" && (!file.type || file.type === \"\")) {\n      try {\n        const text = await file.text();\n        if (text.trim().startsWith(\"<svg\")) {\n          const svgBlob = new Blob([text], { type: \"image/svg+xml\" });\n          url = URL.createObjectURL(svgBlob);\n        } else {\n          url = URL.createObjectURL(file);\n        }\n      } catch {\n        url = URL.createObjectURL(file);\n      }\n    } else {\n      url = URL.createObjectURL(file);\n    }\n\n    return {\n      id: metadata.id,\n      name: metadata.name,\n      type: metadata.type,\n      file,\n      url,\n      width: metadata.width,\n      height: metadata.height,\n      duration: metadata.duration,\n      ephemeral: metadata.ephemeral,\n    };\n  }\n\n  async loadAllMediaFiles({\n    projectId,\n  }: {\n    projectId: string;\n  }): Promise<MediaFile[]> {\n    const { mediaMetadataAdapter } = this.getProjectMediaAdapters({\n      projectId,\n    });\n\n    const mediaIds = await mediaMetadataAdapter.list();\n    const mediaItems: MediaFile[] = [];\n\n    for (const id of mediaIds) {\n      const item = await this.loadMediaFile({ projectId, id });\n      if (item) {\n        mediaItems.push(item);\n      }\n    }\n\n    return mediaItems;\n  }\n\n  async deleteMediaFile({\n    projectId,\n    id,\n  }: {\n    projectId: string;\n    id: string;\n  }): Promise<void> {\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\n      this.getProjectMediaAdapters({ projectId });\n\n    await Promise.all([\n      mediaFilesAdapter.remove(id),\n      mediaMetadataAdapter.remove(id),\n    ]);\n  }\n\n  async deleteProjectMedia({\n    projectId,\n  }: {\n    projectId: string;\n  }): Promise<void> {\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\n      this.getProjectMediaAdapters({ projectId });\n\n    await Promise.all([\n      mediaMetadataAdapter.clear(),\n      mediaFilesAdapter.clear(),\n    ]);\n  }\n\n  // Timeline operations - supports both legacy and scene-based storage\n  async saveTimeline({\n    projectId,\n    tracks,\n    sceneId,\n  }: {\n    projectId: string;\n    tracks: TimelineTrack[];\n    sceneId?: string;\n  }): Promise<void> {\n    const timelineAdapter = this.getProjectTimelineAdapter({\n      projectId,\n      sceneId,\n    });\n    const timelineData: TimelineData = {\n      tracks,\n      lastModified: new Date().toISOString(),\n    };\n    await timelineAdapter.set(\"timeline\", timelineData);\n  }\n\n  async loadTimeline({\n    projectId,\n    sceneId,\n  }: {\n    projectId: string;\n    sceneId?: string;\n  }): Promise<TimelineTrack[] | null> {\n    const timelineAdapter = this.getProjectTimelineAdapter({\n      projectId,\n      sceneId,\n    });\n    const timelineData = await timelineAdapter.get(\"timeline\");\n    return timelineData ? timelineData.tracks : null;\n  }\n\n  async deleteProjectTimeline({\n    projectId,\n  }: {\n    projectId: string;\n  }): Promise<void> {\n    const timelineAdapter = this.getProjectTimelineAdapter({ projectId });\n    await timelineAdapter.remove(\"timeline\");\n  }\n\n  // Utility methods\n  async clearAllData(): Promise<void> {\n    // Clear all projects\n    await this.projectsAdapter.clear();\n\n    // Note: Project-specific media and timelines will be cleaned up when projects are deleted\n  }\n\n  async getStorageInfo(): Promise<{\n    projects: number;\n    isOPFSSupported: boolean;\n    isIndexedDBSupported: boolean;\n  }> {\n    const projectIds = await this.projectsAdapter.list();\n\n    return {\n      projects: projectIds.length,\n      isOPFSSupported: this.isOPFSSupported(),\n      isIndexedDBSupported: this.isIndexedDBSupported(),\n    };\n  }\n\n  async getProjectStorageInfo({ projectId }: { projectId: string }): Promise<{\n    mediaItems: number;\n    hasTimeline: boolean;\n  }> {\n    const { mediaMetadataAdapter } = this.getProjectMediaAdapters({\n      projectId,\n    });\n    const timelineAdapter = this.getProjectTimelineAdapter({ projectId });\n\n    const [mediaIds, timelineData] = await Promise.all([\n      mediaMetadataAdapter.list(),\n      timelineAdapter.get(\"timeline\"),\n    ]);\n\n    return {\n      mediaItems: mediaIds.length,\n      hasTimeline: !!timelineData,\n    };\n  }\n\n  async loadSavedSounds(): Promise<SavedSoundsData> {\n    try {\n      const savedSoundsData = await this.savedSoundsAdapter.get(\"user-sounds\");\n      return (\n        savedSoundsData || {\n          sounds: [],\n          lastModified: new Date().toISOString(),\n        }\n      );\n    } catch (error) {\n      console.error(\"Failed to load saved sounds:\", error);\n      return { sounds: [], lastModified: new Date().toISOString() };\n    }\n  }\n\n  async saveSoundEffect({\n    soundEffect,\n  }: {\n    soundEffect: SoundEffect;\n  }): Promise<void> {\n    try {\n      const currentData = await this.loadSavedSounds();\n\n      // Check if sound is already saved\n      if (currentData.sounds.some((sound) => sound.id === soundEffect.id)) {\n        return; // Already saved\n      }\n\n      const savedSound: SavedSound = {\n        id: soundEffect.id,\n        name: soundEffect.name,\n        username: soundEffect.username,\n        previewUrl: soundEffect.previewUrl,\n        downloadUrl: soundEffect.downloadUrl,\n        duration: soundEffect.duration,\n        tags: soundEffect.tags,\n        license: soundEffect.license,\n        savedAt: new Date().toISOString(),\n      };\n\n      const updatedData: SavedSoundsData = {\n        sounds: [...currentData.sounds, savedSound],\n        lastModified: new Date().toISOString(),\n      };\n\n      await this.savedSoundsAdapter.set(\"user-sounds\", updatedData);\n    } catch (error) {\n      console.error(\"Failed to save sound effect:\", error);\n      throw error;\n    }\n  }\n\n  async removeSavedSound({ soundId }: { soundId: number }): Promise<void> {\n    try {\n      const currentData = await this.loadSavedSounds();\n\n      const updatedData: SavedSoundsData = {\n        sounds: currentData.sounds.filter((sound) => sound.id !== soundId),\n        lastModified: new Date().toISOString(),\n      };\n\n      await this.savedSoundsAdapter.set(\"user-sounds\", updatedData);\n    } catch (error) {\n      console.error(\"Failed to remove saved sound:\", error);\n      throw error;\n    }\n  }\n\n  async isSoundSaved({ soundId }: { soundId: number }): Promise<boolean> {\n    try {\n      const currentData = await this.loadSavedSounds();\n      return currentData.sounds.some((sound) => sound.id === soundId);\n    } catch (error) {\n      console.error(\"Failed to check if sound is saved:\", error);\n      return false;\n    }\n  }\n\n  async clearSavedSounds(): Promise<void> {\n    try {\n      await this.savedSoundsAdapter.remove(\"user-sounds\");\n    } catch (error) {\n      console.error(\"Failed to clear saved sounds:\", error);\n      throw error;\n    }\n  }\n\n  // Check browser support\n  isOPFSSupported(): boolean {\n    return OPFSAdapter.isSupported();\n  }\n\n  isIndexedDBSupported(): boolean {\n    return \"indexedDB\" in window;\n  }\n\n  isFullySupported(): boolean {\n    return this.isIndexedDBSupported() && this.isOPFSSupported();\n  }\n}\n\n// Export singleton instance\nexport const storageService = new StorageService();\nexport { StorageService };\n"],"names":[],"mappings":";;;;AAEA;AACA;;;AAWA,MAAM;IACI,gBAAqD;IACrD,mBAAsD;IACtD,OAAsB;IAE9B,aAAc;QACZ,IAAI,CAAC,MAAM,GAAG;YACZ,YAAY;YACZ,SAAS;YACT,YAAY;YACZ,eAAe;YACf,SAAS;QACX;QAEA,IAAI,CAAC,eAAe,GAAG,IAAI,4JAAA,CAAA,mBAAgB,CACzC,IAAI,CAAC,MAAM,CAAC,UAAU,EACtB,YACA,IAAI,CAAC,MAAM,CAAC,OAAO;QAGrB,IAAI,CAAC,kBAAkB,GAAG,IAAI,4JAAA,CAAA,mBAAgB,CAC5C,IAAI,CAAC,MAAM,CAAC,aAAa,EACzB,gBACA,IAAI,CAAC,MAAM,CAAC,OAAO;IAEvB;IAEA,gDAAgD;IACxC,wBAAwB,EAAE,SAAS,EAAyB,EAAE;QACpE,MAAM,uBAAuB,IAAI,4JAAA,CAAA,mBAAgB,CAC/C,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,WAAW,EACrC,kBACA,IAAI,CAAC,MAAM,CAAC,OAAO;QAGrB,MAAM,oBAAoB,IAAI,uJAAA,CAAA,cAAW,CAAC,CAAC,YAAY,EAAE,WAAW;QAEpE,OAAO;YAAE;YAAsB;QAAkB;IACnD;IAEA,kDAAkD;IAC1C,0BAA0B,EAChC,SAAS,EACT,OAAO,EAIR,EAAE;QACD,MAAM,SAAS,UACX,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE,SAAS,GACnD,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,EAAE,WAAW;QAE5C,OAAO,IAAI,4JAAA,CAAA,mBAAgB,CACzB,QACA,YACA,IAAI,CAAC,MAAM,CAAC,OAAO;IAEvB;IAEA,qBAAqB;IACrB,MAAM,YAAY,EAAE,OAAO,EAAyB,EAAiB;QACnE,0CAA0C;QAC1C,MAAM,mBAAsC,QAAQ,MAAM,CAAC,GAAG,CAAC,CAAC,QAAU,CAAC;gBACzE,IAAI,MAAM,EAAE;gBACZ,MAAM,MAAM,IAAI;gBAChB,QAAQ,MAAM,MAAM;gBACpB,WAAW,MAAM,SAAS,CAAC,WAAW;gBACtC,WAAW,MAAM,SAAS,CAAC,WAAW;YACxC,CAAC;QAED,MAAM,oBAAuC;YAC3C,IAAI,QAAQ,EAAE;YACd,MAAM,QAAQ,IAAI;YAClB,WAAW,QAAQ,SAAS;YAC5B,WAAW,QAAQ,SAAS,CAAC,WAAW;YACxC,WAAW,QAAQ,SAAS,CAAC,WAAW;YACxC,QAAQ;YACR,gBAAgB,QAAQ,cAAc;YACtC,iBAAiB,QAAQ,eAAe;YACxC,gBAAgB,QAAQ,cAAc;YACtC,eAAe,QAAQ,aAAa;YACpC,WAAW,QAAQ,SAAS;YAC5B,KAAK,QAAQ,GAAG;YAChB,YAAY,QAAQ,UAAU;YAC9B,YAAY,QAAQ,UAAU;QAChC;QAEA,MAAM,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE;IAC7C;IAEA,MAAM,YAAY,EAAE,EAAE,EAAkB,EAA4B;QAClE,MAAM,oBAAoB,MAAM,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC;QAEzD,IAAI,CAAC,mBAAmB,OAAO;QAE/B,sDAAsD;QACtD,MAAM,SACJ,kBAAkB,MAAM,EAAE,IAAI,CAAC,QAAU,CAAC;gBACxC,IAAI,MAAM,EAAE;gBACZ,MAAM,MAAM,IAAI;gBAChB,QAAQ,MAAM,MAAM;gBACpB,WAAW,IAAI,KAAK,MAAM,SAAS;gBACnC,WAAW,IAAI,KAAK,MAAM,SAAS;YACrC,CAAC,MAAM,EAAE;QAEX,kCAAkC;QAClC,MAAM,UAAU;YACd,IAAI,kBAAkB,EAAE;YACxB,MAAM,kBAAkB,IAAI;YAC5B,WAAW,kBAAkB,SAAS;YACtC,WAAW,IAAI,KAAK,kBAAkB,SAAS;YAC/C,WAAW,IAAI,KAAK,kBAAkB,SAAS;YAC/C;YACA,gBAAgB,kBAAkB,cAAc,IAAI;YACpD,iBAAiB,kBAAkB,eAAe;YAClD,gBAAgB,kBAAkB,cAAc;YAChD,eAAe,kBAAkB,aAAa;YAC9C,WAAW,kBAAkB,SAAS;YACtC,KAAK,kBAAkB,GAAG;YAC1B,YAAY,kBAAkB,UAAU;YACxC,YAAY,kBAAkB,UAAU;QAC1C;QACA,OAAO;IACT;IAEA,MAAM,kBAAuC;QAC3C,MAAM,aAAa,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI;QAClD,MAAM,WAAuB,EAAE;QAE/B,KAAK,MAAM,MAAM,WAAY;YAC3B,MAAM,UAAU,MAAM,IAAI,CAAC,WAAW,CAAC;gBAAE;YAAG;YAC5C,IAAI,SAAS;gBACX,SAAS,IAAI,CAAC;YAChB;QACF;QAEA,2CAA2C;QAC3C,OAAO,SAAS,IAAI,CAClB,CAAC,GAAG,IAAM,EAAE,SAAS,CAAC,OAAO,KAAK,EAAE,SAAS,CAAC,OAAO;IAEzD;IAEA,MAAM,cAAc,EAAE,EAAE,EAAkB,EAAiB;QACzD,MAAM,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC;IACpC;IAEA,mBAAmB;IACnB,MAAM,cAAc,EAClB,SAAS,EACT,SAAS,EAIV,EAAiB;QAChB,MAAM,EAAE,oBAAoB,EAAE,iBAAiB,EAAE,GAC/C,IAAI,CAAC,uBAAuB,CAAC;YAAE;QAAU;QAE3C,qCAAqC;QACrC,MAAM,kBAAkB,GAAG,CAAC,UAAU,EAAE,EAAE,UAAU,IAAI;QAExD,8CAA8C;QAC9C,MAAM,WAA0B;YAC9B,IAAI,UAAU,EAAE;YAChB,MAAM,UAAU,IAAI;YACpB,MAAM,UAAU,IAAI;YACpB,MAAM,UAAU,IAAI,CAAC,IAAI;YACzB,cAAc,UAAU,IAAI,CAAC,YAAY;YACzC,OAAO,UAAU,KAAK;YACtB,QAAQ,UAAU,MAAM;YACxB,UAAU,UAAU,QAAQ;YAC5B,WAAW,UAAU,SAAS;QAChC;QAEA,MAAM,qBAAqB,GAAG,CAAC,UAAU,EAAE,EAAE;IAC/C;IAEA,MAAM,cAAc,EAClB,SAAS,EACT,EAAE,EAIH,EAA6B;QAC5B,MAAM,EAAE,oBAAoB,EAAE,iBAAiB,EAAE,GAC/C,IAAI,CAAC,uBAAuB,CAAC;YAAE;QAAU;QAE3C,MAAM,CAAC,MAAM,SAAS,GAAG,MAAM,QAAQ,GAAG,CAAC;YACzC,kBAAkB,GAAG,CAAC;YACtB,qBAAqB,GAAG,CAAC;SAC1B;QAED,IAAI,CAAC,QAAQ,CAAC,UAAU,OAAO;QAE/B,IAAI;QACJ,IAAI,SAAS,IAAI,KAAK,WAAW,CAAC,CAAC,KAAK,IAAI,IAAI,KAAK,IAAI,KAAK,EAAE,GAAG;YACjE,IAAI;gBACF,MAAM,OAAO,MAAM,KAAK,IAAI;gBAC5B,IAAI,KAAK,IAAI,GAAG,UAAU,CAAC,SAAS;oBAClC,MAAM,UAAU,IAAI,KAAK;wBAAC;qBAAK,EAAE;wBAAE,MAAM;oBAAgB;oBACzD,MAAM,IAAI,eAAe,CAAC;gBAC5B,OAAO;oBACL,MAAM,IAAI,eAAe,CAAC;gBAC5B;YACF,EAAE,OAAM;gBACN,MAAM,IAAI,eAAe,CAAC;YAC5B;QACF,OAAO;YACL,MAAM,IAAI,eAAe,CAAC;QAC5B;QAEA,OAAO;YACL,IAAI,SAAS,EAAE;YACf,MAAM,SAAS,IAAI;YACnB,MAAM,SAAS,IAAI;YACnB;YACA;YACA,OAAO,SAAS,KAAK;YACrB,QAAQ,SAAS,MAAM;YACvB,UAAU,SAAS,QAAQ;YAC3B,WAAW,SAAS,SAAS;QAC/B;IACF;IAEA,MAAM,kBAAkB,EACtB,SAAS,EAGV,EAAwB;QACvB,MAAM,EAAE,oBAAoB,EAAE,GAAG,IAAI,CAAC,uBAAuB,CAAC;YAC5D;QACF;QAEA,MAAM,WAAW,MAAM,qBAAqB,IAAI;QAChD,MAAM,aAA0B,EAAE;QAElC,KAAK,MAAM,MAAM,SAAU;YACzB,MAAM,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC;gBAAE;gBAAW;YAAG;YACtD,IAAI,MAAM;gBACR,WAAW,IAAI,CAAC;YAClB;QACF;QAEA,OAAO;IACT;IAEA,MAAM,gBAAgB,EACpB,SAAS,EACT,EAAE,EAIH,EAAiB;QAChB,MAAM,EAAE,oBAAoB,EAAE,iBAAiB,EAAE,GAC/C,IAAI,CAAC,uBAAuB,CAAC;YAAE;QAAU;QAE3C,MAAM,QAAQ,GAAG,CAAC;YAChB,kBAAkB,MAAM,CAAC;YACzB,qBAAqB,MAAM,CAAC;SAC7B;IACH;IAEA,MAAM,mBAAmB,EACvB,SAAS,EAGV,EAAiB;QAChB,MAAM,EAAE,oBAAoB,EAAE,iBAAiB,EAAE,GAC/C,IAAI,CAAC,uBAAuB,CAAC;YAAE;QAAU;QAE3C,MAAM,QAAQ,GAAG,CAAC;YAChB,qBAAqB,KAAK;YAC1B,kBAAkB,KAAK;SACxB;IACH;IAEA,qEAAqE;IACrE,MAAM,aAAa,EACjB,SAAS,EACT,MAAM,EACN,OAAO,EAKR,EAAiB;QAChB,MAAM,kBAAkB,IAAI,CAAC,yBAAyB,CAAC;YACrD;YACA;QACF;QACA,MAAM,eAA6B;YACjC;YACA,cAAc,IAAI,OAAO,WAAW;QACtC;QACA,MAAM,gBAAgB,GAAG,CAAC,YAAY;IACxC;IAEA,MAAM,aAAa,EACjB,SAAS,EACT,OAAO,EAIR,EAAmC;QAClC,MAAM,kBAAkB,IAAI,CAAC,yBAAyB,CAAC;YACrD;YACA;QACF;QACA,MAAM,eAAe,MAAM,gBAAgB,GAAG,CAAC;QAC/C,OAAO,eAAe,aAAa,MAAM,GAAG;IAC9C;IAEA,MAAM,sBAAsB,EAC1B,SAAS,EAGV,EAAiB;QAChB,MAAM,kBAAkB,IAAI,CAAC,yBAAyB,CAAC;YAAE;QAAU;QACnE,MAAM,gBAAgB,MAAM,CAAC;IAC/B;IAEA,kBAAkB;IAClB,MAAM,eAA8B;QAClC,qBAAqB;QACrB,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK;IAEhC,0FAA0F;IAC5F;IAEA,MAAM,iBAIH;QACD,MAAM,aAAa,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI;QAElD,OAAO;YACL,UAAU,WAAW,MAAM;YAC3B,iBAAiB,IAAI,CAAC,eAAe;YACrC,sBAAsB,IAAI,CAAC,oBAAoB;QACjD;IACF;IAEA,MAAM,sBAAsB,EAAE,SAAS,EAAyB,EAG7D;QACD,MAAM,EAAE,oBAAoB,EAAE,GAAG,IAAI,CAAC,uBAAuB,CAAC;YAC5D;QACF;QACA,MAAM,kBAAkB,IAAI,CAAC,yBAAyB,CAAC;YAAE;QAAU;QAEnE,MAAM,CAAC,UAAU,aAAa,GAAG,MAAM,QAAQ,GAAG,CAAC;YACjD,qBAAqB,IAAI;YACzB,gBAAgB,GAAG,CAAC;SACrB;QAED,OAAO;YACL,YAAY,SAAS,MAAM;YAC3B,aAAa,CAAC,CAAC;QACjB;IACF;IAEA,MAAM,kBAA4C;QAChD,IAAI;YACF,MAAM,kBAAkB,MAAM,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC;YAC1D,OACE,mBAAmB;gBACjB,QAAQ,EAAE;gBACV,cAAc,IAAI,OAAO,WAAW;YACtC;QAEJ,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,OAAO;gBAAE,QAAQ,EAAE;gBAAE,cAAc,IAAI,OAAO,WAAW;YAAG;QAC9D;IACF;IAEA,MAAM,gBAAgB,EACpB,WAAW,EAGZ,EAAiB;QAChB,IAAI;YACF,MAAM,cAAc,MAAM,IAAI,CAAC,eAAe;YAE9C,kCAAkC;YAClC,IAAI,YAAY,MAAM,CAAC,IAAI,CAAC,CAAC,QAAU,MAAM,EAAE,KAAK,YAAY,EAAE,GAAG;gBACnE,QAAQ,gBAAgB;YAC1B;YAEA,MAAM,aAAyB;gBAC7B,IAAI,YAAY,EAAE;gBAClB,MAAM,YAAY,IAAI;gBACtB,UAAU,YAAY,QAAQ;gBAC9B,YAAY,YAAY,UAAU;gBAClC,aAAa,YAAY,WAAW;gBACpC,UAAU,YAAY,QAAQ;gBAC9B,MAAM,YAAY,IAAI;gBACtB,SAAS,YAAY,OAAO;gBAC5B,SAAS,IAAI,OAAO,WAAW;YACjC;YAEA,MAAM,cAA+B;gBACnC,QAAQ;uBAAI,YAAY,MAAM;oBAAE;iBAAW;gBAC3C,cAAc,IAAI,OAAO,WAAW;YACtC;YAEA,MAAM,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,eAAe;QACnD,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,MAAM;QACR;IACF;IAEA,MAAM,iBAAiB,EAAE,OAAO,EAAuB,EAAiB;QACtE,IAAI;YACF,MAAM,cAAc,MAAM,IAAI,CAAC,eAAe;YAE9C,MAAM,cAA+B;gBACnC,QAAQ,YAAY,MAAM,CAAC,MAAM,CAAC,CAAC,QAAU,MAAM,EAAE,KAAK;gBAC1D,cAAc,IAAI,OAAO,WAAW;YACtC;YAEA,MAAM,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,eAAe;QACnD,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,MAAM;QACR;IACF;IAEA,MAAM,aAAa,EAAE,OAAO,EAAuB,EAAoB;QACrE,IAAI;YACF,MAAM,cAAc,MAAM,IAAI,CAAC,eAAe;YAC9C,OAAO,YAAY,MAAM,CAAC,IAAI,CAAC,CAAC,QAAU,MAAM,EAAE,KAAK;QACzD,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,sCAAsC;YACpD,OAAO;QACT;IACF;IAEA,MAAM,mBAAkC;QACtC,IAAI;YACF,MAAM,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC;QACvC,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,iCAAiC;YAC/C,MAAM;QACR;IACF;IAEA,wBAAwB;IACxB,kBAA2B;QACzB,OAAO,uJAAA,CAAA,cAAW,CAAC,WAAW;IAChC;IAEA,uBAAgC;QAC9B,OAAO,eAAe;IACxB;IAEA,mBAA4B;QAC1B,OAAO,IAAI,CAAC,oBAAoB,MAAM,IAAI,CAAC,eAAe;IAC5D;AACF;AAGO,MAAM,iBAAiB,IAAI","debugId":null}},
    {"offset": {"line": 573, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/utils.ts"],"sourcesContent":["// Generic utilities\n\nimport { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function uppercase(str: string) {\n  return str.toUpperCase();\n}\n\n/**\n * Generates a UUID v4 string\n * Uses crypto.randomUUID() if available, otherwise falls back to a custom implementation\n */\nexport function generateUUID(): string {\n  // Use the native crypto.randomUUID if available\n  if (\n    typeof crypto !== \"undefined\" &&\n    typeof crypto.randomUUID === \"function\"\n  ) {\n    return crypto.randomUUID();\n  }\n\n  // Secure fallback using crypto.getRandomValues\n  const bytes = new Uint8Array(16);\n  crypto.getRandomValues(bytes);\n\n  // Set version 4 (UUIDv4)\n  bytes[6] = (bytes[6] & 0x0f) | 0x40;\n  // Set variant 10xxxxxx\n  bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n  const hex = [...bytes].map((b) => b.toString(16).padStart(2, \"0\"));\n\n  return (\n    hex.slice(0, 4).join(\"\") +\n    \"-\" +\n    hex.slice(4, 6).join(\"\") +\n    \"-\" +\n    hex.slice(6, 8).join(\"\") +\n    \"-\" +\n    hex.slice(8, 10).join(\"\") +\n    \"-\" +\n    hex.slice(10, 16).join(\"\")\n  );\n}\n\nexport function isDOMElement(el: any): el is HTMLElement {\n  return !!el && (el instanceof Element || el instanceof HTMLElement);\n}\n\nexport function isTypableElement(el: HTMLElement): boolean {\n  // If content editable, then it is editable\n  if (el.isContentEditable) return true;\n\n  // If element is an input and the input is enabled, then it is typable\n  if (el.tagName === \"INPUT\") {\n    return !(el as HTMLInputElement).disabled;\n  }\n  // If element is a textarea and the input is enabled, then it is typable\n  if (el.tagName === \"TEXTAREA\") {\n    return !(el as HTMLTextAreaElement).disabled;\n  }\n\n  return false;\n}\nexport function isAppleDevice() {\n  return /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n}\n\nexport function getPlatformSpecialKey() {\n  return isAppleDevice() ? \"⌘\" : \"Ctrl\";\n}\n\nexport function getPlatformAlternateKey() {\n  return isAppleDevice() ? \"⌥\" : \"Alt\";\n}\n"],"names":[],"mappings":"AAAA,oBAAoB;;;;;;;;;;;AAEpB;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,CAAA,GAAA,wNAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD,EAAE;AACtB;AAEO,SAAS,UAAU,GAAW;IACnC,OAAO,IAAI,WAAW;AACxB;AAMO,SAAS;IACd,gDAAgD;IAChD,IACE,OAAO,WAAW,eAClB,OAAO,OAAO,UAAU,KAAK,YAC7B;QACA,OAAO,OAAO,UAAU;IAC1B;IAEA,+CAA+C;IAC/C,MAAM,QAAQ,IAAI,WAAW;IAC7B,OAAO,eAAe,CAAC;IAEvB,yBAAyB;IACzB,KAAK,CAAC,EAAE,GAAG,AAAC,KAAK,CAAC,EAAE,GAAG,OAAQ;IAC/B,uBAAuB;IACvB,KAAK,CAAC,EAAE,GAAG,AAAC,KAAK,CAAC,EAAE,GAAG,OAAQ;IAE/B,MAAM,MAAM;WAAI;KAAM,CAAC,GAAG,CAAC,CAAC,IAAM,EAAE,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG;IAE7D,OACE,IAAI,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,MACrB,MACA,IAAI,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,MACrB,MACA,IAAI,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,MACrB,MACA,IAAI,KAAK,CAAC,GAAG,IAAI,IAAI,CAAC,MACtB,MACA,IAAI,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC;AAE3B;AAEO,SAAS,aAAa,EAAO;IAClC,OAAO,CAAC,CAAC,MAAM,CAAC,cAAc,WAAW,cAAc,WAAW;AACpE;AAEO,SAAS,iBAAiB,EAAe;IAC9C,2CAA2C;IAC3C,IAAI,GAAG,iBAAiB,EAAE,OAAO;IAEjC,sEAAsE;IACtE,IAAI,GAAG,OAAO,KAAK,SAAS;QAC1B,OAAO,CAAC,AAAC,GAAwB,QAAQ;IAC3C;IACA,wEAAwE;IACxE,IAAI,GAAG,OAAO,KAAK,YAAY;QAC7B,OAAO,CAAC,AAAC,GAA2B,QAAQ;IAC9C;IAEA,OAAO;AACT;AACO,SAAS;IACd,OAAO,0BAA0B,IAAI,CAAC,UAAU,QAAQ;AAC1D;AAEO,SAAS;IACd,OAAO,kBAAkB,MAAM;AACjC;AAEO,SAAS;IACd,OAAO,kBAAkB,MAAM;AACjC","debugId":null}},
    {"offset": {"line": 640, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/types/timeline.ts"],"sourcesContent":["import { MediaType } from \"@/types/media\";\nimport { generateUUID } from \"@/lib/utils\";\n\nexport type TrackType = \"media\" | \"text\" | \"audio\";\n\n// Base element properties\ninterface BaseTimelineElement {\n  id: string;\n  name: string;\n  duration: number;\n  startTime: number;\n  trimStart: number;\n  trimEnd: number;\n  hidden?: boolean;\n}\n\n// Media element that references MediaStore\nexport interface MediaElement extends BaseTimelineElement {\n  type: \"media\";\n  mediaId: string;\n  muted?: boolean;\n}\n\n// Text element with embedded text data\nexport interface TextElement extends BaseTimelineElement {\n  type: \"text\";\n  content: string;\n  fontSize: number;\n  fontFamily: string;\n  color: string;\n  backgroundColor: string;\n  textAlign: \"left\" | \"center\" | \"right\";\n  fontWeight: \"normal\" | \"bold\";\n  fontStyle: \"normal\" | \"italic\";\n  textDecoration: \"none\" | \"underline\" | \"line-through\";\n  x: number; // Position relative to canvas center\n  y: number; // Position relative to canvas center\n  rotation: number; // in degrees\n  opacity: number; // 0-1\n}\n\n// Typed timeline elements\nexport type TimelineElement = MediaElement | TextElement;\n\n// Creation types (without id, for addElementToTrack)\nexport type CreateMediaElement = Omit<MediaElement, \"id\">;\nexport type CreateTextElement = Omit<TextElement, \"id\">;\nexport type CreateTimelineElement = CreateMediaElement | CreateTextElement;\n\nexport interface TimelineElementProps {\n  element: TimelineElement;\n  track: TimelineTrack;\n  zoomLevel: number;\n  isSelected: boolean;\n  onElementMouseDown: (e: React.MouseEvent, element: TimelineElement) => void;\n  onElementClick: (e: React.MouseEvent, element: TimelineElement) => void;\n}\n\nexport interface ResizeState {\n  elementId: string;\n  side: \"left\" | \"right\";\n  startX: number;\n  initialTrimStart: number;\n  initialTrimEnd: number;\n}\n\n// Drag data types for type-safe drag and drop\nexport interface MediaItemDragData {\n  id: string;\n  type: MediaType;\n  name: string;\n}\n\nexport interface TextItemDragData {\n  id: string;\n  type: \"text\";\n  name: string;\n  content: string;\n}\n\nexport type DragData = MediaItemDragData | TextItemDragData;\n\nexport interface TimelineTrack {\n  id: string;\n  name: string;\n  type: TrackType;\n  elements: TimelineElement[];\n  muted?: boolean;\n  isMain?: boolean;\n}\n\nexport function sortTracksByOrder(tracks: TimelineTrack[]): TimelineTrack[] {\n  return [...tracks].sort((a, b) => {\n    // Text tracks always go to the top\n    if (a.type === \"text\" && b.type !== \"text\") return -1;\n    if (b.type === \"text\" && a.type !== \"text\") return 1;\n\n    // Audio tracks always go to bottom\n    if (a.type === \"audio\" && b.type !== \"audio\") return 1;\n    if (b.type === \"audio\" && a.type !== \"audio\") return -1;\n\n    // Main track goes above audio but below text tracks\n    if (a.isMain && !b.isMain && b.type !== \"audio\" && b.type !== \"text\")\n      return 1;\n    if (b.isMain && !a.isMain && a.type !== \"audio\" && a.type !== \"text\")\n      return -1;\n\n    // Within same category, maintain creation order\n    return 0;\n  });\n}\n\nexport function getMainTrack(tracks: TimelineTrack[]): TimelineTrack | null {\n  return tracks.find((track) => track.isMain) || null;\n}\n\nexport function ensureMainTrack(tracks: TimelineTrack[]): TimelineTrack[] {\n  const hasMainTrack = tracks.some((track) => track.isMain);\n\n  if (!hasMainTrack) {\n    // Create main track if it doesn't exist\n    const mainTrack: TimelineTrack = {\n      id: generateUUID(),\n      name: \"Main Track\",\n      type: \"media\",\n      elements: [],\n      muted: false,\n      isMain: true,\n    };\n    return [mainTrack, ...tracks];\n  }\n\n  return tracks;\n}\n\n// Timeline validation utilities\nexport function canElementGoOnTrack(\n  elementType: \"text\" | \"media\",\n  trackType: TrackType\n): boolean {\n  if (elementType === \"text\") {\n    return trackType === \"text\";\n  }\n  if (elementType === \"media\") {\n    return trackType === \"media\" || trackType === \"audio\";\n  }\n  return false;\n}\n\nexport function validateElementTrackCompatibility(\n  element: { type: \"text\" | \"media\" },\n  track: { type: TrackType }\n): { isValid: boolean; errorMessage?: string } {\n  const isValid = canElementGoOnTrack(element.type, track.type);\n\n  if (!isValid) {\n    const errorMessage =\n      element.type === \"text\"\n        ? \"Text elements can only be placed on text tracks\"\n        : \"Media elements can only be placed on media or audio tracks\";\n\n    return { isValid: false, errorMessage };\n  }\n\n  return { isValid: true };\n}\n"],"names":[],"mappings":";;;;;;;AACA;;AA0FO,SAAS,kBAAkB,MAAuB;IACvD,OAAO;WAAI;KAAO,CAAC,IAAI,CAAC,CAAC,GAAG;QAC1B,mCAAmC;QACnC,IAAI,EAAE,IAAI,KAAK,UAAU,EAAE,IAAI,KAAK,QAAQ,OAAO,CAAC;QACpD,IAAI,EAAE,IAAI,KAAK,UAAU,EAAE,IAAI,KAAK,QAAQ,OAAO;QAEnD,mCAAmC;QACnC,IAAI,EAAE,IAAI,KAAK,WAAW,EAAE,IAAI,KAAK,SAAS,OAAO;QACrD,IAAI,EAAE,IAAI,KAAK,WAAW,EAAE,IAAI,KAAK,SAAS,OAAO,CAAC;QAEtD,oDAAoD;QACpD,IAAI,EAAE,MAAM,IAAI,CAAC,EAAE,MAAM,IAAI,EAAE,IAAI,KAAK,WAAW,EAAE,IAAI,KAAK,QAC5D,OAAO;QACT,IAAI,EAAE,MAAM,IAAI,CAAC,EAAE,MAAM,IAAI,EAAE,IAAI,KAAK,WAAW,EAAE,IAAI,KAAK,QAC5D,OAAO,CAAC;QAEV,gDAAgD;QAChD,OAAO;IACT;AACF;AAEO,SAAS,aAAa,MAAuB;IAClD,OAAO,OAAO,IAAI,CAAC,CAAC,QAAU,MAAM,MAAM,KAAK;AACjD;AAEO,SAAS,gBAAgB,MAAuB;IACrD,MAAM,eAAe,OAAO,IAAI,CAAC,CAAC,QAAU,MAAM,MAAM;IAExD,IAAI,CAAC,cAAc;QACjB,wCAAwC;QACxC,MAAM,YAA2B;YAC/B,IAAI,CAAA,GAAA,kIAAA,CAAA,eAAY,AAAD;YACf,MAAM;YACN,MAAM;YACN,UAAU,EAAE;YACZ,OAAO;YACP,QAAQ;QACV;QACA,OAAO;YAAC;eAAc;SAAO;IAC/B;IAEA,OAAO;AACT;AAGO,SAAS,oBACd,WAA6B,EAC7B,SAAoB;IAEpB,IAAI,gBAAgB,QAAQ;QAC1B,OAAO,cAAc;IACvB;IACA,IAAI,gBAAgB,SAAS;QAC3B,OAAO,cAAc,WAAW,cAAc;IAChD;IACA,OAAO;AACT;AAEO,SAAS,kCACd,OAAmC,EACnC,KAA0B;IAE1B,MAAM,UAAU,oBAAoB,QAAQ,IAAI,EAAE,MAAM,IAAI;IAE5D,IAAI,CAAC,SAAS;QACZ,MAAM,eACJ,QAAQ,IAAI,KAAK,SACb,oDACA;QAEN,OAAO;YAAE,SAAS;YAAO;QAAa;IACxC;IAEA,OAAO;QAAE,SAAS;IAAK;AACzB","debugId":null}},
    {"offset": {"line": 714, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/editor-utils.ts"],"sourcesContent":["import { CanvasSize } from \"@/types/editor\";\r\n\r\nconst DEFAULT_CANVAS_PRESETS = [\r\n  { name: \"16:9\", width: 1920, height: 1080 },\r\n  { name: \"9:16\", width: 1080, height: 1920 },\r\n  { name: \"1:1\", width: 1080, height: 1080 },\r\n  { name: \"4:3\", width: 1440, height: 1080 },\r\n];\r\n\r\n/**\r\n * Helper function to find the best matching canvas preset for an aspect ratio\r\n * @param aspectRatio The target aspect ratio to match\r\n * @returns The best matching canvas size\r\n */\r\nexport function findBestCanvasPreset(aspectRatio: number): CanvasSize {\r\n  // Calculate aspect ratio for each preset and find the closest match\r\n  let bestMatch = DEFAULT_CANVAS_PRESETS[0]; // Default to 16:9 HD\r\n  let smallestDifference = Math.abs(\r\n    aspectRatio - bestMatch.width / bestMatch.height\r\n  );\r\n\r\n  for (const preset of DEFAULT_CANVAS_PRESETS) {\r\n    const presetAspectRatio = preset.width / preset.height;\r\n    const difference = Math.abs(aspectRatio - presetAspectRatio);\r\n\r\n    if (difference < smallestDifference) {\r\n      smallestDifference = difference;\r\n      bestMatch = preset;\r\n    }\r\n  }\r\n\r\n  // If the difference is still significant (> 0.1), create a custom size\r\n  // based on the media aspect ratio with a reasonable resolution\r\n  const bestAspectRatio = bestMatch.width / bestMatch.height;\r\n  if (Math.abs(aspectRatio - bestAspectRatio) > 0.1) {\r\n    // Create custom dimensions based on the aspect ratio\r\n    if (aspectRatio > 1) {\r\n      // Landscape - use 1920 width\r\n      return { width: 1920, height: Math.round(1920 / aspectRatio) };\r\n    }\r\n    // Portrait or square - use 1080 height\r\n    return { width: Math.round(1080 * aspectRatio), height: 1080 };\r\n  }\r\n\r\n  return { width: bestMatch.width, height: bestMatch.height };\r\n}\r\n"],"names":[],"mappings":";;;AAEA,MAAM,yBAAyB;IAC7B;QAAE,MAAM;QAAQ,OAAO;QAAM,QAAQ;IAAK;IAC1C;QAAE,MAAM;QAAQ,OAAO;QAAM,QAAQ;IAAK;IAC1C;QAAE,MAAM;QAAO,OAAO;QAAM,QAAQ;IAAK;IACzC;QAAE,MAAM;QAAO,OAAO;QAAM,QAAQ;IAAK;CAC1C;AAOM,SAAS,qBAAqB,WAAmB;IACtD,oEAAoE;IACpE,IAAI,YAAY,sBAAsB,CAAC,EAAE,EAAE,qBAAqB;IAChE,IAAI,qBAAqB,KAAK,GAAG,CAC/B,cAAc,UAAU,KAAK,GAAG,UAAU,MAAM;IAGlD,KAAK,MAAM,UAAU,uBAAwB;QAC3C,MAAM,oBAAoB,OAAO,KAAK,GAAG,OAAO,MAAM;QACtD,MAAM,aAAa,KAAK,GAAG,CAAC,cAAc;QAE1C,IAAI,aAAa,oBAAoB;YACnC,qBAAqB;YACrB,YAAY;QACd;IACF;IAEA,uEAAuE;IACvE,+DAA+D;IAC/D,MAAM,kBAAkB,UAAU,KAAK,GAAG,UAAU,MAAM;IAC1D,IAAI,KAAK,GAAG,CAAC,cAAc,mBAAmB,KAAK;QACjD,qDAAqD;QACrD,IAAI,cAAc,GAAG;YACnB,6BAA6B;YAC7B,OAAO;gBAAE,OAAO;gBAAM,QAAQ,KAAK,KAAK,CAAC,OAAO;YAAa;QAC/D;QACA,uCAAuC;QACvC,OAAO;YAAE,OAAO,KAAK,KAAK,CAAC,OAAO;YAAc,QAAQ;QAAK;IAC/D;IAEA,OAAO;QAAE,OAAO,UAAU,KAAK;QAAE,QAAQ,UAAU,MAAM;IAAC;AAC5D","debugId":null}},
    {"offset": {"line": 778, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/stores/scene-store.ts"],"sourcesContent":["import { create } from \"zustand\";\nimport { Scene } from \"@/types/project\";\nimport { useProjectStore } from \"./project-store\";\nimport { useTimelineStore } from \"./timeline-store\";\nimport { storageService } from \"@/lib/storage/storage-service\";\nimport { generateUUID } from \"@/lib/utils\";\n\nexport function getMainScene({ scenes }: { scenes: Scene[] }): Scene | null {\n  return scenes.find((scene) => scene.isMain) || null;\n}\n\nfunction ensureMainScene(scenes: Scene[]): Scene[] {\n  const hasMain = scenes.some((scene) => scene.isMain);\n  if (!hasMain) {\n    const mainScene: Scene = {\n      id: generateUUID(),\n      name: \"Main scene\",\n      isMain: true,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n    return [mainScene, ...scenes];\n  }\n  return scenes;\n}\n\ninterface SceneStore {\n  // Current scene state\n  currentScene: Scene | null;\n  scenes: Scene[];\n\n  // Scene management\n  createScene: ({\n    name,\n    isMain,\n  }: {\n    name: string;\n    isMain: boolean;\n  }) => Promise<string>;\n  deleteScene: ({ sceneId }: { sceneId: string }) => Promise<void>;\n  renameScene: ({\n    sceneId,\n    name,\n  }: {\n    sceneId: string;\n    name: string;\n  }) => Promise<void>;\n  switchToScene: ({ sceneId }: { sceneId: string }) => Promise<void>;\n\n  // Scene utilities\n  getMainScene: () => Scene | null;\n  getCurrentScene: () => Scene | null;\n\n  // Project integration\n  loadProjectScenes: ({ projectId }: { projectId: string }) => Promise<void>;\n  initializeScenes: ({\n    scenes,\n    currentSceneId,\n  }: {\n    scenes: Scene[];\n    currentSceneId?: string;\n  }) => void;\n  clearScenes: () => void;\n}\n\nexport const useSceneStore = create<SceneStore>((set, get) => ({\n  currentScene: null,\n  scenes: [],\n\n  createScene: async ({ name, isMain = false }) => {\n    const { scenes } = get();\n\n    const newScene = {\n      id: generateUUID(),\n      name,\n      isMain,\n      isBackground: false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n    const updatedScenes = [...scenes, newScene];\n\n    const projectStore = useProjectStore.getState();\n    const { activeProject } = projectStore;\n\n    if (!activeProject) {\n      throw new Error(\"No active project\");\n    }\n\n    const updatedProject = {\n      ...activeProject,\n      scenes: updatedScenes,\n      updatedAt: new Date(),\n    };\n\n    try {\n      await storageService.saveProject({ project: updatedProject });\n      useProjectStore.setState({ activeProject: updatedProject });\n      set({ scenes: updatedScenes });\n      return newScene.id;\n    } catch (error) {\n      console.error(\"Failed to create scene:\", error);\n      throw error;\n    }\n  },\n\n  deleteScene: async ({ sceneId }: { sceneId: string }) => {\n    const { scenes, currentScene } = get();\n    const sceneToDelete = scenes.find((s) => s.id === sceneId);\n\n    if (!sceneToDelete) {\n      throw new Error(\"Scene not found\");\n    }\n\n    if (sceneToDelete.isMain) {\n      throw new Error(\"Cannot delete main scene\");\n    }\n\n    const updatedScenes = scenes.filter((s) => s.id !== sceneId);\n\n    // Determine new current scene if we're deleting the current one\n    let newCurrentScene = currentScene;\n    if (currentScene?.id === sceneId) {\n      newCurrentScene = getMainScene({ scenes: updatedScenes });\n    }\n\n    // Update project\n    const projectStore = useProjectStore.getState();\n    const { activeProject } = projectStore;\n\n    if (!activeProject) {\n      throw new Error(\"No active project\");\n    }\n\n    const updatedProject = {\n      ...activeProject,\n      scenes: updatedScenes,\n      updatedAt: new Date(),\n    };\n\n    try {\n      await storageService.saveProject({ project: updatedProject });\n      useProjectStore.setState({ activeProject: updatedProject });\n      set({\n        scenes: updatedScenes,\n        currentScene: newCurrentScene,\n      });\n\n      // If we switched scenes, load the new scene's timeline\n      if (newCurrentScene && newCurrentScene.id !== currentScene?.id) {\n        const timelineStore = useTimelineStore.getState();\n        await timelineStore.loadProjectTimeline({\n          projectId: activeProject.id,\n          sceneId: newCurrentScene.id,\n        });\n      }\n    } catch (error) {\n      console.error(\"Failed to delete scene:\", error);\n      throw error;\n    }\n  },\n\n  renameScene: async ({ sceneId, name }: { sceneId: string; name: string }) => {\n    const { scenes } = get();\n    const updatedScenes = scenes.map((scene) =>\n      scene.id === sceneId ? { ...scene, name, updatedAt: new Date() } : scene\n    );\n\n    // Update project\n    const projectStore = useProjectStore.getState();\n    const { activeProject } = projectStore;\n\n    if (!activeProject) {\n      throw new Error(\"No active project\");\n    }\n\n    const updatedProject = {\n      ...activeProject,\n      scenes: updatedScenes,\n      updatedAt: new Date(),\n    };\n\n    try {\n      await storageService.saveProject({ project: updatedProject });\n      useProjectStore.setState({ activeProject: updatedProject });\n      set({\n        scenes: updatedScenes,\n        currentScene: updatedScenes.find((s) => s.id === sceneId) || null,\n      });\n    } catch (error) {\n      console.error(\"Failed to rename scene:\", error);\n      throw error;\n    }\n  },\n\n  switchToScene: async ({ sceneId }: { sceneId: string }) => {\n    const { scenes } = get();\n    const targetScene = scenes.find((s) => s.id === sceneId);\n\n    if (!targetScene) {\n      throw new Error(\"Scene not found\");\n    }\n\n    const timelineStore = useTimelineStore.getState();\n    const projectStore = useProjectStore.getState();\n    const { activeProject } = projectStore;\n    const { currentScene } = get();\n\n    if (activeProject && currentScene) {\n      await timelineStore.saveProjectTimeline({\n        projectId: activeProject.id,\n        sceneId: currentScene.id,\n      });\n    }\n\n    if (activeProject) {\n      await timelineStore.loadProjectTimeline({\n        projectId: activeProject.id,\n        sceneId,\n      });\n\n      const updatedProject = {\n        ...activeProject,\n        currentSceneId: sceneId,\n        updatedAt: new Date(),\n      };\n\n      await storageService.saveProject({ project: updatedProject });\n      useProjectStore.setState({ activeProject: updatedProject });\n    }\n\n    set({ currentScene: targetScene });\n  },\n\n  getMainScene: () => {\n    const { scenes } = get();\n    return scenes.find((scene) => scene.isMain) || null;\n  },\n\n  getCurrentScene: () => {\n    return get().currentScene;\n  },\n\n  loadProjectScenes: async ({ projectId }: { projectId: string }) => {\n    try {\n      const project = await storageService.loadProject({ id: projectId });\n      if (project?.scenes) {\n        const ensuredScenes = project.scenes.map((scene) => ({\n          ...scene,\n          isMain: scene.isMain || false,\n        }));\n        const currentScene =\n          ensuredScenes.find((s) => s.id === project.currentSceneId) ||\n          ensuredScenes[0];\n\n        set({\n          scenes: ensuredScenes,\n          currentScene,\n        });\n      }\n    } catch (error) {\n      console.error(\"Failed to load project scenes:\", error);\n      set({ scenes: [], currentScene: null });\n    }\n  },\n\n  initializeScenes: ({\n    scenes,\n    currentSceneId,\n  }: {\n    scenes: Scene[];\n    currentSceneId?: string;\n  }) => {\n    const ensuredScenes = ensureMainScene(scenes);\n    const currentScene = currentSceneId\n      ? ensuredScenes.find((s) => s.id === currentSceneId)\n      : null;\n\n    const fallbackScene = getMainScene({ scenes: ensuredScenes });\n\n    set({\n      scenes: ensuredScenes,\n      currentScene: currentScene || fallbackScene,\n    });\n\n    if (ensuredScenes.length > scenes.length) {\n      const projectStore = useProjectStore.getState();\n      const { activeProject } = projectStore;\n\n      if (activeProject) {\n        const updatedProject = {\n          ...activeProject,\n          scenes: ensuredScenes,\n          updatedAt: new Date(),\n        };\n\n        storageService\n          .saveProject({ project: updatedProject })\n          .then(() => {\n            useProjectStore.setState({ activeProject: updatedProject });\n          })\n          .catch((error) => {\n            console.error(\n              \"Failed to save project with background scene:\",\n              error\n            );\n          });\n      }\n    }\n  },\n\n  clearScenes: () => {\n    set({\n      scenes: [],\n      currentScene: null,\n    });\n  },\n}));\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1051, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/constants/timeline-constants.ts"],"sourcesContent":["import type { TrackType } from \"@/types/timeline\";\n\n// Track color definitions\nexport const TRACK_COLORS: Record<\n  TrackType,\n  { solid: string; background: string; border: string }\n> = {\n  media: {\n    solid: \"bg-blue-500\",\n    background: \"\",\n    border: \"\",\n  },\n  text: {\n    solid: \"bg-[#5DBAA0]\",\n    background: \"bg-[#5DBAA0]\",\n    border: \"\",\n  },\n  audio: {\n    solid: \"bg-green-500\",\n    background: \"bg-[#915DBE]\",\n    border: \"\",\n  },\n} as const;\n\n// Utility functions\nexport function getTrackColors(type: TrackType) {\n  return TRACK_COLORS[type];\n}\n\nexport function getTrackElementClasses(type: TrackType) {\n  const colors = getTrackColors(type);\n  return `${colors.background} ${colors.border}`;\n}\n\n// Track height definitions\nexport const TRACK_HEIGHTS: Record<TrackType, number> = {\n  media: 60,\n  text: 25,\n  audio: 50,\n} as const;\n\n// Utility function for track heights\nexport function getTrackHeight(type: TrackType): number {\n  return TRACK_HEIGHTS[type];\n}\n\n// Calculate cumulative height up to (but not including) a track index\nexport function getCumulativeHeightBefore(\n  tracks: Array<{ type: TrackType }>,\n  trackIndex: number\n): number {\n  const GAP = 4; // 4px gap between tracks (equivalent to Tailwind's gap-1)\n  return tracks\n    .slice(0, trackIndex)\n    .reduce((sum, track) => sum + getTrackHeight(track.type) + GAP, 0);\n}\n\n// Calculate total height of all tracks\nexport function getTotalTracksHeight(\n  tracks: Array<{ type: TrackType }>\n): number {\n  const GAP = 4; // 4px gap between tracks (equivalent to Tailwind's gap-1)\n  const tracksHeight = tracks.reduce(\n    (sum, track) => sum + getTrackHeight(track.type),\n    0\n  );\n  const gapsHeight = Math.max(0, tracks.length - 1) * GAP; // n-1 gaps for n tracks\n  return tracksHeight + gapsHeight;\n}\n\n// Other timeline constants\nexport const TIMELINE_CONSTANTS = {\n  ELEMENT_MIN_WIDTH: 80,\n  PIXELS_PER_SECOND: 50,\n  TRACK_HEIGHT: 60, // Default fallback\n  DEFAULT_TEXT_DURATION: 5,\n  DEFAULT_IMAGE_DURATION: 5,\n  ZOOM_LEVELS: [0.25, 0.5, 1, 1.5, 2, 3, 4],\n} as const;\n\n// FPS presets for project settings\nexport const FPS_PRESETS = [\n  { value: \"24\", label: \"24 fps\" },\n  { value: \"25\", label: \"25 fps\" },\n  { value: \"30\", label: \"30 fps\" },\n  { value: \"60\", label: \"60 fps\" },\n  { value: \"120\", label: \"120 fps\" },\n] as const;\n\n// Frame snapping utilities\nexport function timeToFrame(time: number, fps: number): number {\n  return Math.round(time * fps);\n}\n\nexport function frameToTime(frame: number, fps: number): number {\n  return frame / fps;\n}\n\nexport function snapTimeToFrame(time: number, fps: number): number {\n  if (fps <= 0) return time; // Fallback for invalid FPS\n  const frame = timeToFrame(time, fps);\n  return frameToTime(frame, fps);\n}\n\nexport function getFrameDuration(fps: number): number {\n  return 1 / fps;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAGO,MAAM,eAGT;IACF,OAAO;QACL,OAAO;QACP,YAAY;QACZ,QAAQ;IACV;IACA,MAAM;QACJ,OAAO;QACP,YAAY;QACZ,QAAQ;IACV;IACA,OAAO;QACL,OAAO;QACP,YAAY;QACZ,QAAQ;IACV;AACF;AAGO,SAAS,eAAe,IAAe;IAC5C,OAAO,YAAY,CAAC,KAAK;AAC3B;AAEO,SAAS,uBAAuB,IAAe;IACpD,MAAM,SAAS,eAAe;IAC9B,OAAO,GAAG,OAAO,UAAU,CAAC,CAAC,EAAE,OAAO,MAAM,EAAE;AAChD;AAGO,MAAM,gBAA2C;IACtD,OAAO;IACP,MAAM;IACN,OAAO;AACT;AAGO,SAAS,eAAe,IAAe;IAC5C,OAAO,aAAa,CAAC,KAAK;AAC5B;AAGO,SAAS,0BACd,MAAkC,EAClC,UAAkB;IAElB,MAAM,MAAM,GAAG,0DAA0D;IACzE,OAAO,OACJ,KAAK,CAAC,GAAG,YACT,MAAM,CAAC,CAAC,KAAK,QAAU,MAAM,eAAe,MAAM,IAAI,IAAI,KAAK;AACpE;AAGO,SAAS,qBACd,MAAkC;IAElC,MAAM,MAAM,GAAG,0DAA0D;IACzE,MAAM,eAAe,OAAO,MAAM,CAChC,CAAC,KAAK,QAAU,MAAM,eAAe,MAAM,IAAI,GAC/C;IAEF,MAAM,aAAa,KAAK,GAAG,CAAC,GAAG,OAAO,MAAM,GAAG,KAAK,KAAK,wBAAwB;IACjF,OAAO,eAAe;AACxB;AAGO,MAAM,qBAAqB;IAChC,mBAAmB;IACnB,mBAAmB;IACnB,cAAc;IACd,uBAAuB;IACvB,wBAAwB;IACxB,aAAa;QAAC;QAAM;QAAK;QAAG;QAAK;QAAG;QAAG;KAAE;AAC3C;AAGO,MAAM,cAAc;IACzB;QAAE,OAAO;QAAM,OAAO;IAAS;IAC/B;QAAE,OAAO;QAAM,OAAO;IAAS;IAC/B;QAAE,OAAO;QAAM,OAAO;IAAS;IAC/B;QAAE,OAAO;QAAM,OAAO;IAAS;IAC/B;QAAE,OAAO;QAAO,OAAO;IAAU;CAClC;AAGM,SAAS,YAAY,IAAY,EAAE,GAAW;IACnD,OAAO,KAAK,KAAK,CAAC,OAAO;AAC3B;AAEO,SAAS,YAAY,KAAa,EAAE,GAAW;IACpD,OAAO,QAAQ;AACjB;AAEO,SAAS,gBAAgB,IAAY,EAAE,GAAW;IACvD,IAAI,OAAO,GAAG,OAAO,MAAM,2BAA2B;IACtD,MAAM,QAAQ,YAAY,MAAM;IAChC,OAAO,YAAY,OAAO;AAC5B;AAEO,SAAS,iBAAiB,GAAW;IAC1C,OAAO,IAAI;AACb","debugId":null}},
    {"offset": {"line": 1164, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/timeline.ts"],"sourcesContent":["import { TimelineElement } from \"@/types/timeline\";\n\n// Helper function to check for element overlaps and prevent invalid timeline states\nexport const checkElementOverlaps = (elements: TimelineElement[]): boolean => {\n  // Sort elements by start time\n  const sortedElements = [...elements].sort(\n    (a, b) => a.startTime - b.startTime\n  );\n\n  for (let i = 0; i < sortedElements.length - 1; i++) {\n    const current = sortedElements[i];\n    const next = sortedElements[i + 1];\n\n    const currentEnd =\n      current.startTime +\n      (current.duration - current.trimStart - current.trimEnd);\n\n    // Check if current element overlaps with next element\n    if (currentEnd > next.startTime) return true; // Overlap detected\n  }\n\n  return false; // No overlaps\n};\n\n// Helper function to resolve overlaps by adjusting element positions\nexport const resolveElementOverlaps = (\n  elements: TimelineElement[]\n): TimelineElement[] => {\n  // Sort elements by start time\n  const sortedElements = [...elements].sort(\n    (a, b) => a.startTime - b.startTime\n  );\n  const resolvedElements: TimelineElement[] = [];\n\n  for (let i = 0; i < sortedElements.length; i++) {\n    const current = { ...sortedElements[i] };\n\n    if (resolvedElements.length > 0) {\n      const previous = resolvedElements[resolvedElements.length - 1];\n      const previousEnd =\n        previous.startTime +\n        (previous.duration - previous.trimStart - previous.trimEnd);\n\n      // If current element would overlap with previous, push it after previous ends\n      if (current.startTime < previousEnd) {\n        current.startTime = previousEnd;\n      }\n    }\n\n    resolvedElements.push(current);\n  }\n\n  return resolvedElements;\n};\n"],"names":[],"mappings":";;;;AAGO,MAAM,uBAAuB,CAAC;IACnC,8BAA8B;IAC9B,MAAM,iBAAiB;WAAI;KAAS,CAAC,IAAI,CACvC,CAAC,GAAG,IAAM,EAAE,SAAS,GAAG,EAAE,SAAS;IAGrC,IAAK,IAAI,IAAI,GAAG,IAAI,eAAe,MAAM,GAAG,GAAG,IAAK;QAClD,MAAM,UAAU,cAAc,CAAC,EAAE;QACjC,MAAM,OAAO,cAAc,CAAC,IAAI,EAAE;QAElC,MAAM,aACJ,QAAQ,SAAS,GACjB,CAAC,QAAQ,QAAQ,GAAG,QAAQ,SAAS,GAAG,QAAQ,OAAO;QAEzD,sDAAsD;QACtD,IAAI,aAAa,KAAK,SAAS,EAAE,OAAO,MAAM,mBAAmB;IACnE;IAEA,OAAO,OAAO,cAAc;AAC9B;AAGO,MAAM,yBAAyB,CACpC;IAEA,8BAA8B;IAC9B,MAAM,iBAAiB;WAAI;KAAS,CAAC,IAAI,CACvC,CAAC,GAAG,IAAM,EAAE,SAAS,GAAG,EAAE,SAAS;IAErC,MAAM,mBAAsC,EAAE;IAE9C,IAAK,IAAI,IAAI,GAAG,IAAI,eAAe,MAAM,EAAE,IAAK;QAC9C,MAAM,UAAU;YAAE,GAAG,cAAc,CAAC,EAAE;QAAC;QAEvC,IAAI,iBAAiB,MAAM,GAAG,GAAG;YAC/B,MAAM,WAAW,gBAAgB,CAAC,iBAAiB,MAAM,GAAG,EAAE;YAC9D,MAAM,cACJ,SAAS,SAAS,GAClB,CAAC,SAAS,QAAQ,GAAG,SAAS,SAAS,GAAG,SAAS,OAAO;YAE5D,8EAA8E;YAC9E,IAAI,QAAQ,SAAS,GAAG,aAAa;gBACnC,QAAQ,SAAS,GAAG;YACtB;QACF;QAEA,iBAAiB,IAAI,CAAC;IACxB;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 1208, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/constants/text-constants.ts"],"sourcesContent":["import { TextElement } from \"@/types/timeline\";\r\nimport { TIMELINE_CONSTANTS } from \"./timeline-constants\";\r\n\r\nexport const DEFAULT_TEXT_ELEMENT: Omit<\r\n  TextElement,\r\n  \"id\"\r\n> = {\r\n  type: \"text\",\r\n  name: \"Text\",\r\n  content: \"Default Text\",\r\n  fontSize: 48,\r\n  fontFamily: \"Arial\",\r\n  color: \"#ffffff\",\r\n  backgroundColor: \"transparent\",\r\n  textAlign: \"center\",\r\n  fontWeight: \"normal\",\r\n  fontStyle: \"normal\",\r\n  textDecoration: \"none\",\r\n  x: 0,\r\n  y: 0,\r\n  rotation: 0,\r\n  opacity: 1,\r\n  duration: TIMELINE_CONSTANTS.DEFAULT_TEXT_DURATION,\r\n  startTime: 0,\r\n  trimStart: 0,\r\n  trimEnd: 0,\r\n};\r\n"],"names":[],"mappings":";;;AACA;;AAEO,MAAM,uBAGT;IACF,MAAM;IACN,MAAM;IACN,SAAS;IACT,UAAU;IACV,YAAY;IACZ,OAAO;IACP,iBAAiB;IACjB,WAAW;IACX,YAAY;IACZ,WAAW;IACX,gBAAgB;IAChB,GAAG;IACH,GAAG;IACH,UAAU;IACV,SAAS;IACT,UAAU,wJAAA,CAAA,qBAAkB,CAAC,qBAAqB;IAClD,WAAW;IACX,WAAW;IACX,SAAS;AACX","debugId":null}},
    {"offset": {"line": 1238, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/stores/playback-store.ts"],"sourcesContent":["import { create } from \"zustand\";\nimport type { PlaybackState, PlaybackControls } from \"@/types/playback\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { DEFAULT_FPS, useProjectStore } from \"./project-store\";\n\ninterface PlaybackStore extends PlaybackState, PlaybackControls {\n  setDuration: (duration: number) => void;\n  setCurrentTime: (time: number) => void;\n}\n\nlet playbackTimer: number | null = null;\n\nconst startTimer = (store: () => PlaybackStore) => {\n  if (playbackTimer) cancelAnimationFrame(playbackTimer);\n\n  // Use requestAnimationFrame for smoother updates\n  const updateTime = () => {\n    const state = store();\n    if (state.isPlaying && state.currentTime < state.duration) {\n      const now = performance.now();\n      const delta = (now - lastUpdate) / 1000; // Convert to seconds\n      lastUpdate = now;\n\n      const newTime = state.currentTime + delta * state.speed;\n\n      // Get actual content duration from timeline store\n      const actualContentDuration = useTimelineStore\n        .getState()\n        .getTotalDuration();\n\n      // Stop at actual content end, not timeline duration (which has 10s minimum)\n      // It was either this or reducing default min timeline to 1 second\n      const effectiveDuration =\n        actualContentDuration > 0 ? actualContentDuration : state.duration;\n\n      if (newTime >= effectiveDuration) {\n        // When content completes, pause just before the end so we can see the last frame\n        const projectFps = useProjectStore.getState().activeProject?.fps;\n        if (!projectFps)\n          console.error(\"Project FPS is not set, assuming \" + DEFAULT_FPS + \"fps\");\n\n        const frameOffset = 1 / (projectFps ?? DEFAULT_FPS); // Stop 1 frame before end based on project FPS\n        const stopTime = Math.max(0, effectiveDuration - frameOffset);\n\n        state.pause();\n        state.setCurrentTime(stopTime);\n        // Notify video elements to sync with end position\n        window.dispatchEvent(\n          new CustomEvent(\"playback-seek\", {\n            detail: { time: stopTime },\n          })\n        );\n      } else {\n        state.setCurrentTime(newTime);\n        // Notify video elements to sync\n        window.dispatchEvent(\n          new CustomEvent(\"playback-update\", { detail: { time: newTime } })\n        );\n      }\n    }\n    playbackTimer = requestAnimationFrame(updateTime);\n  };\n\n  let lastUpdate = performance.now();\n  playbackTimer = requestAnimationFrame(updateTime);\n};\n\nconst stopTimer = () => {\n  if (playbackTimer) {\n    cancelAnimationFrame(playbackTimer);\n    playbackTimer = null;\n  }\n};\n\nexport const usePlaybackStore = create<PlaybackStore>((set, get) => ({\n  isPlaying: false,\n  currentTime: 0,\n  duration: 0,\n  volume: 1,\n  muted: false,\n  previousVolume: 1,\n  speed: 1.0,\n\n  play: () => {\n    const state = get();\n\n    const actualContentDuration = useTimelineStore\n      .getState()\n      .getTotalDuration();\n    const effectiveDuration =\n      actualContentDuration > 0 ? actualContentDuration : state.duration;\n\n    if (effectiveDuration > 0) {\n      const fps = useProjectStore.getState().activeProject?.fps ?? DEFAULT_FPS;\n      const frameOffset = 1 / fps;\n      const endThreshold = Math.max(0, effectiveDuration - frameOffset);\n\n      if (state.currentTime >= endThreshold) {\n        get().seek(0);\n      }\n    }\n\n    set({ isPlaying: true });\n    startTimer(get);\n  },\n\n  pause: () => {\n    set({ isPlaying: false });\n    stopTimer();\n  },\n\n  toggle: () => {\n    const { isPlaying } = get();\n    if (isPlaying) {\n      get().pause();\n    } else {\n      get().play();\n    }\n  },\n\n  seek: (time: number) => {\n    const { duration } = get();\n    const clampedTime = Math.max(0, Math.min(duration, time));\n    set({ currentTime: clampedTime });\n\n    const event = new CustomEvent(\"playback-seek\", {\n      detail: { time: clampedTime },\n    });\n    window.dispatchEvent(event);\n  },\n\n  setVolume: (volume: number) =>\n    set((state) => ({\n      volume: Math.max(0, Math.min(1, volume)),\n      muted: volume === 0,\n      previousVolume: volume > 0 ? volume : state.previousVolume,\n    })),\n\n  setSpeed: (speed: number) => {\n    const newSpeed = Math.max(0.1, Math.min(2.0, speed));\n    set({ speed: newSpeed });\n\n    const event = new CustomEvent(\"playback-speed\", {\n      detail: { speed: newSpeed },\n    });\n    window.dispatchEvent(event);\n  },\n\n  setDuration: (duration: number) => set({ duration }),\n  setCurrentTime: (time: number) => set({ currentTime: time }),\n\n  mute: () => {\n    const { volume, previousVolume } = get();\n    set({\n      muted: true,\n      previousVolume: volume > 0 ? volume : previousVolume,\n      volume: 0,\n    });\n  },\n\n  unmute: () => {\n    const { previousVolume } = get();\n    set({ muted: false, volume: previousVolume ?? 1 });\n  },\n\n  toggleMute: () => {\n    const { muted } = get();\n    if (muted) {\n      get().unmute();\n    } else {\n      get().mute();\n    }\n  },\n}));\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1401, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/components/editor/media-panel/store.ts"],"sourcesContent":["import {\n  CaptionsIcon,\n  ArrowLeftRightIcon,\n  SparklesIcon,\n  StickerIcon,\n  MusicIcon,\n  VideoIcon,\n  BlendIcon,\n  SlidersHorizontalIcon,\n  LucideIcon,\n  TypeIcon,\n  SettingsIcon,\n} from \"lucide-react\";\nimport { create } from \"zustand\";\n\nexport type Tab =\n  | \"media\"\n  | \"sounds\"\n  | \"text\"\n  | \"stickers\"\n  | \"effects\"\n  | \"transitions\"\n  | \"captions\"\n  | \"filters\"\n  | \"adjustment\"\n  | \"settings\";\n\nexport const tabs: { [key in Tab]: { icon: LucideIcon; label: string } } = {\n  media: {\n    icon: VideoIcon,\n    label: \"Media\",\n  },\n  sounds: {\n    icon: MusicIcon,\n    label: \"Sounds\",\n  },\n  text: {\n    icon: TypeIcon,\n    label: \"Text\",\n  },\n  stickers: {\n    icon: StickerIcon,\n    label: \"Stickers\",\n  },\n  effects: {\n    icon: SparklesIcon,\n    label: \"Effects\",\n  },\n  transitions: {\n    icon: ArrowLeftRightIcon,\n    label: \"Transitions\",\n  },\n  captions: {\n    icon: CaptionsIcon,\n    label: \"Captions\",\n  },\n  filters: {\n    icon: BlendIcon,\n    label: \"Filters\",\n  },\n  adjustment: {\n    icon: SlidersHorizontalIcon,\n    label: \"Adjustment\",\n  },\n  settings: {\n    icon: SettingsIcon,\n    label: \"Settings\",\n  },\n};\n\ninterface MediaPanelStore {\n  activeTab: Tab;\n  setActiveTab: (tab: Tab) => void;\n  highlightMediaId: string | null;\n  requestRevealMedia: (mediaId: string) => void;\n  clearHighlight: () => void;\n}\n\nexport const useMediaPanelStore = create<MediaPanelStore>((set) => ({\n  activeTab: \"media\",\n  setActiveTab: (tab) => set({ activeTab: tab }),\n  highlightMediaId: null,\n  requestRevealMedia: (mediaId) =>\n    set({ activeTab: \"media\", highlightMediaId: mediaId }),\n  clearHighlight: () => set({ highlightMediaId: null }),\n}));\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;;;AAcO,MAAM,OAA8D;IACzE,OAAO;QACL,MAAM,yRAAA,CAAA,YAAS;QACf,OAAO;IACT;IACA,QAAQ;QACN,MAAM,yRAAA,CAAA,YAAS;QACf,OAAO;IACT;IACA,MAAM;QACJ,MAAM,uRAAA,CAAA,WAAQ;QACd,OAAO;IACT;IACA,UAAU;QACR,MAAM,6RAAA,CAAA,cAAW;QACjB,OAAO;IACT;IACA,SAAS;QACP,MAAM,+RAAA,CAAA,eAAY;QAClB,OAAO;IACT;IACA,aAAa;QACX,MAAM,mTAAA,CAAA,qBAAkB;QACxB,OAAO;IACT;IACA,UAAU;QACR,MAAM,+RAAA,CAAA,eAAY;QAClB,OAAO;IACT;IACA,SAAS;QACP,MAAM,yRAAA,CAAA,YAAS;QACf,OAAO;IACT;IACA,YAAY;QACV,MAAM,qTAAA,CAAA,wBAAqB;QAC3B,OAAO;IACT;IACA,UAAU;QACR,MAAM,+RAAA,CAAA,eAAY;QAClB,OAAO;IACT;AACF;AAUO,MAAM,qBAAqB,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD,EAAmB,CAAC,MAAQ,CAAC;QAClE,WAAW;QACX,cAAc,CAAC,MAAQ,IAAI;gBAAE,WAAW;YAAI;QAC5C,kBAAkB;QAClB,oBAAoB,CAAC,UACnB,IAAI;gBAAE,WAAW;gBAAS,kBAAkB;YAAQ;QACtD,gBAAgB,IAAM,IAAI;gBAAE,kBAAkB;YAAK;IACrD,CAAC","debugId":null}},
    {"offset": {"line": 1478, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/stores/timeline-store.ts"],"sourcesContent":["import { create } from \"zustand\";\nimport {\n  TrackType,\n  TimelineElement,\n  CreateTimelineElement,\n  TimelineTrack,\n  TextElement,\n  DragData,\n  MediaElement,\n  sortTracksByOrder,\n  ensureMainTrack,\n  validateElementTrackCompatibility,\n} from \"@/types/timeline\";\nimport { useMediaStore, getMediaAspectRatio } from \"./media-store\";\nimport { MediaFile, MediaType } from \"@/types/media\";\nimport { findBestCanvasPreset } from \"@/lib/editor-utils\";\nimport { storageService } from \"@/lib/storage/storage-service\";\nimport { useProjectStore } from \"./project-store\";\nimport { useSceneStore } from \"./scene-store\";\nimport { generateUUID } from \"@/lib/utils\";\nimport { TIMELINE_CONSTANTS } from \"@/constants/timeline-constants\";\nimport { checkElementOverlaps, resolveElementOverlaps } from \"@/lib/timeline\";\nimport { DEFAULT_TEXT_ELEMENT } from \"@/constants/text-constants\";\nimport { usePlaybackStore } from \"./playback-store\";\n\n// Helper function to manage element naming with suffixes\nconst getElementNameWithSuffix = (\n  originalName: string,\n  suffix: string\n): string => {\n  // Remove existing suffixes to prevent accumulation\n  const baseName = originalName\n    .replace(/ \\(left\\)$/i, \"\")\n    .replace(/ \\(right\\)$/i, \"\")\n    .replace(/ \\(audio\\)$/i, \"\")\n    .replace(/ \\(split \\d+\\)$/i, \"\");\n\n  return `${baseName} (${suffix})`;\n};\n\ninterface TimelineStore {\n  // Private track storage\n  _tracks: TimelineTrack[];\n  history: TimelineTrack[][];\n  redoStack: TimelineTrack[][];\n\n  // Clipboard buffer\n  clipboard: {\n    items: Array<{ trackType: TrackType; element: CreateTimelineElement }>;\n  } | null;\n\n  // Always returns properly ordered tracks with main track ensured\n  tracks: TimelineTrack[];\n\n  // Manual method if you need to force recomputation\n  getSortedTracks: () => TimelineTrack[];\n\n  // Snapping settings\n  snappingEnabled: boolean;\n\n  // Snapping actions\n  toggleSnapping: () => void;\n\n  // Ripple editing mode\n  rippleEditingEnabled: boolean;\n  toggleRippleEditing: () => void;\n\n  // Multi-selection\n  selectedElements: { trackId: string; elementId: string }[];\n  selectElement: (trackId: string, elementId: string, multi?: boolean) => void;\n  deselectElement: (trackId: string, elementId: string) => void;\n  clearSelectedElements: () => void;\n  setSelectedElements: (\n    elements: { trackId: string; elementId: string }[]\n  ) => void;\n\n  // Drag state\n  dragState: {\n    isDragging: boolean;\n    elementId: string | null;\n    trackId: string | null;\n    startMouseX: number;\n    startElementTime: number;\n    clickOffsetTime: number;\n    currentTime: number;\n  };\n  setDragState: (dragState: Partial<TimelineStore[\"dragState\"]>) => void;\n  startDrag: (\n    elementId: string,\n    trackId: string,\n    startMouseX: number,\n    startElementTime: number,\n    clickOffsetTime: number\n  ) => void;\n  updateDragTime: (currentTime: number) => void;\n  endDrag: () => void;\n\n  // Actions\n  addTrack: (type: TrackType) => string;\n  insertTrackAt: (type: TrackType, index: number) => string;\n  removeTrack: (trackId: string) => void;\n  removeTrackWithRipple: (trackId: string) => void;\n  addElementToTrack: (trackId: string, element: CreateTimelineElement) => void;\n\n  moveElementToTrack: (\n    fromTrackId: string,\n    toTrackId: string,\n    elementId: string\n  ) => void;\n  updateElementTrim: (\n    trackId: string,\n    elementId: string,\n    trimStart: number,\n    trimEnd: number,\n    pushHistory?: boolean\n  ) => void;\n  updateElementDuration: (\n    trackId: string,\n    elementId: string,\n    duration: number,\n    pushHistory?: boolean\n  ) => void;\n  updateElementStartTime: (\n    trackId: string,\n    elementId: string,\n    startTime: number,\n    pushHistory?: boolean\n  ) => void;\n  toggleTrackMute: (trackId: string) => void;\n  splitAndKeepLeft: (\n    trackId: string,\n    elementId: string,\n    splitTime: number\n  ) => void;\n  splitAndKeepRight: (\n    trackId: string,\n    elementId: string,\n    splitTime: number\n  ) => void;\n  separateAudio: (trackId: string, elementId: string) => string | null;\n\n  // Replace media for an element\n  replaceElementMedia: (\n    trackId: string,\n    elementId: string,\n    newFile: File\n  ) => Promise<{ success: boolean; error?: string }>;\n\n  // Ripple editing functions\n  updateElementStartTimeWithRipple: (\n    trackId: string,\n    elementId: string,\n    newStartTime: number\n  ) => void;\n  removeElementFromTrackWithRipple: (\n    trackId: string,\n    elementId: string,\n    pushHistory?: boolean\n  ) => void;\n\n  // Computed values\n  getTotalDuration: () => number;\n  getProjectThumbnail: (projectId: string) => Promise<string | null>;\n\n  // History actions\n  undo: () => void;\n  redo: () => void;\n  pushHistory: () => void;\n\n  // Persistence actions\n  loadProjectTimeline: ({\n    projectId,\n    sceneId,\n  }: {\n    projectId: string;\n    sceneId?: string;\n  }) => Promise<void>;\n  saveProjectTimeline: ({\n    projectId,\n    sceneId,\n  }: {\n    projectId: string;\n    sceneId?: string;\n  }) => Promise<void>;\n  clearTimeline: () => void;\n\n  // Clipboard actions\n  copySelected: () => void;\n  pasteAtTime: (time: number) => void;\n\n  // Unified selection-aware actions\n  deleteSelected: (trackId?: string, elementId?: string) => void;\n  splitSelected: (\n    splitTime: number,\n    trackId?: string,\n    elementId?: string\n  ) => void;\n  toggleSelectedHidden: (trackId?: string, elementId?: string) => void;\n  toggleSelectedMuted: (trackId?: string, elementId?: string) => void;\n  duplicateElement: (trackId: string, elementId: string) => void;\n  revealElementInMedia: (elementId: string) => void;\n  replaceElementWithFile: (\n    trackId: string,\n    elementId: string,\n    file: File\n  ) => Promise<void>;\n  getContextMenuState: (\n    trackId: string,\n    elementId: string\n  ) => {\n    isMultipleSelected: boolean;\n    isCurrentElementSelected: boolean;\n    hasAudioElements: boolean;\n    canSplitSelected: boolean;\n    currentTime: number;\n  };\n  updateTextElement: (\n    trackId: string,\n    elementId: string,\n    updates: Partial<\n      Pick<\n        TextElement,\n        | \"content\"\n        | \"fontSize\"\n        | \"fontFamily\"\n        | \"color\"\n        | \"backgroundColor\"\n        | \"textAlign\"\n        | \"fontWeight\"\n        | \"fontStyle\"\n        | \"textDecoration\"\n        | \"x\"\n        | \"y\"\n        | \"rotation\"\n        | \"opacity\"\n      >\n    >\n  ) => void;\n  checkElementOverlap: (\n    trackId: string,\n    startTime: number,\n    duration: number,\n    excludeElementId?: string\n  ) => boolean;\n  findOrCreateTrack: (trackType: TrackType) => string;\n  addElementAtTime: (\n    item: MediaFile | TextElement,\n    currentTime?: number\n  ) => boolean;\n  addElementToNewTrack: (item: MediaFile | TextElement | DragData) => boolean;\n}\n\nexport const useTimelineStore = create<TimelineStore>((set, get) => {\n  // Helper to update tracks and maintain ordering\n  const updateTracks = (newTracks: TimelineTrack[]) => {\n    const tracksWithMain = ensureMainTrack(newTracks);\n    const sortedTracks = sortTracksByOrder(tracksWithMain);\n    set({\n      _tracks: tracksWithMain,\n      tracks: sortedTracks,\n    });\n  };\n\n  // Helper to auto-save timeline changes\n  const autoSaveTimeline = async () => {\n    const activeProject = useProjectStore.getState().activeProject;\n    const currentScene = useSceneStore.getState().currentScene;\n\n    if (activeProject && currentScene) {\n      try {\n        await storageService.saveTimeline({\n          projectId: activeProject.id,\n          tracks: get()._tracks,\n          sceneId: currentScene.id,\n        });\n      } catch (error) {\n        console.error(\"Failed to auto-save timeline:\", error);\n      }\n    } else {\n      console.warn(\n        \"Auto-save skipped - missing activeProject or currentScene:\",\n        {\n          hasProject: !!activeProject,\n          hasScene: !!currentScene,\n          sceneName: currentScene?.name,\n        }\n      );\n    }\n  };\n\n  // Helper to update tracks and auto-save\n  const updateTracksAndSave = (newTracks: TimelineTrack[]) => {\n    updateTracks(newTracks);\n    // Auto-save in background\n    setTimeout(autoSaveTimeline, 100);\n  };\n\n  // Initialize with proper track ordering\n  const initialTracks = ensureMainTrack([]);\n  const sortedInitialTracks = sortTracksByOrder(initialTracks);\n\n  return {\n    _tracks: initialTracks,\n    tracks: sortedInitialTracks,\n    history: [],\n    redoStack: [],\n    selectedElements: [],\n    rippleEditingEnabled: false,\n    clipboard: null,\n\n    // Snapping settings defaults\n    snappingEnabled: true,\n\n    getSortedTracks: () => {\n      const { _tracks } = get();\n      const tracksWithMain = ensureMainTrack(_tracks);\n      return sortTracksByOrder(tracksWithMain);\n    },\n\n    pushHistory: () => {\n      const { _tracks, history } = get();\n      set({\n        history: [...history, JSON.parse(JSON.stringify(_tracks))],\n        redoStack: [],\n      });\n    },\n\n    undo: () => {\n      const { history, redoStack, _tracks } = get();\n      if (history.length === 0) return;\n      const prev = history[history.length - 1];\n      updateTracksAndSave(prev);\n      set({\n        history: history.slice(0, -1),\n        redoStack: [...redoStack, JSON.parse(JSON.stringify(_tracks))],\n      });\n    },\n\n    selectElement: (trackId, elementId, multi = false) => {\n      set((state) => {\n        const exists = state.selectedElements.some(\n          (c) => c.trackId === trackId && c.elementId === elementId\n        );\n        if (multi) {\n          return exists\n            ? {\n                selectedElements: state.selectedElements.filter(\n                  (c) => !(c.trackId === trackId && c.elementId === elementId)\n                ),\n              }\n            : {\n                selectedElements: [\n                  ...state.selectedElements,\n                  { trackId, elementId },\n                ],\n              };\n        }\n        return { selectedElements: [{ trackId, elementId }] };\n      });\n    },\n\n    deselectElement: (trackId, elementId) => {\n      set((state) => ({\n        selectedElements: state.selectedElements.filter(\n          (c) => !(c.trackId === trackId && c.elementId === elementId)\n        ),\n      }));\n    },\n\n    clearSelectedElements: () => {\n      set({ selectedElements: [] });\n    },\n\n    setSelectedElements: (elements) => set({ selectedElements: elements }),\n\n    addTrack: (type) => {\n      get().pushHistory();\n\n      const trackName =\n        type === \"media\"\n          ? \"Media Track\"\n          : type === \"text\"\n            ? \"Text Track\"\n            : type === \"audio\"\n              ? \"Audio Track\"\n              : \"Track\";\n\n      const newTrack: TimelineTrack = {\n        id: generateUUID(),\n        name: trackName,\n        type,\n        elements: [],\n        muted: false,\n      };\n\n      updateTracksAndSave([...get()._tracks, newTrack]);\n      return newTrack.id;\n    },\n\n    insertTrackAt: (type, index) => {\n      get().pushHistory();\n\n      const trackName =\n        type === \"media\"\n          ? \"Media Track\"\n          : type === \"text\"\n            ? \"Text Track\"\n            : type === \"audio\"\n              ? \"Audio Track\"\n              : \"Track\";\n\n      const newTrack: TimelineTrack = {\n        id: generateUUID(),\n        name: trackName,\n        type,\n        elements: [],\n        muted: false,\n      };\n\n      const newTracks = [...get()._tracks];\n      newTracks.splice(index, 0, newTrack);\n      updateTracksAndSave(newTracks);\n      return newTrack.id;\n    },\n\n    removeTrack: (trackId) => {\n      const { rippleEditingEnabled } = get();\n\n      if (rippleEditingEnabled) {\n        get().removeTrackWithRipple(trackId);\n      } else {\n        get().pushHistory();\n        updateTracksAndSave(\n          get()._tracks.filter((track) => track.id !== trackId)\n        );\n      }\n    },\n\n    removeTrackWithRipple: (trackId) => {\n      const { _tracks } = get();\n      const trackToRemove = _tracks.find((t) => t.id === trackId);\n\n      if (!trackToRemove) return;\n\n      get().pushHistory();\n\n      const occupiedRanges = trackToRemove.elements.map((element) => ({\n        startTime: element.startTime,\n        endTime:\n          element.startTime +\n          (element.duration - element.trimStart - element.trimEnd),\n      }));\n\n      occupiedRanges.sort((a, b) => a.startTime - b.startTime);\n\n      const mergedRanges: Array<{\n        startTime: number;\n        endTime: number;\n        duration: number;\n      }> = [];\n\n      for (const range of occupiedRanges) {\n        if (mergedRanges.length === 0) {\n          mergedRanges.push({\n            startTime: range.startTime,\n            endTime: range.endTime,\n            duration: range.endTime - range.startTime,\n          });\n        } else {\n          const lastRange = mergedRanges[mergedRanges.length - 1];\n          if (range.startTime <= lastRange.endTime) {\n            lastRange.endTime = Math.max(lastRange.endTime, range.endTime);\n            lastRange.duration = lastRange.endTime - lastRange.startTime;\n          } else {\n            mergedRanges.push({\n              startTime: range.startTime,\n              endTime: range.endTime,\n              duration: range.endTime - range.startTime,\n            });\n          }\n        }\n      }\n\n      const updatedTracks = _tracks\n        .filter((track) => track.id !== trackId)\n        .map((track) => {\n          const updatedElements = track.elements.map((element) => {\n            let newStartTime = element.startTime;\n\n            for (let i = mergedRanges.length - 1; i >= 0; i--) {\n              const gap = mergedRanges[i];\n              if (newStartTime >= gap.endTime) {\n                newStartTime -= gap.duration;\n              }\n            }\n\n            return {\n              ...element,\n              startTime: Math.max(0, newStartTime),\n            };\n          });\n\n          const hasOverlaps = checkElementOverlaps(updatedElements);\n          if (hasOverlaps) {\n            const resolvedElements = resolveElementOverlaps(updatedElements);\n            return { ...track, elements: resolvedElements };\n          }\n\n          return { ...track, elements: updatedElements };\n        });\n\n      updateTracksAndSave(updatedTracks);\n    },\n\n    addElementToTrack: (trackId, elementData) => {\n      get().pushHistory();\n\n      const track = get()._tracks.find((t) => t.id === trackId);\n      if (!track) {\n        console.error(\"Track not found:\", trackId);\n        return;\n      }\n\n      const validation = validateElementTrackCompatibility(elementData, track);\n      if (!validation.isValid) {\n        console.error(validation.errorMessage);\n        return;\n      }\n\n      if (elementData.type === \"media\" && !elementData.mediaId) {\n        console.error(\"Media element must have mediaId\");\n        return;\n      }\n\n      if (elementData.type === \"text\" && !elementData.content) {\n        console.error(\"Text element must have content\");\n        return;\n      }\n\n      const currentState = get();\n      const totalElementsInTimeline = currentState._tracks.reduce(\n        (total, track) => total + track.elements.length,\n        0\n      );\n      const isFirstElement = totalElementsInTimeline === 0;\n\n      const newElement: TimelineElement = {\n        ...elementData,\n        id: generateUUID(),\n        startTime: elementData.startTime,\n        trimStart: elementData.trimStart ?? 0,\n        trimEnd: elementData.trimEnd ?? 0,\n        ...(elementData.type === \"media\"\n          ? { muted: elementData.muted ?? false }\n          : {}),\n      } as TimelineElement;\n\n      if (isFirstElement && newElement.type === \"media\") {\n        const mediaStore = useMediaStore.getState();\n        const mediaItem = mediaStore.mediaFiles.find(\n          (item) => item.id === newElement.mediaId\n        );\n\n        if (\n          mediaItem &&\n          (mediaItem.type === \"image\" || mediaItem.type === \"video\")\n        ) {\n          const projectStore = useProjectStore.getState();\n          projectStore.updateCanvasSize(\n            findBestCanvasPreset(getMediaAspectRatio(mediaItem)),\n            \"original\"\n          );\n        }\n\n        if (mediaItem && mediaItem.type === \"video\" && mediaItem.fps) {\n          const projectStore = useProjectStore.getState();\n          if (projectStore.activeProject) {\n            projectStore.updateProjectFps(mediaItem.fps);\n          }\n        }\n      }\n\n      updateTracksAndSave(\n        get()._tracks.map((track) =>\n          track.id === trackId\n            ? { ...track, elements: [...track.elements, newElement] }\n            : track\n        )\n      );\n\n      get().selectElement(trackId, newElement.id);\n    },\n\n    removeElementFromTrackWithRipple: (\n      trackId,\n      elementId,\n      pushHistory = true\n    ) => {\n      const { _tracks, rippleEditingEnabled } = get();\n\n      if (!rippleEditingEnabled) {\n        // Inline non-ripple removal logic\n        if (pushHistory) get().pushHistory();\n        updateTracksAndSave(\n          _tracks\n            .map((track) =>\n              track.id === trackId\n                ? {\n                    ...track,\n                    elements: track.elements.filter(\n                      (element) => element.id !== elementId\n                    ),\n                  }\n                : track\n            )\n            .filter((track) => track.elements.length > 0)\n        );\n        return;\n      }\n\n      const track = _tracks.find((t) => t.id === trackId);\n      const element = track?.elements.find((e) => e.id === elementId);\n\n      if (!element || !track) return;\n\n      if (pushHistory) get().pushHistory();\n\n      const elementStartTime = element.startTime;\n      const elementDuration =\n        element.duration - element.trimStart - element.trimEnd;\n      const elementEndTime = elementStartTime + elementDuration;\n\n      const updatedTracks = _tracks\n        .map((currentTrack) => {\n          const shouldApplyRipple = currentTrack.id === trackId;\n\n          const updatedElements = currentTrack.elements\n            .filter((currentElement) => {\n              if (\n                currentElement.id === elementId &&\n                currentTrack.id === trackId\n              ) {\n                return false;\n              }\n              return true;\n            })\n            .map((currentElement) => {\n              if (!shouldApplyRipple) {\n                return currentElement;\n              }\n\n              if (currentElement.startTime >= elementEndTime) {\n                return {\n                  ...currentElement,\n                  startTime: Math.max(\n                    0,\n                    currentElement.startTime - elementDuration\n                  ),\n                };\n              }\n              return currentElement;\n            });\n\n          const hasOverlaps = checkElementOverlaps(updatedElements);\n          if (hasOverlaps) {\n            const resolvedElements = resolveElementOverlaps(updatedElements);\n            return { ...currentTrack, elements: resolvedElements };\n          }\n\n          return { ...currentTrack, elements: updatedElements };\n        })\n        .filter((track) => track.elements.length > 0 || track.isMain);\n\n      updateTracksAndSave(updatedTracks);\n    },\n\n    moveElementToTrack: (fromTrackId, toTrackId, elementId) => {\n      get().pushHistory();\n\n      const fromTrack = get()._tracks.find((track) => track.id === fromTrackId);\n      const toTrack = get()._tracks.find((track) => track.id === toTrackId);\n      const elementToMove = fromTrack?.elements.find(\n        (element) => element.id === elementId\n      );\n\n      if (!elementToMove || !toTrack) return;\n\n      const validation = validateElementTrackCompatibility(\n        elementToMove,\n        toTrack\n      );\n      if (!validation.isValid) {\n        console.error(validation.errorMessage);\n        return;\n      }\n\n      const newTracks = get()\n        ._tracks.map((track) => {\n          if (track.id === fromTrackId) {\n            return {\n              ...track,\n              elements: track.elements.filter(\n                (element) => element.id !== elementId\n              ),\n            };\n          }\n          if (track.id === toTrackId) {\n            return {\n              ...track,\n              elements: [...track.elements, elementToMove],\n            };\n          }\n          return track;\n        })\n        .filter((track) => track.elements.length > 0);\n\n      updateTracksAndSave(newTracks);\n    },\n\n    updateElementTrim: (\n      trackId,\n      elementId,\n      trimStart,\n      trimEnd,\n      pushHistory = true\n    ) => {\n      if (pushHistory) get().pushHistory();\n      updateTracksAndSave(\n        get()._tracks.map((track) =>\n          track.id === trackId\n            ? {\n                ...track,\n                elements: track.elements.map((element) =>\n                  element.id === elementId\n                    ? { ...element, trimStart, trimEnd }\n                    : element\n                ),\n              }\n            : track\n        )\n      );\n    },\n\n    updateElementDuration: (\n      trackId,\n      elementId,\n      duration,\n      pushHistory = true\n    ) => {\n      if (pushHistory) get().pushHistory();\n      updateTracksAndSave(\n        get()._tracks.map((track) =>\n          track.id === trackId\n            ? {\n                ...track,\n                elements: track.elements.map((element) =>\n                  element.id === elementId ? { ...element, duration } : element\n                ),\n              }\n            : track\n        )\n      );\n    },\n\n    updateElementStartTime: (\n      trackId,\n      elementId,\n      startTime,\n      pushHistory = true\n    ) => {\n      if (pushHistory) get().pushHistory();\n      const clampedStartTime = Math.max(0, startTime);\n      updateTracksAndSave(\n        get()._tracks.map((track) =>\n          track.id === trackId\n            ? {\n                ...track,\n                elements: track.elements.map((element) =>\n                  element.id === elementId\n                    ? { ...element, startTime: clampedStartTime }\n                    : element\n                ),\n              }\n            : track\n        )\n      );\n    },\n\n    updateElementStartTimeWithRipple: (trackId, elementId, newStartTime) => {\n      const { _tracks, rippleEditingEnabled } = get();\n\n      if (!rippleEditingEnabled) {\n        get().updateElementStartTime(trackId, elementId, newStartTime);\n        return;\n      }\n\n      const track = _tracks.find((t) => t.id === trackId);\n      const element = track?.elements.find((e) => e.id === elementId);\n\n      if (!element || !track) return;\n\n      get().pushHistory();\n\n      const oldStartTime = element.startTime;\n      const oldEndTime =\n        element.startTime +\n        (element.duration - element.trimStart - element.trimEnd);\n      const newEndTime =\n        newStartTime + (element.duration - element.trimStart - element.trimEnd);\n      const timeDelta = newStartTime - oldStartTime;\n\n      const updatedTracks = _tracks.map((currentTrack) => {\n        const shouldApplyRipple = currentTrack.id === trackId;\n\n        const updatedElements = currentTrack.elements.map((currentElement) => {\n          if (currentElement.id === elementId && currentTrack.id === trackId) {\n            return { ...currentElement, startTime: Math.max(0, newStartTime) };\n          }\n\n          if (!shouldApplyRipple) {\n            return currentElement;\n          }\n\n          const currentElementStart = currentElement.startTime;\n          const currentElementEnd =\n            currentElement.startTime +\n            (currentElement.duration -\n              currentElement.trimStart -\n              currentElement.trimEnd);\n\n          if (timeDelta > 0) {\n            if (currentElementStart >= oldEndTime) {\n              return {\n                ...currentElement,\n                startTime: currentElementStart + timeDelta,\n              };\n            }\n          } else if (timeDelta < 0) {\n            if (\n              currentElementStart >= newEndTime &&\n              currentElementStart >= oldStartTime\n            ) {\n              return {\n                ...currentElement,\n                startTime: Math.max(0, currentElementStart + timeDelta),\n              };\n            }\n          }\n\n          return currentElement;\n        });\n\n        const hasOverlaps = checkElementOverlaps(updatedElements);\n        if (hasOverlaps) {\n          const resolvedElements = resolveElementOverlaps(updatedElements);\n          return { ...currentTrack, elements: resolvedElements };\n        }\n\n        return { ...currentTrack, elements: updatedElements };\n      });\n\n      updateTracksAndSave(updatedTracks);\n    },\n\n    toggleTrackMute: (trackId) => {\n      get().pushHistory();\n      updateTracksAndSave(\n        get()._tracks.map((track) =>\n          track.id === trackId ? { ...track, muted: !track.muted } : track\n        )\n      );\n    },\n\n    updateTextElement: (trackId, elementId, updates) => {\n      get().pushHistory();\n      updateTracksAndSave(\n        get()._tracks.map((track) =>\n          track.id === trackId\n            ? {\n                ...track,\n                elements: track.elements.map((element) =>\n                  element.id === elementId && element.type === \"text\"\n                    ? { ...element, ...updates }\n                    : element\n                ),\n              }\n            : track\n        )\n      );\n    },\n\n    // Split element and keep only the left portion\n    splitAndKeepLeft: (trackId, elementId, splitTime) => {\n      const { _tracks } = get();\n      const track = _tracks.find((t) => t.id === trackId);\n      const element = track?.elements.find((c) => c.id === elementId);\n\n      if (!element) return;\n\n      const effectiveStart = element.startTime;\n      const effectiveEnd =\n        element.startTime +\n        (element.duration - element.trimStart - element.trimEnd);\n\n      if (splitTime <= effectiveStart || splitTime >= effectiveEnd) return;\n\n      get().pushHistory();\n\n      const relativeTime = splitTime - element.startTime;\n      const durationToRemove =\n        element.duration - element.trimStart - element.trimEnd - relativeTime;\n\n      updateTracksAndSave(\n        get()._tracks.map((track) =>\n          track.id === trackId\n            ? {\n                ...track,\n                elements: track.elements.map((c) =>\n                  c.id === elementId\n                    ? {\n                        ...c,\n                        trimEnd: c.trimEnd + durationToRemove,\n                        name: getElementNameWithSuffix(c.name, \"left\"),\n                      }\n                    : c\n                ),\n              }\n            : track\n        )\n      );\n    },\n\n    // Split element and keep only the right portion\n    splitAndKeepRight: (trackId, elementId, splitTime) => {\n      const { _tracks } = get();\n      const track = _tracks.find((t) => t.id === trackId);\n      const element = track?.elements.find((c) => c.id === elementId);\n\n      if (!element) return;\n\n      const effectiveStart = element.startTime;\n      const effectiveEnd =\n        element.startTime +\n        (element.duration - element.trimStart - element.trimEnd);\n\n      if (splitTime <= effectiveStart || splitTime >= effectiveEnd) return;\n\n      get().pushHistory();\n\n      const relativeTime = splitTime - element.startTime;\n\n      updateTracksAndSave(\n        get()._tracks.map((track) =>\n          track.id === trackId\n            ? {\n                ...track,\n                elements: track.elements.map((c) =>\n                  c.id === elementId\n                    ? {\n                        ...c,\n                        startTime: splitTime,\n                        trimStart: c.trimStart + relativeTime,\n                        name: getElementNameWithSuffix(c.name, \"right\"),\n                      }\n                    : c\n                ),\n              }\n            : track\n        )\n      );\n    },\n\n    // Extract audio from video element to an audio track\n    separateAudio: (trackId, elementId) => {\n      const { _tracks } = get();\n      const track = _tracks.find((t) => t.id === trackId);\n      const element = track?.elements.find((c) => c.id === elementId);\n\n      if (!element || track?.type !== \"media\") return null;\n\n      get().pushHistory();\n\n      const existingAudioTrack = _tracks.find((t) => t.type === \"audio\");\n      const audioElementId = generateUUID();\n\n      if (existingAudioTrack) {\n        updateTracksAndSave(\n          get()._tracks.map((track) =>\n            track.id === existingAudioTrack.id\n              ? {\n                  ...track,\n                  elements: [\n                    ...track.elements,\n                    {\n                      ...element,\n                      id: audioElementId,\n                      name: getElementNameWithSuffix(element.name, \"audio\"),\n                    },\n                  ],\n                }\n              : track\n          )\n        );\n      } else {\n        const newAudioTrack: TimelineTrack = {\n          id: generateUUID(),\n          name: \"Audio Track\",\n          type: \"audio\",\n          elements: [\n            {\n              ...element,\n              id: audioElementId,\n              name: getElementNameWithSuffix(element.name, \"audio\"),\n            },\n          ],\n          muted: false,\n        };\n\n        updateTracksAndSave([...get()._tracks, newAudioTrack]);\n      }\n\n      return audioElementId;\n    },\n\n    // Replace media for an element\n    replaceElementMedia: async (\n      trackId: string,\n      elementId: string,\n      newFile: File\n    ): Promise<{ success: boolean; error?: string }> => {\n      const { _tracks } = get();\n      const track = _tracks.find((t) => t.id === trackId);\n      const element = track?.elements.find((c) => c.id === elementId);\n\n      if (!element) {\n        return { success: false, error: \"Timeline element not found\" };\n      }\n\n      if (element.type !== \"media\") {\n        return {\n          success: false,\n          error: \"Replace is only available for media clips\",\n        };\n      }\n\n      try {\n        const mediaStore = useMediaStore.getState();\n        const projectStore = useProjectStore.getState();\n\n        if (!projectStore.activeProject) {\n          return { success: false, error: \"No active project found\" };\n        }\n\n        const {\n          getFileType,\n          getImageDimensions,\n          generateVideoThumbnail,\n          getMediaDuration,\n        } = await import(\"./media-store\");\n\n        const fileType = getFileType(newFile);\n        if (!fileType) {\n          return {\n            success: false,\n            error:\n              \"Unsupported file type. Please select a video, audio, or image file.\",\n          };\n        }\n\n        const mediaData: Omit<MediaFile, \"id\"> = {\n          name: newFile.name,\n          type: fileType as MediaType,\n          file: newFile,\n          url: URL.createObjectURL(newFile),\n        };\n\n        try {\n          if (fileType === \"image\") {\n            const { width, height } = await getImageDimensions(newFile);\n            mediaData.width = width;\n            mediaData.height = height;\n          } else if (fileType === \"video\") {\n            const [duration, { thumbnailUrl, width, height }] =\n              await Promise.all([\n                getMediaDuration(newFile),\n                generateVideoThumbnail(newFile),\n              ]);\n            mediaData.duration = duration;\n            mediaData.thumbnailUrl = thumbnailUrl;\n            mediaData.width = width;\n            mediaData.height = height;\n          } else if (fileType === \"audio\") {\n            mediaData.duration = await getMediaDuration(newFile);\n          }\n        } catch (error) {\n          return {\n            success: false,\n            error: `Failed to process ${fileType} file: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n          };\n        }\n\n        try {\n          await mediaStore.addMediaFile(\n            projectStore.activeProject.id,\n            mediaData\n          );\n        } catch (error) {\n          return {\n            success: false,\n            error: `Failed to add media to project: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n          };\n        }\n\n        const newMediaItem = mediaStore.mediaFiles.find(\n          (item) => item.file === newFile\n        );\n\n        if (!newMediaItem) {\n          return {\n            success: false,\n            error: \"Failed to create media item in project. Please try again.\",\n          };\n        }\n\n        get().pushHistory();\n\n        updateTracksAndSave(\n          _tracks.map((track) =>\n            track.id === trackId\n              ? {\n                  ...track,\n                  elements: track.elements.map((c) =>\n                    c.id === elementId\n                      ? {\n                          ...c,\n                          mediaId: newMediaItem.id,\n                          name: newMediaItem.name,\n                          duration: newMediaItem.duration || c.duration,\n                        }\n                      : c\n                  ),\n                }\n              : track\n          )\n        );\n\n        return { success: true };\n      } catch (error) {\n        console.error(\"Failed to replace element media:\", error);\n        return {\n          success: false,\n          error: `Unexpected error: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n        };\n      }\n    },\n\n    getTotalDuration: () => {\n      const { _tracks } = get();\n      if (_tracks.length === 0) return 0;\n\n      const trackEndTimes = _tracks.map((track) =>\n        track.elements.reduce((maxEnd, element) => {\n          const elementEnd =\n            element.startTime +\n            element.duration -\n            element.trimStart -\n            element.trimEnd;\n          return Math.max(maxEnd, elementEnd);\n        }, 0)\n      );\n\n      return Math.max(...trackEndTimes, 0);\n    },\n\n    getProjectThumbnail: async (projectId) => {\n      try {\n        const project = await storageService.loadProject({ id: projectId });\n        if (!project) return null;\n\n        // For scene-based projects, use main scene timeline\n        // For legacy projects, use legacy timeline format\n        let sceneId: string | undefined;\n        if (project.scenes && project.scenes.length > 0) {\n          const mainScene = project.scenes.find((s) => s.isMain);\n          sceneId = mainScene?.id;\n        }\n\n        const tracks = await storageService.loadTimeline({\n          projectId,\n          sceneId,\n        });\n        const mediaItems = await storageService.loadAllMediaFiles({\n          projectId,\n        });\n\n        if (!tracks || !mediaItems.length) return null;\n\n        const firstMediaElement = tracks\n          .flatMap((track) => track.elements)\n          .filter((element) => element.type === \"media\")\n          .sort((a, b) => a.startTime - b.startTime)[0];\n\n        if (!firstMediaElement) return null;\n\n        const mediaFile = mediaItems.find(\n          (item) => item.id === firstMediaElement.mediaId\n        );\n        if (!mediaFile) return null;\n\n        if (mediaFile.type === \"video\" && mediaFile.file) {\n          const { generateVideoThumbnail } = await import(\n            \"@/stores/media-store\"\n          );\n          const { thumbnailUrl } = await generateVideoThumbnail(mediaFile.file);\n          return thumbnailUrl;\n        }\n        if (mediaFile.type === \"image\" && mediaFile.url) {\n          return mediaFile.url;\n        }\n\n        return null;\n      } catch (error) {\n        console.error(\"Failed to get project thumbnail:\", error);\n        return null;\n      }\n    },\n\n    redo: () => {\n      const { redoStack } = get();\n      if (redoStack.length === 0) return;\n      const next = redoStack[redoStack.length - 1];\n      updateTracksAndSave(next);\n      set({ redoStack: redoStack.slice(0, -1) });\n    },\n\n    dragState: {\n      isDragging: false,\n      elementId: null,\n      trackId: null,\n      startMouseX: 0,\n      startElementTime: 0,\n      clickOffsetTime: 0,\n      currentTime: 0,\n    },\n\n    setDragState: (dragState) =>\n      set((state) => ({\n        dragState: { ...state.dragState, ...dragState },\n      })),\n\n    startDrag: (\n      elementId,\n      trackId,\n      startMouseX,\n      startElementTime,\n      clickOffsetTime\n    ) => {\n      set({\n        dragState: {\n          isDragging: true,\n          elementId,\n          trackId,\n          startMouseX,\n          startElementTime,\n          clickOffsetTime,\n          currentTime: startElementTime,\n        },\n      });\n    },\n\n    updateDragTime: (currentTime) => {\n      set((state) => ({\n        dragState: {\n          ...state.dragState,\n          currentTime,\n        },\n      }));\n    },\n\n    endDrag: () => {\n      set({\n        dragState: {\n          isDragging: false,\n          elementId: null,\n          trackId: null,\n          startMouseX: 0,\n          startElementTime: 0,\n          clickOffsetTime: 0,\n          currentTime: 0,\n        },\n      });\n    },\n\n    loadProjectTimeline: async ({\n      projectId,\n      sceneId,\n    }: {\n      projectId: string;\n      sceneId?: string;\n    }) => {\n      try {\n        const tracks = await storageService.loadTimeline({\n          projectId,\n          sceneId,\n        });\n\n        if (tracks) {\n          updateTracks(tracks);\n        } else {\n          const defaultTracks = ensureMainTrack([]);\n          updateTracks(defaultTracks);\n        }\n        set({ history: [], redoStack: [] });\n      } catch (error) {\n        console.error(\"Failed to load timeline:\", error);\n        const defaultTracks = ensureMainTrack([]);\n        updateTracks(defaultTracks);\n        set({ history: [], redoStack: [] });\n      }\n    },\n\n    saveProjectTimeline: async ({\n      projectId,\n      sceneId,\n    }: {\n      projectId: string;\n      sceneId?: string;\n    }) => {\n      const { _tracks } = get();\n      try {\n        await storageService.saveTimeline({\n          projectId,\n          tracks: _tracks,\n          sceneId,\n        });\n      } catch (error) {\n        console.error(\"Failed to save timeline:\", error);\n      }\n    },\n\n    clearTimeline: () => {\n      const defaultTracks = ensureMainTrack([]);\n      updateTracks(defaultTracks);\n      set({\n        history: [],\n        redoStack: [],\n        selectedElements: [],\n        clipboard: null,\n      });\n    },\n\n    // Snapping actions\n    toggleSnapping: () => {\n      set((state) => ({ snappingEnabled: !state.snappingEnabled }));\n    },\n\n    // Ripple editing functions\n    toggleRippleEditing: () => {\n      set((state) => ({\n        rippleEditingEnabled: !state.rippleEditingEnabled,\n      }));\n    },\n\n    checkElementOverlap: (trackId, startTime, duration, excludeElementId) => {\n      const track = get()._tracks.find((t) => t.id === trackId);\n      if (!track) return false;\n\n      const overlap = track.elements.some((element) => {\n        const elementEnd =\n          element.startTime +\n          element.duration -\n          element.trimStart -\n          element.trimEnd;\n\n        if (element.id === excludeElementId) {\n          return false;\n        }\n\n        return (\n          (startTime >= element.startTime && startTime < elementEnd) ||\n          (startTime + duration > element.startTime &&\n            startTime + duration <= elementEnd) ||\n          (startTime < element.startTime && startTime + duration > elementEnd)\n        );\n      });\n      return overlap;\n    },\n\n    findOrCreateTrack: (trackType) => {\n      if (trackType === \"text\") {\n        return get().insertTrackAt(trackType, 0);\n      }\n\n      const existingTrack = get()._tracks.find((t) => t.type === trackType);\n      if (existingTrack) {\n        return existingTrack.id;\n      }\n\n      return get().addTrack(trackType);\n    },\n\n    addElementAtTime: (item: MediaFile | TextElement, currentTime = 0) => {\n      if (item.type === \"text\") {\n        const targetTrackId = get().insertTrackAt(\"text\", 0);\n        get().addElementToTrack(\n          targetTrackId,\n          buildTextElement(item, currentTime)\n        );\n        return true;\n      }\n\n      const media = item as MediaFile;\n      const trackType = media.type === \"audio\" ? \"audio\" : \"media\";\n      const targetTrackId = get().insertTrackAt(trackType, 0);\n      get().addElementToTrack(targetTrackId, {\n        type: \"media\",\n        mediaId: media.id,\n        name: media.name,\n        duration: media.duration || TIMELINE_CONSTANTS.DEFAULT_IMAGE_DURATION,\n        startTime: currentTime,\n        trimStart: 0,\n        trimEnd: 0,\n        muted: false,\n      });\n      return true;\n    },\n\n    addElementToNewTrack: (item) => {\n      if (item.type === \"text\") {\n        const targetTrackId = get().insertTrackAt(\"text\", 0);\n        get().addElementToTrack(\n          targetTrackId,\n          buildTextElement(item as TextElement | DragData, 0)\n        );\n        return true;\n      }\n\n      const media = item as MediaFile;\n      const trackType = media.type === \"audio\" ? \"audio\" : \"media\";\n      const targetTrackId = get().insertTrackAt(trackType, 0);\n      get().addElementToTrack(targetTrackId, {\n        type: \"media\",\n        mediaId: media.id,\n        name: media.name,\n        duration: media.duration || TIMELINE_CONSTANTS.DEFAULT_IMAGE_DURATION,\n        startTime: 0,\n        trimStart: 0,\n        trimEnd: 0,\n        muted: false,\n      });\n      return true;\n    },\n\n    copySelected: () => {\n      const { selectedElements, _tracks } = get();\n      if (selectedElements.length === 0) return;\n\n      const items: Array<{\n        trackType: TrackType;\n        element: CreateTimelineElement;\n      }> = [];\n\n      for (const { trackId, elementId } of selectedElements) {\n        const track = _tracks.find((t) => t.id === trackId);\n        const element = track?.elements.find((e) => e.id === elementId);\n        if (!track || !element) continue;\n\n        // Prepare a creation-friendly copy without id\n        const { id: _id, ...rest } = element as TimelineElement;\n        items.push({\n          trackType: track.type,\n          element: rest as CreateTimelineElement,\n        });\n      }\n\n      set({ clipboard: { items } });\n    },\n\n    pasteAtTime: (time) => {\n      const { clipboard } = get();\n      if (!clipboard || clipboard.items.length === 0) return;\n\n      // Determine reference start time offset based on earliest element in clipboard\n      const minStart = Math.min(\n        ...clipboard.items.map((x) => x.element.startTime)\n      );\n\n      get().pushHistory();\n\n      for (const item of clipboard.items) {\n        const targetTrackId = get().findOrCreateTrack(item.trackType);\n        const relativeOffset = item.element.startTime - minStart;\n        const startTime = Math.max(0, time + relativeOffset);\n\n        // Ensure no overlap on target track\n        const duration =\n          item.element.duration - item.element.trimStart - item.element.trimEnd;\n        const hasOverlap = get().checkElementOverlap(\n          targetTrackId,\n          startTime,\n          duration\n        );\n        if (hasOverlap) {\n          // If overlap, nudge forward slightly until free (simple resolve)\n          let candidate = startTime;\n          let safety = 0;\n          while (\n            get().checkElementOverlap(targetTrackId, candidate, duration) &&\n            safety < 1000\n          ) {\n            candidate += 0.01;\n            safety += 1;\n          }\n          get().addElementToTrack(targetTrackId, {\n            ...item.element,\n            startTime: candidate,\n          });\n        } else {\n          get().addElementToTrack(targetTrackId, {\n            ...item.element,\n            startTime,\n          });\n        }\n      }\n    },\n\n    deleteSelected: (trackId?: string, elementId?: string) => {\n      const { selectedElements, rippleEditingEnabled } = get();\n\n      const elementsToDelete =\n        trackId && elementId\n          ? [{ trackId, elementId }]\n          : selectedElements.length > 0\n            ? selectedElements\n            : [];\n\n      if (elementsToDelete.length === 0) return;\n\n      get().pushHistory();\n\n      if (rippleEditingEnabled) {\n        for (const { trackId: tId, elementId: eId } of elementsToDelete) {\n          get().removeElementFromTrackWithRipple(tId, eId, false);\n        }\n      } else {\n        updateTracksAndSave(\n          get()\n            ._tracks.map((track) => ({\n              ...track,\n              elements: track.elements.filter(\n                (element) =>\n                  !elementsToDelete.some(\n                    ({ trackId: tId, elementId: eId }) =>\n                      track.id === tId && element.id === eId\n                  )\n              ),\n            }))\n            .filter((track) => track.elements.length > 0)\n        );\n      }\n\n      get().clearSelectedElements();\n    },\n\n    splitSelected: (splitTime, trackId?: string, elementId?: string) => {\n      const { selectedElements, _tracks } = get();\n\n      const elementsToProcess =\n        trackId && elementId\n          ? [{ trackId, elementId }]\n          : selectedElements.length > 0\n            ? selectedElements\n            : [];\n\n      if (elementsToProcess.length === 0) return;\n\n      const elementsToSplit: Array<{\n        trackId: string;\n        elementId: string;\n        element: TimelineElement;\n      }> = [];\n\n      for (const { trackId: tId, elementId: eId } of elementsToProcess) {\n        const track = _tracks.find((t) => t.id === tId);\n        const element = track?.elements.find((e) => e.id === eId);\n        if (!track || !element) continue;\n\n        const effectiveStart = element.startTime;\n        const effectiveEnd =\n          element.startTime +\n          (element.duration - element.trimStart - element.trimEnd);\n\n        if (splitTime > effectiveStart && splitTime < effectiveEnd) {\n          elementsToSplit.push({ trackId: tId, elementId: eId, element });\n        }\n      }\n\n      if (elementsToSplit.length === 0) {\n        const { toast } = require(\"sonner\");\n        const isMultiple = elementsToProcess.length > 1;\n        toast.error(\n          isMultiple\n            ? \"Playhead must be within all selected elements to split\"\n            : \"Playhead must be within element to split\"\n        );\n        return;\n      }\n\n      get().pushHistory();\n\n      updateTracksAndSave(\n        get()._tracks.map((track) => {\n          const elementsToSplitInTrack = elementsToSplit.filter(\n            ({ trackId: tId }) => tId === track.id\n          );\n\n          if (elementsToSplitInTrack.length === 0) return track;\n\n          return {\n            ...track,\n            elements: track.elements.flatMap((c) => {\n              const elementToSplit = elementsToSplitInTrack.find(\n                ({ elementId: eId }) => eId === c.id\n              );\n\n              if (!elementToSplit) return [c];\n\n              const relativeTime = splitTime - elementToSplit.element.startTime;\n              const firstDuration = relativeTime;\n              const secondDuration =\n                elementToSplit.element.duration -\n                elementToSplit.element.trimStart -\n                elementToSplit.element.trimEnd -\n                relativeTime;\n\n              const secondElementId = generateUUID();\n\n              return [\n                {\n                  ...c,\n                  trimEnd: c.trimEnd + secondDuration,\n                  name: getElementNameWithSuffix(c.name, \"left\"),\n                },\n                {\n                  ...c,\n                  id: secondElementId,\n                  startTime: splitTime,\n                  trimStart: c.trimStart + firstDuration,\n                  name: getElementNameWithSuffix(c.name, \"right\"),\n                },\n              ];\n            }),\n          };\n        })\n      );\n    },\n\n    toggleSelectedHidden: (trackId?: string, elementId?: string) => {\n      const { selectedElements, _tracks } = get();\n\n      const elementsToProcess =\n        trackId && elementId\n          ? [{ trackId, elementId }]\n          : selectedElements.length > 0\n            ? selectedElements\n            : [];\n\n      if (elementsToProcess.length === 0) return;\n\n      get().pushHistory();\n\n      const shouldHide = elementsToProcess.some(\n        ({ trackId: tId, elementId: eId }) => {\n          const track = _tracks.find((t) => t.id === tId);\n          const element = track?.elements.find((e) => e.id === eId);\n          return element && !element.hidden;\n        }\n      );\n\n      updateTracksAndSave(\n        _tracks.map((track) => ({\n          ...track,\n          elements: track.elements.map((element) => {\n            const shouldUpdate = elementsToProcess.some(\n              ({ trackId: tId, elementId: eId }) =>\n                track.id === tId && element.id === eId\n            );\n            return shouldUpdate && element.hidden !== shouldHide\n              ? { ...element, hidden: shouldHide }\n              : element;\n          }),\n        }))\n      );\n    },\n\n    toggleSelectedMuted: (trackId?: string, elementId?: string) => {\n      const { selectedElements, _tracks } = get();\n\n      const elementsToProcess =\n        trackId && elementId\n          ? [{ trackId, elementId }]\n          : selectedElements.length > 0\n            ? selectedElements\n            : [];\n\n      if (elementsToProcess.length === 0) return;\n\n      get().pushHistory();\n\n      const audioElements = elementsToProcess.filter(\n        ({ trackId: tId, elementId: eId }) => {\n          const track = _tracks.find((t) => t.id === tId);\n          const element = track?.elements.find((e) => e.id === eId);\n          return element?.type === \"media\";\n        }\n      );\n\n      if (audioElements.length === 0) return;\n\n      const shouldMute = audioElements.some(\n        ({ trackId: tId, elementId: eId }) => {\n          const track = _tracks.find((t) => t.id === tId);\n          const element = track?.elements.find((e) => e.id === eId);\n          return element?.type === \"media\" && !element.muted;\n        }\n      );\n\n      updateTracksAndSave(\n        _tracks.map((track) => ({\n          ...track,\n          elements: track.elements.map((element) => {\n            const shouldUpdate = audioElements.some(\n              ({ trackId: tId, elementId: eId }) =>\n                track.id === tId && element.id === eId\n            );\n            return shouldUpdate &&\n              element.type === \"media\" &&\n              element.muted !== shouldMute\n              ? { ...element, muted: shouldMute }\n              : element;\n          }),\n        }))\n      );\n    },\n\n    duplicateElement: (trackId, elementId) => {\n      const { _tracks } = get();\n      const track = _tracks.find((t) => t.id === trackId);\n      const element = track?.elements.find((e) => e.id === elementId);\n      if (!track || !element) return;\n\n      const { id, ...elementWithoutId } = element;\n      const effectiveDuration =\n        element.duration - element.trimStart - element.trimEnd;\n\n      get().addElementToTrack(trackId, {\n        ...elementWithoutId,\n        name: `${element.name} (copy)`,\n        startTime: element.startTime + effectiveDuration + 0.1,\n      } as CreateTimelineElement);\n    },\n\n    revealElementInMedia: (elementId) => {\n      const {\n        useMediaPanelStore,\n      } = require(\"../components/editor/media-panel/store\");\n      const { requestRevealMedia } = useMediaPanelStore.getState();\n\n      const { _tracks } = get();\n      const element = _tracks\n        .flatMap((track) => track.elements)\n        .find((el) => el.id === elementId);\n\n      if (element?.type === \"media\") {\n        requestRevealMedia(element.mediaId);\n      }\n    },\n\n    replaceElementWithFile: async (trackId, elementId, file) => {\n      try {\n        const result = await get().replaceElementMedia(\n          trackId,\n          elementId,\n          file\n        );\n        if (result.success) {\n          const { toast } = await import(\"sonner\");\n          toast.success(\"Clip replaced successfully\");\n        } else {\n          const { toast } = await import(\"sonner\");\n          toast.error(result.error || \"Failed to replace clip\");\n        }\n      } catch (error) {\n        console.error(\"Unexpected error replacing clip:\", error);\n        const { toast } = await import(\"sonner\");\n        toast.error(\n          `Unexpected error: ${error instanceof Error ? error.message : \"Unknown error\"}`\n        );\n      }\n    },\n\n    getContextMenuState: (trackId, elementId) => {\n      const { selectedElements, _tracks } = get();\n      const { currentTime } = usePlaybackStore.getState();\n      const { mediaFiles } = useMediaStore.getState();\n\n      const isMultipleSelected = selectedElements.length > 1;\n      const isCurrentElementSelected = selectedElements.some(\n        (sel) => sel.trackId === trackId && sel.elementId === elementId\n      );\n\n      const hasAudioElements = selectedElements.some(\n        ({ trackId: tId, elementId: eId }) => {\n          const selectedTrack = _tracks.find((t) => t.id === tId);\n          const selectedElement = selectedTrack?.elements.find(\n            (e) => e.id === eId\n          );\n          if (selectedElement?.type !== \"media\") return false;\n          const mediaElement = selectedElement as MediaElement;\n          const mediaItem = mediaFiles.find(\n            (file: MediaFile) => file.id === mediaElement.mediaId\n          );\n          return mediaItem?.type === \"audio\" || mediaItem?.type === \"video\";\n        }\n      );\n\n      const canSplitSelected = selectedElements.every(\n        ({ trackId: tId, elementId: eId }) => {\n          const selectedTrack = _tracks.find((t) => t.id === tId);\n          const selectedElement = selectedTrack?.elements.find(\n            (e) => e.id === eId\n          );\n          if (!selectedElement) return false;\n          const effectiveStart = selectedElement.startTime;\n          const effectiveEnd =\n            selectedElement.startTime +\n            (selectedElement.duration -\n              selectedElement.trimStart -\n              selectedElement.trimEnd);\n          return currentTime > effectiveStart && currentTime < effectiveEnd;\n        }\n      );\n\n      return {\n        isMultipleSelected,\n        isCurrentElementSelected,\n        hasAudioElements,\n        canSplitSelected,\n        currentTime,\n      };\n    },\n  };\n});\n\nfunction buildTextElement(\n  raw: TextElement | DragData,\n  startTime: number\n): CreateTimelineElement {\n  const t = raw as Partial<TextElement>;\n\n  return {\n    type: \"text\",\n    name: t.name ?? DEFAULT_TEXT_ELEMENT.name,\n    content: t.content ?? DEFAULT_TEXT_ELEMENT.content,\n    duration: t.duration ?? TIMELINE_CONSTANTS.DEFAULT_TEXT_DURATION,\n    startTime,\n    trimStart: 0,\n    trimEnd: 0,\n    fontSize:\n      typeof t.fontSize === \"number\"\n        ? t.fontSize\n        : DEFAULT_TEXT_ELEMENT.fontSize,\n    fontFamily: t.fontFamily ?? DEFAULT_TEXT_ELEMENT.fontFamily,\n    color: t.color ?? DEFAULT_TEXT_ELEMENT.color,\n    backgroundColor: t.backgroundColor ?? DEFAULT_TEXT_ELEMENT.backgroundColor,\n    textAlign: t.textAlign ?? DEFAULT_TEXT_ELEMENT.textAlign,\n    fontWeight: t.fontWeight ?? DEFAULT_TEXT_ELEMENT.fontWeight,\n    fontStyle: t.fontStyle ?? DEFAULT_TEXT_ELEMENT.fontStyle,\n    textDecoration: t.textDecoration ?? DEFAULT_TEXT_ELEMENT.textDecoration,\n    x: typeof t.x === \"number\" ? t.x : DEFAULT_TEXT_ELEMENT.x,\n    y: typeof t.y === \"number\" ? t.y : DEFAULT_TEXT_ELEMENT.y,\n    rotation:\n      typeof t.rotation === \"number\"\n        ? t.rotation\n        : DEFAULT_TEXT_ELEMENT.rotation,\n    opacity:\n      typeof t.opacity === \"number\" ? t.opacity : DEFAULT_TEXT_ELEMENT.opacity,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2688, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/lib/video-cache.ts"],"sourcesContent":["import {\r\n  Input,\r\n  ALL_FORMATS,\r\n  BlobSource,\r\n  CanvasSink,\r\n  WrappedCanvas,\r\n} from \"mediabunny\";\r\n\r\ninterface VideoSinkData {\r\n  sink: CanvasSink;\r\n  iterator: AsyncGenerator<WrappedCanvas, void, unknown> | null;\r\n  currentFrame: WrappedCanvas | null;\r\n  lastTime: number;\r\n}\r\nexport class VideoCache {\r\n  private sinks = new Map<string, VideoSinkData>();\r\n  private initPromises = new Map<string, Promise<void>>();\r\n\r\n  async getFrameAt(\r\n    mediaId: string,\r\n    file: File,\r\n    time: number\r\n  ): Promise<WrappedCanvas | null> {\r\n    await this.ensureSink(mediaId, file);\r\n\r\n    const sinkData = this.sinks.get(mediaId);\r\n    if (!sinkData) return null;\r\n\r\n    if (\r\n      sinkData.currentFrame &&\r\n      this.isFrameValid(sinkData.currentFrame, time)\r\n    ) {\r\n      return sinkData.currentFrame;\r\n    }\r\n\r\n    if (\r\n      sinkData.iterator &&\r\n      sinkData.currentFrame &&\r\n      time >= sinkData.lastTime &&\r\n      time < sinkData.lastTime + 2.0\r\n    ) {\r\n      const frame = await this.iterateToTime(sinkData, time);\r\n      if (frame) return frame;\r\n    }\r\n\r\n    return await this.seekToTime(sinkData, time);\r\n  }\r\n\r\n  private isFrameValid(frame: WrappedCanvas, time: number): boolean {\r\n    return time >= frame.timestamp && time < frame.timestamp + frame.duration;\r\n  }\r\n  private async iterateToTime(\r\n    sinkData: VideoSinkData,\r\n    targetTime: number\r\n  ): Promise<WrappedCanvas | null> {\r\n    if (!sinkData.iterator) return null;\r\n\r\n    try {\r\n      while (true) {\r\n        const { value: frame, done } = await sinkData.iterator.next();\r\n\r\n        if (done || !frame) break;\r\n\r\n        sinkData.currentFrame = frame;\r\n        sinkData.lastTime = frame.timestamp;\r\n\r\n        if (this.isFrameValid(frame, targetTime)) {\r\n          return frame;\r\n        }\r\n\r\n        if (frame.timestamp > targetTime + 1.0) break;\r\n      }\r\n    } catch (error) {\r\n      console.warn(\"Iterator failed, will restart:\", error);\r\n      sinkData.iterator = null;\r\n    }\r\n\r\n    return null;\r\n  }\r\n  private async seekToTime(\r\n    sinkData: VideoSinkData,\r\n    time: number\r\n  ): Promise<WrappedCanvas | null> {\r\n    try {\r\n      if (sinkData.iterator) {\r\n        await sinkData.iterator.return();\r\n        sinkData.iterator = null;\r\n      }\r\n\r\n      sinkData.iterator = sinkData.sink.canvases(time);\r\n      sinkData.lastTime = time;\r\n\r\n      const { value: frame } = await sinkData.iterator.next();\r\n\r\n      if (frame) {\r\n        sinkData.currentFrame = frame;\r\n        return frame;\r\n      }\r\n    } catch (error) {\r\n      console.warn(\"Failed to seek video:\", error);\r\n    }\r\n\r\n    return null;\r\n  }\r\n  private async ensureSink(mediaId: string, file: File): Promise<void> {\r\n    if (this.sinks.has(mediaId)) return;\r\n\r\n    if (this.initPromises.has(mediaId)) {\r\n      await this.initPromises.get(mediaId);\r\n      return;\r\n    }\r\n\r\n    const initPromise = this.initializeSink(mediaId, file);\r\n    this.initPromises.set(mediaId, initPromise);\r\n\r\n    try {\r\n      await initPromise;\r\n    } finally {\r\n      this.initPromises.delete(mediaId);\r\n    }\r\n  }\r\n  private async initializeSink(mediaId: string, file: File): Promise<void> {\r\n    try {\r\n      const input = new Input({\r\n        source: new BlobSource(file),\r\n        formats: ALL_FORMATS,\r\n      });\r\n\r\n      const videoTrack = await input.getPrimaryVideoTrack();\r\n      if (!videoTrack) {\r\n        throw new Error(\"No video track found\");\r\n      }\r\n\r\n      const canDecode = await videoTrack.canDecode();\r\n      if (!canDecode) {\r\n        throw new Error(\"Video codec not supported for decoding\");\r\n      }\r\n\r\n      const sink = new CanvasSink(videoTrack, {\r\n        poolSize: 3,\r\n        fit: \"contain\",\r\n      });\r\n\r\n      this.sinks.set(mediaId, {\r\n        sink,\r\n        iterator: null,\r\n        currentFrame: null,\r\n        lastTime: -1,\r\n      });\r\n    } catch (error) {\r\n      console.error(`Failed to initialize video sink for ${mediaId}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  clearVideo(mediaId: string): void {\r\n    const sinkData = this.sinks.get(mediaId);\r\n    if (sinkData) {\r\n      if (sinkData.iterator) {\r\n        sinkData.iterator.return();\r\n      }\r\n\r\n      this.sinks.delete(mediaId);\r\n    }\r\n\r\n    this.initPromises.delete(mediaId);\r\n  }\r\n\r\n  clearAll(): void {\r\n    for (const [mediaId] of this.sinks) {\r\n      this.clearVideo(mediaId);\r\n    }\r\n  }\r\n\r\n  getStats() {\r\n    return {\r\n      totalSinks: this.sinks.size,\r\n      activeSinks: Array.from(this.sinks.values()).filter((s) => s.iterator)\r\n        .length,\r\n      cachedFrames: Array.from(this.sinks.values()).filter(\r\n        (s) => s.currentFrame\r\n      ).length,\r\n    };\r\n  }\r\n}\r\nexport const videoCache = new VideoCache();\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2824, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/stores/media-store.ts"],"sourcesContent":["import { create } from \"zustand\";\nimport { storageService } from \"@/lib/storage/storage-service\";\nimport { useTimelineStore } from \"./timeline-store\";\nimport { generateUUID } from \"@/lib/utils\";\nimport { MediaType, MediaFile } from \"@/types/media\";\nimport { videoCache } from \"@/lib/video-cache\";\n\ninterface MediaStore {\n  mediaFiles: MediaFile[];\n  isLoading: boolean;\n\n  // Actions\n  addMediaFile: (\n    projectId: string,\n    file: Omit<MediaFile, \"id\">\n  ) => Promise<void>;\n  removeMediaFile: (projectId: string, id: string) => Promise<void>;\n  loadProjectMedia: (projectId: string) => Promise<void>;\n  clearProjectMedia: (projectId: string) => Promise<void>;\n  clearAllMedia: () => void;\n}\n\n// Helper function to determine file type\nexport const getFileType = (file: File): MediaType | null => {\n  const { type } = file;\n\n  if (type.startsWith(\"image/\")) {\n    return \"image\";\n  }\n  if (type.startsWith(\"video/\")) {\n    return \"video\";\n  }\n  if (type.startsWith(\"audio/\")) {\n    return \"audio\";\n  }\n\n  return null;\n};\n\n// Helper function to get image dimensions\nexport const getImageDimensions = (\n  file: File\n): Promise<{ width: number; height: number }> => {\n  return new Promise((resolve, reject) => {\n    const img = new window.Image();\n\n    img.addEventListener(\"load\", () => {\n      const width = img.naturalWidth;\n      const height = img.naturalHeight;\n      resolve({ width, height });\n      img.remove();\n    });\n\n    img.addEventListener(\"error\", () => {\n      reject(new Error(\"Could not load image\"));\n      img.remove();\n    });\n\n    img.src = URL.createObjectURL(file);\n  });\n};\n\n// Helper function to generate video thumbnail and get dimensions\nexport const generateVideoThumbnail = (\n  file: File\n): Promise<{ thumbnailUrl: string; width: number; height: number }> => {\n  return new Promise((resolve, reject) => {\n    const video = document.createElement(\"video\") as HTMLVideoElement;\n    const canvas = document.createElement(\"canvas\") as HTMLCanvasElement;\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) {\n      reject(new Error(\"Could not get canvas context\"));\n      return;\n    }\n\n    video.addEventListener(\"loadedmetadata\", () => {\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n\n      // Seek to 1 second or 10% of duration, whichever is smaller\n      video.currentTime = Math.min(1, video.duration * 0.1);\n    });\n\n    video.addEventListener(\"seeked\", () => {\n      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n      const thumbnailUrl = canvas.toDataURL(\"image/jpeg\", 0.8);\n      const width = video.videoWidth;\n      const height = video.videoHeight;\n\n      resolve({ thumbnailUrl, width, height });\n\n      // Cleanup\n      video.remove();\n      canvas.remove();\n    });\n\n    video.addEventListener(\"error\", () => {\n      reject(new Error(\"Could not load video\"));\n      video.remove();\n      canvas.remove();\n    });\n\n    video.src = URL.createObjectURL(file);\n    video.load();\n  });\n};\n\n// Helper function to get media duration\nexport const getMediaDuration = (file: File): Promise<number> => {\n  return new Promise((resolve, reject) => {\n    const element = document.createElement(\n      file.type.startsWith(\"video/\") ? \"video\" : \"audio\"\n    ) as HTMLVideoElement;\n\n    element.addEventListener(\"loadedmetadata\", () => {\n      resolve(element.duration);\n      element.remove();\n    });\n\n    element.addEventListener(\"error\", () => {\n      reject(new Error(\"Could not load media\"));\n      element.remove();\n    });\n\n    element.src = URL.createObjectURL(file);\n    element.load();\n  });\n};\n\nexport const getMediaAspectRatio = (item: MediaFile): number => {\n  if (item.width && item.height) {\n    return item.width / item.height;\n  }\n  return 16 / 9; // Default aspect ratio\n};\n\nexport const useMediaStore = create<MediaStore>((set, get) => ({\n  mediaFiles: [],\n  isLoading: false,\n\n  addMediaFile: async (projectId, file) => {\n    const newItem: MediaFile = {\n      ...file,\n      id: generateUUID(),\n    };\n\n    // Add to local state immediately for UI responsiveness\n    set((state) => ({\n      mediaFiles: [...state.mediaFiles, newItem],\n    }));\n\n    // Save to persistent storage in background\n    try {\n      await storageService.saveMediaFile({ projectId, mediaItem: newItem });\n    } catch (error) {\n      console.error(\"Failed to save media item:\", error);\n      // Remove from local state if save failed\n      set((state) => ({\n        mediaFiles: state.mediaFiles.filter((media) => media.id !== newItem.id),\n      }));\n    }\n  },\n\n  removeMediaFile: async (projectId: string, id: string) => {\n    const state = get();\n    const item = state.mediaFiles.find((media) => media.id === id);\n\n    videoCache.clearVideo(id);\n\n    // Cleanup object URLs to prevent memory leaks\n    if (item?.url) {\n      URL.revokeObjectURL(item.url);\n      if (item.thumbnailUrl) {\n        URL.revokeObjectURL(item.thumbnailUrl);\n      }\n    }\n\n    // 1) Remove from local state immediately\n    set((state) => ({\n      mediaFiles: state.mediaFiles.filter((media) => media.id !== id),\n    }));\n\n    // 2) Cascade into the timeline: remove any elements using this media ID\n    const timeline = useTimelineStore.getState();\n    const { tracks, deleteSelected, setSelectedElements } = timeline;\n\n    // Find all elements that reference this media\n    const elementsToRemove: Array<{ trackId: string; elementId: string }> = [];\n    for (const track of tracks) {\n      for (const el of track.elements) {\n        if (el.type === \"media\" && el.mediaId === id) {\n          elementsToRemove.push({ trackId: track.id, elementId: el.id });\n        }\n      }\n    }\n\n    // If there are elements to remove, use unified delete function\n    if (elementsToRemove.length > 0) {\n      setSelectedElements(elementsToRemove);\n      deleteSelected();\n    }\n\n    // 3) Remove from persistent storage\n    try {\n      await storageService.deleteMediaFile({ projectId, id });\n    } catch (error) {\n      console.error(\"Failed to delete media item:\", error);\n    }\n  },\n\n  loadProjectMedia: async (projectId) => {\n    set({ isLoading: true });\n\n    try {\n      const mediaItems = await storageService.loadAllMediaFiles({ projectId });\n\n      // Regenerate thumbnails for video items\n      const updatedMediaItems = await Promise.all(\n        mediaItems.map(async (item) => {\n          if (item.type === \"video\" && item.file) {\n            try {\n              const { thumbnailUrl, width, height } =\n                await generateVideoThumbnail(item.file);\n              return {\n                ...item,\n                thumbnailUrl,\n                width: width || item.width,\n                height: height || item.height,\n              };\n            } catch (error) {\n              console.error(\n                `Failed to regenerate thumbnail for video ${item.id}:`,\n                error\n              );\n              return item;\n            }\n          }\n          return item;\n        })\n      );\n\n      set({ mediaFiles: updatedMediaItems });\n    } catch (error) {\n      console.error(\"Failed to load media items:\", error);\n    } finally {\n      set({ isLoading: false });\n    }\n  },\n\n  clearProjectMedia: async (projectId) => {\n    const state = get();\n\n    // Cleanup all object URLs\n    state.mediaFiles.forEach((item) => {\n      if (item.url) {\n        URL.revokeObjectURL(item.url);\n      }\n      if (item.thumbnailUrl) {\n        URL.revokeObjectURL(item.thumbnailUrl);\n      }\n    });\n\n    // Clear local state\n    set({ mediaFiles: [] });\n\n    // Clear persistent storage\n    try {\n      const mediaIds = state.mediaFiles.map((item) => item.id);\n      await Promise.all(\n        mediaIds.map((id) => storageService.deleteMediaFile({ projectId, id }))\n      );\n    } catch (error) {\n      console.error(\"Failed to clear media items from storage:\", error);\n    }\n  },\n\n  clearAllMedia: () => {\n    const state = get();\n\n    videoCache.clearAll();\n\n    // Cleanup all object URLs\n    state.mediaFiles.forEach((item) => {\n      if (item.url) {\n        URL.revokeObjectURL(item.url);\n      }\n      if (item.thumbnailUrl) {\n        URL.revokeObjectURL(item.thumbnailUrl);\n      }\n    });\n\n    // Clear local state\n    set({ mediaFiles: [] });\n  },\n}));\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AAEA;;;;;;AAkBO,MAAM,cAAc,CAAC;IAC1B,MAAM,EAAE,IAAI,EAAE,GAAG;IAEjB,IAAI,KAAK,UAAU,CAAC,WAAW;QAC7B,OAAO;IACT;IACA,IAAI,KAAK,UAAU,CAAC,WAAW;QAC7B,OAAO;IACT;IACA,IAAI,KAAK,UAAU,CAAC,WAAW;QAC7B,OAAO;IACT;IAEA,OAAO;AACT;AAGO,MAAM,qBAAqB,CAChC;IAEA,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,MAAM,MAAM,IAAI,OAAO,KAAK;QAE5B,IAAI,gBAAgB,CAAC,QAAQ;YAC3B,MAAM,QAAQ,IAAI,YAAY;YAC9B,MAAM,SAAS,IAAI,aAAa;YAChC,QAAQ;gBAAE;gBAAO;YAAO;YACxB,IAAI,MAAM;QACZ;QAEA,IAAI,gBAAgB,CAAC,SAAS;YAC5B,OAAO,IAAI,MAAM;YACjB,IAAI,MAAM;QACZ;QAEA,IAAI,GAAG,GAAG,IAAI,eAAe,CAAC;IAChC;AACF;AAGO,MAAM,yBAAyB,CACpC;IAEA,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,MAAM,QAAQ,SAAS,aAAa,CAAC;QACrC,MAAM,SAAS,SAAS,aAAa,CAAC;QACtC,MAAM,MAAM,OAAO,UAAU,CAAC;QAE9B,IAAI,CAAC,KAAK;YACR,OAAO,IAAI,MAAM;YACjB;QACF;QAEA,MAAM,gBAAgB,CAAC,kBAAkB;YACvC,OAAO,KAAK,GAAG,MAAM,UAAU;YAC/B,OAAO,MAAM,GAAG,MAAM,WAAW;YAEjC,4DAA4D;YAC5D,MAAM,WAAW,GAAG,KAAK,GAAG,CAAC,GAAG,MAAM,QAAQ,GAAG;QACnD;QAEA,MAAM,gBAAgB,CAAC,UAAU;YAC/B,IAAI,SAAS,CAAC,OAAO,GAAG,GAAG,OAAO,KAAK,EAAE,OAAO,MAAM;YACtD,MAAM,eAAe,OAAO,SAAS,CAAC,cAAc;YACpD,MAAM,QAAQ,MAAM,UAAU;YAC9B,MAAM,SAAS,MAAM,WAAW;YAEhC,QAAQ;gBAAE;gBAAc;gBAAO;YAAO;YAEtC,UAAU;YACV,MAAM,MAAM;YACZ,OAAO,MAAM;QACf;QAEA,MAAM,gBAAgB,CAAC,SAAS;YAC9B,OAAO,IAAI,MAAM;YACjB,MAAM,MAAM;YACZ,OAAO,MAAM;QACf;QAEA,MAAM,GAAG,GAAG,IAAI,eAAe,CAAC;QAChC,MAAM,IAAI;IACZ;AACF;AAGO,MAAM,mBAAmB,CAAC;IAC/B,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,MAAM,UAAU,SAAS,aAAa,CACpC,KAAK,IAAI,CAAC,UAAU,CAAC,YAAY,UAAU;QAG7C,QAAQ,gBAAgB,CAAC,kBAAkB;YACzC,QAAQ,QAAQ,QAAQ;YACxB,QAAQ,MAAM;QAChB;QAEA,QAAQ,gBAAgB,CAAC,SAAS;YAChC,OAAO,IAAI,MAAM;YACjB,QAAQ,MAAM;QAChB;QAEA,QAAQ,GAAG,GAAG,IAAI,eAAe,CAAC;QAClC,QAAQ,IAAI;IACd;AACF;AAEO,MAAM,sBAAsB,CAAC;IAClC,IAAI,KAAK,KAAK,IAAI,KAAK,MAAM,EAAE;QAC7B,OAAO,KAAK,KAAK,GAAG,KAAK,MAAM;IACjC;IACA,OAAO,KAAK,GAAG,uBAAuB;AACxC;AAEO,MAAM,gBAAgB,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD,EAAc,CAAC,KAAK,MAAQ,CAAC;QAC7D,YAAY,EAAE;QACd,WAAW;QAEX,cAAc,OAAO,WAAW;YAC9B,MAAM,UAAqB;gBACzB,GAAG,IAAI;gBACP,IAAI,CAAA,GAAA,kIAAA,CAAA,eAAY,AAAD;YACjB;YAEA,uDAAuD;YACvD,IAAI,CAAC,QAAU,CAAC;oBACd,YAAY;2BAAI,MAAM,UAAU;wBAAE;qBAAQ;gBAC5C,CAAC;YAED,2CAA2C;YAC3C,IAAI;gBACF,MAAM,0JAAA,CAAA,iBAAc,CAAC,aAAa,CAAC;oBAAE;oBAAW,WAAW;gBAAQ;YACrE,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,8BAA8B;gBAC5C,yCAAyC;gBACzC,IAAI,CAAC,QAAU,CAAC;wBACd,YAAY,MAAM,UAAU,CAAC,MAAM,CAAC,CAAC,QAAU,MAAM,EAAE,KAAK,QAAQ,EAAE;oBACxE,CAAC;YACH;QACF;QAEA,iBAAiB,OAAO,WAAmB;YACzC,MAAM,QAAQ;YACd,MAAM,OAAO,MAAM,UAAU,CAAC,IAAI,CAAC,CAAC,QAAU,MAAM,EAAE,KAAK;YAE3D,2IAAA,CAAA,aAAU,CAAC,UAAU,CAAC;YAEtB,8CAA8C;YAC9C,IAAI,MAAM,KAAK;gBACb,IAAI,eAAe,CAAC,KAAK,GAAG;gBAC5B,IAAI,KAAK,YAAY,EAAE;oBACrB,IAAI,eAAe,CAAC,KAAK,YAAY;gBACvC;YACF;YAEA,yCAAyC;YACzC,IAAI,CAAC,QAAU,CAAC;oBACd,YAAY,MAAM,UAAU,CAAC,MAAM,CAAC,CAAC,QAAU,MAAM,EAAE,KAAK;gBAC9D,CAAC;YAED,wEAAwE;YACxE,MAAM,WAAW,iJAAA,CAAA,mBAAgB,CAAC,QAAQ;YAC1C,MAAM,EAAE,MAAM,EAAE,cAAc,EAAE,mBAAmB,EAAE,GAAG;YAExD,8CAA8C;YAC9C,MAAM,mBAAkE,EAAE;YAC1E,KAAK,MAAM,SAAS,OAAQ;gBAC1B,KAAK,MAAM,MAAM,MAAM,QAAQ,CAAE;oBAC/B,IAAI,GAAG,IAAI,KAAK,WAAW,GAAG,OAAO,KAAK,IAAI;wBAC5C,iBAAiB,IAAI,CAAC;4BAAE,SAAS,MAAM,EAAE;4BAAE,WAAW,GAAG,EAAE;wBAAC;oBAC9D;gBACF;YACF;YAEA,+DAA+D;YAC/D,IAAI,iBAAiB,MAAM,GAAG,GAAG;gBAC/B,oBAAoB;gBACpB;YACF;YAEA,oCAAoC;YACpC,IAAI;gBACF,MAAM,0JAAA,CAAA,iBAAc,CAAC,eAAe,CAAC;oBAAE;oBAAW;gBAAG;YACvD,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,gCAAgC;YAChD;QACF;QAEA,kBAAkB,OAAO;YACvB,IAAI;gBAAE,WAAW;YAAK;YAEtB,IAAI;gBACF,MAAM,aAAa,MAAM,0JAAA,CAAA,iBAAc,CAAC,iBAAiB,CAAC;oBAAE;gBAAU;gBAEtE,wCAAwC;gBACxC,MAAM,oBAAoB,MAAM,QAAQ,GAAG,CACzC,WAAW,GAAG,CAAC,OAAO;oBACpB,IAAI,KAAK,IAAI,KAAK,WAAW,KAAK,IAAI,EAAE;wBACtC,IAAI;4BACF,MAAM,EAAE,YAAY,EAAE,KAAK,EAAE,MAAM,EAAE,GACnC,MAAM,uBAAuB,KAAK,IAAI;4BACxC,OAAO;gCACL,GAAG,IAAI;gCACP;gCACA,OAAO,SAAS,KAAK,KAAK;gCAC1B,QAAQ,UAAU,KAAK,MAAM;4BAC/B;wBACF,EAAE,OAAO,OAAO;4BACd,QAAQ,KAAK,CACX,CAAC,yCAAyC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,EACtD;4BAEF,OAAO;wBACT;oBACF;oBACA,OAAO;gBACT;gBAGF,IAAI;oBAAE,YAAY;gBAAkB;YACtC,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,+BAA+B;YAC/C,SAAU;gBACR,IAAI;oBAAE,WAAW;gBAAM;YACzB;QACF;QAEA,mBAAmB,OAAO;YACxB,MAAM,QAAQ;YAEd,0BAA0B;YAC1B,MAAM,UAAU,CAAC,OAAO,CAAC,CAAC;gBACxB,IAAI,KAAK,GAAG,EAAE;oBACZ,IAAI,eAAe,CAAC,KAAK,GAAG;gBAC9B;gBACA,IAAI,KAAK,YAAY,EAAE;oBACrB,IAAI,eAAe,CAAC,KAAK,YAAY;gBACvC;YACF;YAEA,oBAAoB;YACpB,IAAI;gBAAE,YAAY,EAAE;YAAC;YAErB,2BAA2B;YAC3B,IAAI;gBACF,MAAM,WAAW,MAAM,UAAU,CAAC,GAAG,CAAC,CAAC,OAAS,KAAK,EAAE;gBACvD,MAAM,QAAQ,GAAG,CACf,SAAS,GAAG,CAAC,CAAC,KAAO,0JAAA,CAAA,iBAAc,CAAC,eAAe,CAAC;wBAAE;wBAAW;oBAAG;YAExE,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,6CAA6C;YAC7D;QACF;QAEA,eAAe;YACb,MAAM,QAAQ;YAEd,2IAAA,CAAA,aAAU,CAAC,QAAQ;YAEnB,0BAA0B;YAC1B,MAAM,UAAU,CAAC,OAAO,CAAC,CAAC;gBACxB,IAAI,KAAK,GAAG,EAAE;oBACZ,IAAI,eAAe,CAAC,KAAK,GAAG;gBAC9B;gBACA,IAAI,KAAK,YAAY,EAAE;oBACrB,IAAI,eAAe,CAAC,KAAK,YAAY;gBACvC;YACF;YAEA,oBAAoB;YACpB,IAAI;gBAAE,YAAY,EAAE;YAAC;QACvB;IACF,CAAC","debugId":null}},
    {"offset": {"line": 3092, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/stores/project-store.ts"],"sourcesContent":["import { TProject, BlurIntensity, Scene } from \"@/types/project\";\nimport { create } from \"zustand\";\nimport { storageService } from \"@/lib/storage/storage-service\";\nimport { toast } from \"sonner\";\nimport { useMediaStore } from \"./media-store\";\nimport { useTimelineStore } from \"./timeline-store\";\nimport { useSceneStore } from \"./scene-store\";\nimport { generateUUID } from \"@/lib/utils\";\nimport { CanvasSize, CanvasMode } from \"@/types/editor\";\n\nexport const DEFAULT_CANVAS_SIZE: CanvasSize = { width: 1920, height: 1080 };\nexport const DEFAULT_FPS = 30;\n\nexport function createMainScene(): Scene {\n  return {\n    id: generateUUID(),\n    name: \"Main Scene\",\n    isMain: true,\n    createdAt: new Date(),\n    updatedAt: new Date(),\n  };\n}\n\nconst createDefaultProject = (name: string): TProject => {\n  const mainScene = createMainScene();\n\n  return {\n    id: generateUUID(),\n    name,\n    thumbnail: \"\",\n    createdAt: new Date(),\n    updatedAt: new Date(),\n    scenes: [mainScene],\n    currentSceneId: mainScene.id,\n    backgroundColor: \"#000000\",\n    backgroundType: \"color\",\n    blurIntensity: 8,\n    bookmarks: [],\n    fps: DEFAULT_FPS,\n    canvasSize: DEFAULT_CANVAS_SIZE,\n    canvasMode: \"preset\",\n  };\n};\n\ninterface ProjectStore {\n  activeProject: TProject | null;\n  savedProjects: TProject[];\n  isLoading: boolean;\n  isInitialized: boolean;\n  invalidProjectIds?: Set<string>;\n\n  // Actions\n  createNewProject: (name: string) => Promise<string>;\n  loadProject: (id: string) => Promise<void>;\n  saveCurrentProject: () => Promise<void>;\n  loadAllProjects: () => Promise<void>;\n  deleteProject: (id: string) => Promise<void>;\n  closeProject: () => void;\n  renameProject: (projectId: string, name: string) => Promise<void>;\n  duplicateProject: (projectId: string) => Promise<string>;\n  updateProjectBackground: (backgroundColor: string) => Promise<void>;\n  updateBackgroundType: (\n    type: \"color\" | \"blur\",\n    options?: { backgroundColor?: string; blurIntensity?: BlurIntensity }\n  ) => Promise<void>;\n  updateProjectFps: (fps: number) => Promise<void>;\n  updateCanvasSize: (size: CanvasSize, mode: CanvasMode) => Promise<void>;\n\n  // Bookmark methods\n  toggleBookmark: (time: number) => Promise<void>;\n  isBookmarked: (time: number) => boolean;\n  removeBookmark: (time: number) => Promise<void>;\n\n  getFilteredAndSortedProjects: (\n    searchQuery: string,\n    sortOption: string\n  ) => TProject[];\n\n  // Global invalid project ID tracking\n  isInvalidProjectId: (id: string) => boolean;\n  markProjectIdAsInvalid: (id: string) => void;\n  clearInvalidProjectIds: () => void;\n}\n\nexport const useProjectStore = create<ProjectStore>((set, get) => ({\n  activeProject: null,\n  savedProjects: [],\n  isLoading: true,\n  isInitialized: false,\n  invalidProjectIds: new Set<string>(),\n\n  // Implementation of bookmark methods\n  toggleBookmark: async (time: number) => {\n    const { activeProject } = get();\n    if (!activeProject) return;\n\n    // Round time to the nearest frame\n    const fps = activeProject.fps || DEFAULT_FPS;\n    const frameTime = Math.round(time * fps) / fps;\n\n    const bookmarks = activeProject.bookmarks || [];\n    let updatedBookmarks: number[];\n\n    // Check if already bookmarked\n    const bookmarkIndex = bookmarks.findIndex(\n      (bookmark) => Math.abs(bookmark - frameTime) < 0.001\n    );\n\n    if (bookmarkIndex !== -1) {\n      // Remove bookmark\n      updatedBookmarks = bookmarks.filter((_, i) => i !== bookmarkIndex);\n    } else {\n      // Add bookmark\n      updatedBookmarks = [...bookmarks, frameTime].sort((a, b) => a - b);\n    }\n\n    const updatedProject = {\n      ...activeProject,\n      bookmarks: updatedBookmarks,\n      updatedAt: new Date(),\n    };\n\n    try {\n      await storageService.saveProject({ project: updatedProject });\n      set({ activeProject: updatedProject });\n      await get().loadAllProjects(); // Refresh the list\n    } catch (error) {\n      console.error(\"Failed to update project bookmarks:\", error);\n      toast.error(\"Failed to update bookmarks\", {\n        description: \"Please try again\",\n      });\n    }\n  },\n\n  isBookmarked: (time: number) => {\n    const { activeProject } = get();\n    if (!activeProject || !activeProject.bookmarks) return false;\n\n    // Round time to the nearest frame\n    const fps = activeProject.fps || DEFAULT_FPS;\n    const frameTime = Math.round(time * fps) / fps;\n\n    return activeProject.bookmarks.some(\n      (bookmark) => Math.abs(bookmark - frameTime) < 0.001\n    );\n  },\n\n  removeBookmark: async (time: number) => {\n    const { activeProject } = get();\n    if (!activeProject || !activeProject.bookmarks) return;\n\n    // Round time to the nearest frame\n    const fps = activeProject.fps || DEFAULT_FPS;\n    const frameTime = Math.round(time * fps) / fps;\n\n    const updatedBookmarks = activeProject.bookmarks.filter(\n      (bookmark) => Math.abs(bookmark - frameTime) >= 0.001\n    );\n\n    if (updatedBookmarks.length === activeProject.bookmarks.length) {\n      // No bookmark found to remove\n      return;\n    }\n\n    const updatedProject = {\n      ...activeProject,\n      bookmarks: updatedBookmarks,\n      updatedAt: new Date(),\n    };\n\n    try {\n      await storageService.saveProject({ project: updatedProject });\n      set({ activeProject: updatedProject });\n      await get().loadAllProjects(); // Refresh the list\n    } catch (error) {\n      console.error(\"Failed to update project bookmarks:\", error);\n      toast.error(\"Failed to remove bookmark\", {\n        description: \"Please try again\",\n      });\n    }\n  },\n\n  createNewProject: async (name: string) => {\n    const newProject = createDefaultProject(name);\n\n    set({ activeProject: newProject });\n\n    const mediaStore = useMediaStore.getState();\n    const timelineStore = useTimelineStore.getState();\n    const sceneStore = useSceneStore.getState();\n\n    mediaStore.clearAllMedia();\n    timelineStore.clearTimeline();\n\n    sceneStore.initializeScenes({\n      scenes: newProject.scenes,\n      currentSceneId: newProject.currentSceneId,\n    });\n\n    try {\n      await storageService.saveProject({ project: newProject });\n      // Reload all projects to update the list\n      await get().loadAllProjects();\n      return newProject.id;\n    } catch (error) {\n      toast.error(\"Failed to save new project\");\n      throw error;\n    }\n  },\n\n  loadProject: async (id: string) => {\n    if (!get().isInitialized) {\n      set({ isLoading: true });\n    }\n\n    // Prevent flicker when switching projects - clear all stores\n    const mediaStore = useMediaStore.getState();\n    const timelineStore = useTimelineStore.getState();\n    const sceneStore = useSceneStore.getState();\n\n    mediaStore.clearAllMedia();\n    timelineStore.clearTimeline();\n    sceneStore.clearScenes();\n\n    try {\n      const project = await storageService.loadProject({ id });\n      if (project) {\n        set({ activeProject: project });\n\n        let currentScene = null;\n        if (project.scenes && project.scenes.length > 0) {\n          sceneStore.initializeScenes({\n            scenes: project.scenes,\n            currentSceneId: project.currentSceneId,\n          });\n          // Get current scene directly from project data (don't rely on store state)\n          currentScene =\n            project.scenes.find((s) => s.id === project.currentSceneId) ||\n            project.scenes.find((s) => s.isMain) ||\n            project.scenes[0];\n        }\n\n        await Promise.all([\n          mediaStore.loadProjectMedia(id),\n          timelineStore.loadProjectTimeline({\n            projectId: id,\n            sceneId: currentScene?.id,\n          }),\n        ]);\n      } else {\n        throw new Error(`Project with id ${id} not found`);\n      }\n    } catch (error) {\n      console.error(\"Failed to load project:\", error);\n      throw error; // Re-throw so the editor page can handle it\n    } finally {\n      set({ isLoading: false });\n    }\n  },\n\n  saveCurrentProject: async () => {\n    const { activeProject } = get();\n    if (!activeProject) return;\n\n    try {\n      const timelineStore = useTimelineStore.getState();\n      const sceneStore = useSceneStore.getState();\n      const currentScene = sceneStore.currentScene;\n\n      await Promise.all([\n        storageService.saveProject({ project: activeProject }),\n        timelineStore.saveProjectTimeline({\n          projectId: activeProject.id,\n          sceneId: currentScene?.id,\n        }),\n      ]);\n      await get().loadAllProjects(); // Refresh the list\n    } catch (error) {\n      console.error(\"Failed to save project:\", error);\n    }\n  },\n\n  loadAllProjects: async () => {\n    if (!get().isInitialized) {\n      set({ isLoading: true });\n    }\n\n    try {\n      const projects = await storageService.loadAllProjects();\n      set({ savedProjects: projects });\n    } catch (error) {\n      console.error(\"Failed to load projects:\", error);\n    } finally {\n      set({ isLoading: false, isInitialized: true });\n    }\n  },\n\n  deleteProject: async (id: string) => {\n    try {\n      await Promise.all([\n        storageService.deleteProjectMedia({ projectId: id }),\n        storageService.deleteProjectTimeline({ projectId: id }),\n        storageService.deleteProject({ id }),\n      ]);\n      await get().loadAllProjects(); // Refresh the list\n\n      // If deleted active project, close it and clear data\n      const { activeProject } = get();\n      if (activeProject?.id === id) {\n        set({ activeProject: null });\n        const mediaStore = useMediaStore.getState();\n        const timelineStore = useTimelineStore.getState();\n        const sceneStore = useSceneStore.getState();\n\n        mediaStore.clearAllMedia();\n        timelineStore.clearTimeline();\n        sceneStore.clearScenes();\n      }\n    } catch (error) {\n      console.error(\"Failed to delete project:\", error);\n    }\n  },\n\n  closeProject: () => {\n    set({ activeProject: null });\n\n    const mediaStore = useMediaStore.getState();\n    const timelineStore = useTimelineStore.getState();\n    const sceneStore = useSceneStore.getState();\n\n    mediaStore.clearAllMedia();\n    timelineStore.clearTimeline();\n    sceneStore.clearScenes();\n  },\n\n  renameProject: async (id: string, name: string) => {\n    const { savedProjects } = get();\n\n    // Find the project to rename\n    const projectToRename = savedProjects.find((p) => p.id === id);\n    if (!projectToRename) {\n      toast.error(\"Project not found\", {\n        description: \"Please try again\",\n      });\n      return;\n    }\n\n    const updatedProject = {\n      ...projectToRename,\n      name,\n      updatedAt: new Date(),\n    };\n\n    try {\n      await storageService.saveProject({ project: updatedProject });\n\n      await get().loadAllProjects();\n\n      // Update activeProject if same project\n      const { activeProject } = get();\n      if (activeProject?.id === id) {\n        set({ activeProject: updatedProject });\n      }\n    } catch (error) {\n      console.error(\"Failed to rename project:\", error);\n      toast.error(\"Failed to rename project\", {\n        description:\n          error instanceof Error ? error.message : \"Please try again\",\n      });\n    }\n  },\n\n  duplicateProject: async (projectId: string) => {\n    try {\n      const project = await storageService.loadProject({ id: projectId });\n      if (!project) {\n        toast.error(\"Project not found\", {\n          description: \"Please try again\",\n        });\n        throw new Error(\"Project not found\");\n      }\n\n      const { savedProjects } = get();\n\n      // Extract the base name (remove any existing numbering)\n      const numberMatch = project.name.match(/^\\((\\d+)\\)\\s+(.+)$/);\n      const baseName = numberMatch ? numberMatch[2] : project.name;\n      const existingNumbers: number[] = [];\n\n      // Check for pattern \"(number) baseName\" in existing projects\n      savedProjects.forEach((p) => {\n        const match = p.name.match(/^\\((\\d+)\\)\\s+(.+)$/);\n        if (match && match[2] === baseName) {\n          existingNumbers.push(parseInt(match[1], 10));\n        }\n      });\n\n      const nextNumber =\n        existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;\n\n      const newProject: TProject = {\n        ...project,\n        id: generateUUID(),\n        name: `(${nextNumber}) ${baseName}`,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      await storageService.saveProject({ project: newProject });\n      await get().loadAllProjects();\n      return newProject.id;\n    } catch (error) {\n      console.error(\"Failed to duplicate project:\", error);\n      toast.error(\"Failed to duplicate project\", {\n        description:\n          error instanceof Error ? error.message : \"Please try again\",\n      });\n      throw error;\n    }\n  },\n\n  updateProjectBackground: async (backgroundColor: string) => {\n    const { activeProject } = get();\n    if (!activeProject) return;\n\n    const updatedProject = {\n      ...activeProject,\n      backgroundColor,\n      updatedAt: new Date(),\n    };\n\n    try {\n      await storageService.saveProject({ project: updatedProject });\n      set({ activeProject: updatedProject });\n      await get().loadAllProjects();\n    } catch (error) {\n      console.error(\"Failed to update project background:\", error);\n      toast.error(\"Failed to update background\", {\n        description: \"Please try again\",\n      });\n    }\n  },\n\n  updateBackgroundType: async (\n    type: \"color\" | \"blur\",\n    options?: { backgroundColor?: string; blurIntensity?: BlurIntensity }\n  ) => {\n    const { activeProject } = get();\n    if (!activeProject) return;\n\n    const updatedProject = {\n      ...activeProject,\n      backgroundType: type,\n      ...(options?.backgroundColor && {\n        backgroundColor: options.backgroundColor,\n      }),\n      ...(options?.blurIntensity !== undefined && {\n        blurIntensity: options.blurIntensity,\n      }),\n      updatedAt: new Date(),\n    };\n\n    try {\n      await storageService.saveProject({ project: updatedProject });\n      set({ activeProject: updatedProject });\n      await get().loadAllProjects();\n    } catch (error) {\n      console.error(\"Failed to update background type:\", error);\n      toast.error(\"Failed to update background\", {\n        description: \"Please try again\",\n      });\n    }\n  },\n\n  updateProjectFps: async (fps: number) => {\n    const { activeProject } = get();\n    if (!activeProject) return;\n\n    const updatedProject = {\n      ...activeProject,\n      fps,\n      updatedAt: new Date(),\n    };\n\n    try {\n      await storageService.saveProject({ project: updatedProject });\n      set({ activeProject: updatedProject });\n      await get().loadAllProjects();\n    } catch (error) {\n      console.error(\"Failed to update project FPS:\", error);\n      toast.error(\"Failed to update project FPS\", {\n        description: \"Please try again\",\n      });\n    }\n  },\n\n  updateCanvasSize: async (size: CanvasSize, mode: CanvasMode) => {\n    const { activeProject } = get();\n    if (!activeProject) return;\n\n    const updatedProject = {\n      ...activeProject,\n      canvasSize: size,\n      canvasMode: mode,\n      updatedAt: new Date(),\n    };\n\n    try {\n      await storageService.saveProject({ project: updatedProject });\n      set({ activeProject: updatedProject });\n      await get().loadAllProjects();\n    } catch (error) {\n      console.error(\"Failed to update canvas size:\", error);\n      toast.error(\"Failed to update canvas size\", {\n        description: \"Please try again\",\n      });\n    }\n  },\n\n  getFilteredAndSortedProjects: (searchQuery: string, sortOption: string) => {\n    const { savedProjects } = get();\n\n    const filteredProjects = savedProjects.filter((project) =>\n      project.name.toLowerCase().includes(searchQuery.toLowerCase())\n    );\n\n    const sortedProjects = [...filteredProjects].sort((a, b) => {\n      const [key, order] = sortOption.split(\"-\");\n\n      if (key !== \"createdAt\" && key !== \"name\") {\n        console.warn(`Invalid sort key: ${key}`);\n        return 0;\n      }\n\n      const aValue = a[key];\n      const bValue = b[key];\n\n      if (aValue === undefined || bValue === undefined) return 0;\n\n      if (order === \"asc\") {\n        if (aValue < bValue) return -1;\n        if (aValue > bValue) return 1;\n        return 0;\n      }\n      if (aValue > bValue) return -1;\n      if (aValue < bValue) return 1;\n      return 0;\n    });\n\n    return sortedProjects;\n  },\n\n  // Global invalid project ID tracking\n  isInvalidProjectId: (id: string) => {\n    const invalidIds = get().invalidProjectIds || new Set();\n    return invalidIds.has(id);\n  },\n\n  markProjectIdAsInvalid: (id: string) => {\n    set((state) => ({\n      invalidProjectIds: new Set([\n        ...(state.invalidProjectIds || new Set()),\n        id,\n      ]),\n    }));\n  },\n\n  clearInvalidProjectIds: () => {\n    set({ invalidProjectIds: new Set() });\n  },\n}));\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3616, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/components/storage-provider.tsx"],"sourcesContent":["\"use client\";\n\nimport { createContext, useContext, useEffect, useState } from \"react\";\nimport { useProjectStore } from \"@/stores/project-store\";\nimport { useMediaStore } from \"@/stores/media-store\";\nimport { storageService } from \"@/lib/storage/storage-service\";\nimport { toast } from \"sonner\";\n\ninterface StorageContextType {\n  isInitialized: boolean;\n  isLoading: boolean;\n  hasSupport: boolean;\n  error: string | null;\n}\n\nconst StorageContext = createContext<StorageContextType | null>(null);\n\nexport function useStorage() {\n  const context = useContext(StorageContext);\n  if (!context) {\n    throw new Error(\"useStorage must be used within StorageProvider\");\n  }\n  return context;\n}\n\ninterface StorageProviderProps {\n  children: React.ReactNode;\n}\n\nexport function StorageProvider({ children }: StorageProviderProps) {\n  const [status, setStatus] = useState<StorageContextType>({\n    isInitialized: false,\n    isLoading: true,\n    hasSupport: false,\n    error: null,\n  });\n\n  const loadAllProjects = useProjectStore((state) => state.loadAllProjects);\n\n  useEffect(() => {\n    const initializeStorage = async () => {\n      setStatus((prev) => ({ ...prev, isLoading: true }));\n\n      try {\n        // Check browser support\n        const hasSupport = storageService.isFullySupported();\n\n        if (!hasSupport) {\n          toast.warning(\n            \"Storage not fully supported. Some features may not work.\"\n          );\n        }\n\n        // Load saved projects (media will be loaded when a project is loaded)\n        await loadAllProjects();\n\n        setStatus({\n          isInitialized: true,\n          isLoading: false,\n          hasSupport,\n          error: null,\n        });\n      } catch (error) {\n        console.error(\"Failed to initialize storage:\", error);\n        setStatus({\n          isInitialized: false,\n          isLoading: false,\n          hasSupport: storageService.isFullySupported(),\n          error: error instanceof Error ? error.message : \"Unknown error\",\n        });\n      }\n    };\n\n    initializeStorage();\n  }, [loadAllProjects]);\n\n  return (\n    <StorageContext.Provider value={status}>{children}</StorageContext.Provider>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAEA;AACA;AANA;;;;;;AAeA,MAAM,+BAAiB,CAAA,GAAA,0QAAA,CAAA,gBAAa,AAAD,EAA6B;AAEzD,SAAS;IACd,MAAM,UAAU,CAAA,GAAA,0QAAA,CAAA,aAAU,AAAD,EAAE;IAC3B,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAMO,SAAS,gBAAgB,EAAE,QAAQ,EAAwB;IAChE,MAAM,CAAC,QAAQ,UAAU,GAAG,CAAA,GAAA,0QAAA,CAAA,WAAQ,AAAD,EAAsB;QACvD,eAAe;QACf,WAAW;QACX,YAAY;QACZ,OAAO;IACT;IAEA,MAAM,kBAAkB,CAAA,GAAA,gJAAA,CAAA,kBAAe,AAAD,EAAE,CAAC,QAAU,MAAM,eAAe;IAExE,CAAA,GAAA,0QAAA,CAAA,YAAS,AAAD,EAAE;QACR,MAAM,oBAAoB;YACxB,UAAU,CAAC,OAAS,CAAC;oBAAE,GAAG,IAAI;oBAAE,WAAW;gBAAK,CAAC;YAEjD,IAAI;gBACF,wBAAwB;gBACxB,MAAM,aAAa,0JAAA,CAAA,iBAAc,CAAC,gBAAgB;gBAElD,IAAI,CAAC,YAAY;oBACf,8MAAA,CAAA,QAAK,CAAC,OAAO,CACX;gBAEJ;gBAEA,sEAAsE;gBACtE,MAAM;gBAEN,UAAU;oBACR,eAAe;oBACf,WAAW;oBACX;oBACA,OAAO;gBACT;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC,iCAAiC;gBAC/C,UAAU;oBACR,eAAe;oBACf,WAAW;oBACX,YAAY,0JAAA,CAAA,iBAAc,CAAC,gBAAgB;oBAC3C,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;gBAClD;YACF;QACF;QAEA;IACF,GAAG;QAAC;KAAgB;IAEpB,qBACE,mTAAC,eAAe,QAAQ;QAAC,OAAO;kBAAS;;;;;;AAE7C","debugId":null}},
    {"offset": {"line": 3718, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/components/ui/dialog.tsx"],"sourcesContent":["\"use client\";\n\nimport * as React from \"react\";\nimport { Dialog as DialogPrimitive } from \"radix-ui\";\nimport { X } from \"lucide-react\";\n\nimport { cn } from \"../../lib/utils\";\nimport { ScrollArea } from \"./scroll-area\";\n\nconst Dialog = DialogPrimitive.Root;\n\nconst DialogTrigger = DialogPrimitive.Trigger;\n\nconst DialogPortal = DialogPrimitive.Portal;\n\nconst DialogClose = DialogPrimitive.Close;\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-250 bg-black/50 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n));\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName;\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] p-6 z-250 grid w-[calc(100%-2rem)] max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-popover shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 rounded-lg\",\n        className\n      )}\n      onCloseAutoFocus={(e) => {\n        e.stopPropagation();\n        e.preventDefault();\n      }}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground cursor-pointer\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n));\nDialogContent.displayName = DialogPrimitive.Content.displayName;\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n);\nDialogHeader.displayName = \"DialogHeader\";\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n);\nDialogFooter.displayName = \"DialogFooter\";\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n));\nDialogTitle.displayName = DialogPrimitive.Title.displayName;\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n));\nDialogDescription.displayName = DialogPrimitive.Description.displayName;\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogTrigger,\n  DialogClose,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;AAEA;AACA;AACA;AAEA;AANA;;;;;;AASA,MAAM,SAAS,qSAAA,CAAA,SAAe,CAAC,IAAI;AAEnC,MAAM,gBAAgB,qSAAA,CAAA,SAAe,CAAC,OAAO;AAE7C,MAAM,eAAe,qSAAA,CAAA,SAAe,CAAC,MAAM;AAE3C,MAAM,cAAc,qSAAA,CAAA,SAAe,CAAC,KAAK;AAEzC,MAAM,8BAAgB,0QAAA,CAAA,aAAgB,CAGpC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,mTAAC,qSAAA,CAAA,SAAe,CAAC,OAAO;QACtB,KAAK;QACL,WAAW,CAAA,GAAA,kIAAA,CAAA,KAAE,AAAD,EACV,2JACA;QAED,GAAG,KAAK;;;;;;AAGb,cAAc,WAAW,GAAG,qSAAA,CAAA,SAAe,CAAC,OAAO,CAAC,WAAW;AAE/D,MAAM,8BAAgB,0QAAA,CAAA,aAAgB,CAGpC,CAAC,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,OAAO,EAAE,oBACpC,mTAAC;;0BACC,mTAAC;;;;;0BACD,mTAAC,qSAAA,CAAA,SAAe,CAAC,OAAO;gBACtB,KAAK;gBACL,WAAW,CAAA,GAAA,kIAAA,CAAA,KAAE,AAAD,EACV,+VACA;gBAEF,kBAAkB,CAAC;oBACjB,EAAE,eAAe;oBACjB,EAAE,cAAc;gBAClB;gBACC,GAAG,KAAK;;oBAER;kCACD,mTAAC,qSAAA,CAAA,SAAe,CAAC,KAAK;wBAAC,WAAU;;0CAC/B,mTAAC,6QAAA,CAAA,IAAC;gCAAC,WAAU;;;;;;0CACb,mTAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;AAKlC,cAAc,WAAW,GAAG,qSAAA,CAAA,SAAe,CAAC,OAAO,CAAC,WAAW;AAE/D,MAAM,eAAe,CAAC,EACpB,SAAS,EACT,GAAG,OACkC,iBACrC,mTAAC;QACC,WAAW,CAAA,GAAA,kIAAA,CAAA,KAAE,AAAD,EACV,oDACA;QAED,GAAG,KAAK;;;;;;AAGb,aAAa,WAAW,GAAG;AAE3B,MAAM,eAAe,CAAC,EACpB,SAAS,EACT,GAAG,OACkC,iBACrC,mTAAC;QACC,WAAW,CAAA,GAAA,kIAAA,CAAA,KAAE,AAAD,EACV,iEACA;QAED,GAAG,KAAK;;;;;;AAGb,aAAa,WAAW,GAAG;AAE3B,MAAM,4BAAc,0QAAA,CAAA,aAAgB,CAGlC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,mTAAC,qSAAA,CAAA,SAAe,CAAC,KAAK;QACpB,KAAK;QACL,WAAW,CAAA,GAAA,kIAAA,CAAA,KAAE,AAAD,EACV,qDACA;QAED,GAAG,KAAK;;;;;;AAGb,YAAY,WAAW,GAAG,qSAAA,CAAA,SAAe,CAAC,KAAK,CAAC,WAAW;AAE3D,MAAM,kCAAoB,0QAAA,CAAA,aAAgB,CAGxC,CAAC,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,oBAC1B,mTAAC,qSAAA,CAAA,SAAe,CAAC,WAAW;QAC1B,KAAK;QACL,WAAW,CAAA,GAAA,kIAAA,CAAA,KAAE,AAAD,EAAE,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGb,kBAAkB,WAAW,GAAG,qSAAA,CAAA,SAAe,CAAC,WAAW,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 3852, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/components/ui/progress.tsx"],"sourcesContent":["\"use client\";\n\nimport * as React from \"react\";\nimport { Progress as ProgressPrimitive } from \"radix-ui\";\n\nimport { cn } from \"../../lib/utils\";\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-2 w-full overflow-hidden rounded-full bg-accent\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-foreground transition-all\"\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n));\nProgress.displayName = ProgressPrimitive.Root.displayName;\n\nexport { Progress };\n"],"names":[],"mappings":";;;;AAEA;AACA;AAEA;AALA;;;;;AAOA,MAAM,yBAAW,0QAAA,CAAA,aAAgB,CAG/B,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,OAAO,EAAE,oBACjC,mTAAC,0SAAA,CAAA,WAAiB,CAAC,IAAI;QACrB,KAAK;QACL,WAAW,CAAA,GAAA,kIAAA,CAAA,KAAE,AAAD,EACV,8DACA;QAED,GAAG,KAAK;kBAET,cAAA,mTAAC,0SAAA,CAAA,WAAiB,CAAC,SAAS;YAC1B,WAAU;YACV,OAAO;gBAAE,WAAW,CAAC,YAAY,EAAE,MAAM,CAAC,SAAS,CAAC,EAAE,EAAE,CAAC;YAAC;;;;;;;;;;;AAIhE,SAAS,WAAW,GAAG,0SAAA,CAAA,WAAiB,CAAC,IAAI,CAAC,WAAW","debugId":null}},
    {"offset": {"line": 3889, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/components/providers/migrators/scenes-migrator.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { usePathname } from \"next/navigation\";\nimport { storageService } from \"@/lib/storage/storage-service\";\nimport { TProject, Scene } from \"@/types/project\";\nimport { generateUUID } from \"@/lib/utils\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Progress } from \"@/components/ui/progress\";\nimport { createMainScene } from \"@/stores/project-store\";\n\ninterface MigrationProgress {\n  current: number;\n  total: number;\n  currentProjectName: string;\n}\n\nexport function ScenesMigrator({ children }: { children: React.ReactNode }) {\n  const pathname = usePathname();\n  const [isMigrating, setIsMigrating] = useState(false);\n  const [progress, setProgress] = useState<MigrationProgress>({\n    current: 0,\n    total: 0,\n    currentProjectName: \"\",\n  });\n\n  const shouldCheckMigration =\n    pathname.startsWith(\"/editor\") || pathname.startsWith(\"/projects\");\n\n  useEffect(() => {\n    if (!shouldCheckMigration) return;\n\n    checkAndMigrateProjects();\n  }, [shouldCheckMigration]);\n\n  const checkAndMigrateProjects = async () => {\n    try {\n      const projects = await storageService.loadAllProjects();\n      const legacyProjects = projects.filter(\n        (project) => !project.scenes || project.scenes.length === 0\n      );\n\n      if (legacyProjects.length === 0) {\n        // No migration needed\n        return;\n      }\n\n      setIsMigrating(true);\n      setProgress({\n        current: 0,\n        total: legacyProjects.length,\n        currentProjectName: \"\",\n      });\n\n      // Migrate each legacy project\n      for (let i = 0; i < legacyProjects.length; i++) {\n        const project = legacyProjects[i];\n\n        setProgress({\n          current: i,\n          total: legacyProjects.length,\n          currentProjectName: project.name,\n        });\n\n        await migrateLegacyProject(project);\n      }\n\n      setProgress({\n        current: legacyProjects.length,\n        total: legacyProjects.length,\n        currentProjectName: \"Complete!\",\n      });\n\n      setTimeout(() => {\n        setIsMigrating(false);\n      }, 1000);\n    } catch (error) {\n      console.error(\"Migration failed:\", error);\n      setIsMigrating(false);\n    }\n  };\n\n  const migrateLegacyProject = async (project: TProject) => {\n    try {\n      const mainScene: Scene = {\n        id: generateUUID(),\n        name: \"Main Scene\",\n        isMain: true,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      const migratedProject: TProject = {\n        ...project,\n        scenes: [mainScene],\n        currentSceneId: mainScene.id,\n        updatedAt: new Date(),\n      };\n\n      // Load existing timeline data (legacy format)\n      const legacyTimeline = await storageService.loadTimeline({\n        projectId: project.id,\n      });\n\n      await storageService.saveProject({ project: migratedProject });\n\n      // If timeline data, migrate it to the main scene\n      if (legacyTimeline && legacyTimeline.length > 0) {\n        await storageService.saveTimeline({\n          projectId: project.id,\n          tracks: legacyTimeline,\n          sceneId: mainScene.id,\n        });\n      }\n\n      // Clean up legacy timeline storage\n      await storageService.deleteProjectTimeline({ projectId: project.id });\n    } catch (error) {\n      console.error(`Failed to migrate project ${project.name}:`, error);\n      throw error;\n    }\n  };\n\n  if (!shouldCheckMigration) {\n    return children;\n  }\n\n  if (isMigrating) {\n    const progressPercent =\n      progress.total > 0 ? (progress.current / progress.total) * 100 : 0;\n\n    return (\n      <Dialog open={true}>\n        <DialogContent\n          className=\"sm:max-w-md\"\n          onPointerDownOutside={(e) => e.preventDefault()}\n        >\n          <DialogHeader>\n            <DialogTitle>Updating Projects</DialogTitle>\n            <DialogDescription>\n              We're adding scene support to your projects. This will only take a\n              moment.\n            </DialogDescription>\n          </DialogHeader>\n\n          <div className=\"space-y-4\">\n            <div className=\"space-y-2\">\n              <div className=\"flex justify-between text-sm\">\n                <span>Progress</span>\n                <span>\n                  {progress.current} of {progress.total}\n                </span>\n              </div>\n              <Progress value={progressPercent} className=\"w-full\" />\n            </div>\n\n            {progress.currentProjectName && (\n              <div className=\"text-sm text-muted-foreground\">\n                {progress.current < progress.total\n                  ? `Updating: ${progress.currentProjectName}`\n                  : progress.currentProjectName}\n              </div>\n            )}\n          </div>\n        </DialogContent>\n      </Dialog>\n    );\n  }\n\n  return children;\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}