{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-drag-drop.ts"],"sourcesContent":["import { useState, useRef } from \"react\";\n\ninterface UseDragDropOptions {\n  onDrop?: (files: FileList) => void;\n}\n\n// Helper function to check if drag contains files from external sources (not internal app drags)\nconst containsFiles = (dataTransfer: DataTransfer): boolean => {\n  // Check if this is an internal app drag (media item)\n  if (dataTransfer.types.includes(\"application/x-media-item\")) {\n    return false;\n  }\n\n  // Only show overlay for external file drags\n  return dataTransfer.types.includes(\"Files\");\n};\n\nexport function useDragDrop(options: UseDragDropOptions = {}) {\n  const [isDragOver, setIsDragOver] = useState(false);\n  const dragCounterRef = useRef(0);\n\n  const handleDragEnter = (e: React.DragEvent) => {\n    e.preventDefault();\n\n    // Only handle external file drags, not internal app element drags\n    if (!containsFiles(e.dataTransfer)) {\n      return;\n    }\n\n    dragCounterRef.current += 1;\n    if (!isDragOver) {\n      setIsDragOver(true);\n    }\n  };\n\n  const handleDragOver = (e: React.DragEvent) => {\n    e.preventDefault();\n\n    // Only handle file drags\n    if (!containsFiles(e.dataTransfer)) {\n      return;\n    }\n  };\n\n  const handleDragLeave = (e: React.DragEvent) => {\n    e.preventDefault();\n\n    // Only handle file drags\n    if (!containsFiles(e.dataTransfer)) {\n      return;\n    }\n\n    dragCounterRef.current -= 1;\n    if (dragCounterRef.current === 0) {\n      setIsDragOver(false);\n    }\n  };\n\n  const handleDrop = (e: React.DragEvent) => {\n    e.preventDefault();\n    setIsDragOver(false);\n    dragCounterRef.current = 0;\n\n    // Only handle file drops\n    if (\n      options.onDrop &&\n      e.dataTransfer.files &&\n      containsFiles(e.dataTransfer)\n    ) {\n      options.onDrop(e.dataTransfer.files);\n    }\n  };\n\n  const dragProps = {\n    onDragEnter: handleDragEnter,\n    onDragOver: handleDragOver,\n    onDragLeave: handleDragLeave,\n    onDrop: handleDrop,\n  };\n\n  return {\n    isDragOver,\n    dragProps,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;;AAMA,iGAAiG;AACjG,MAAM,gBAAgB,CAAC;IACrB,qDAAqD;IACrD,IAAI,aAAa,KAAK,CAAC,QAAQ,CAAC,6BAA6B;QAC3D,OAAO;IACT;IAEA,4CAA4C;IAC5C,OAAO,aAAa,KAAK,CAAC,QAAQ,CAAC;AACrC;AAEO,SAAS;QAAY,UAAA,iEAA8B,CAAC;;IACzD,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,kOAAA,CAAA,WAAQ,AAAD,EAAE;IAC7C,MAAM,iBAAiB,CAAA,GAAA,kOAAA,CAAA,SAAM,AAAD,EAAE;IAE9B,MAAM,kBAAkB,CAAC;QACvB,EAAE,cAAc;QAEhB,kEAAkE;QAClE,IAAI,CAAC,cAAc,EAAE,YAAY,GAAG;YAClC;QACF;QAEA,eAAe,OAAO,IAAI;QAC1B,IAAI,CAAC,YAAY;YACf,cAAc;QAChB;IACF;IAEA,MAAM,iBAAiB,CAAC;QACtB,EAAE,cAAc;QAEhB,yBAAyB;QACzB,IAAI,CAAC,cAAc,EAAE,YAAY,GAAG;YAClC;QACF;IACF;IAEA,MAAM,kBAAkB,CAAC;QACvB,EAAE,cAAc;QAEhB,yBAAyB;QACzB,IAAI,CAAC,cAAc,EAAE,YAAY,GAAG;YAClC;QACF;QAEA,eAAe,OAAO,IAAI;QAC1B,IAAI,eAAe,OAAO,KAAK,GAAG;YAChC,cAAc;QAChB;IACF;IAEA,MAAM,aAAa,CAAC;QAClB,EAAE,cAAc;QAChB,cAAc;QACd,eAAe,OAAO,GAAG;QAEzB,yBAAyB;QACzB,IACE,QAAQ,MAAM,IACd,EAAE,YAAY,CAAC,KAAK,IACpB,cAAc,EAAE,YAAY,GAC5B;YACA,QAAQ,MAAM,CAAC,EAAE,YAAY,CAAC,KAAK;QACrC;IACF;IAEA,MAAM,YAAY;QAChB,aAAa;QACb,YAAY;QACZ,aAAa;QACb,QAAQ;IACV;IAEA,OAAO;QACL;QACA;IACF;AACF;GAnEgB","debugId":null}},
    {"offset": {"line": 86, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-highlight-scroll.ts"],"sourcesContent":["import { useEffect, useState, useRef } from \"react\";\r\n\r\nexport function useHighlightScroll(\r\n  highlightId: string | null,\r\n  onClearHighlight: () => void,\r\n  highlightDuration = 1000\r\n) {\r\n  const [highlightedId, setHighlightedId] = useState<string | null>(null);\r\n  const elementRefs = useRef<Map<string, HTMLElement>>(new Map());\r\n\r\n  const registerElement = (id: string, element: HTMLElement | null) => {\r\n    if (element) {\r\n      elementRefs.current.set(id, element);\r\n    } else {\r\n      elementRefs.current.delete(id);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!highlightId) return;\r\n\r\n    setHighlightedId(highlightId);\r\n\r\n    const target = elementRefs.current.get(highlightId);\r\n    target?.scrollIntoView({ block: \"center\" });\r\n\r\n    const timeout = setTimeout(() => {\r\n      setHighlightedId(null);\r\n      onClearHighlight();\r\n    }, highlightDuration);\r\n\r\n    return () => clearTimeout(timeout);\r\n  }, [highlightId, onClearHighlight, highlightDuration]);\r\n\r\n  return { highlightedId, registerElement };\r\n}\r\n"],"names":[],"mappings":";;;AAAA;;;AAEO,SAAS,mBACd,WAA0B,EAC1B,gBAA4B;QAC5B,oBAAA,iEAAoB;;IAEpB,MAAM,CAAC,eAAe,iBAAiB,GAAG,CAAA,GAAA,kOAAA,CAAA,WAAQ,AAAD,EAAiB;IAClE,MAAM,cAAc,CAAA,GAAA,kOAAA,CAAA,SAAM,AAAD,EAA4B,IAAI;IAEzD,MAAM,kBAAkB,CAAC,IAAY;QACnC,IAAI,SAAS;YACX,YAAY,OAAO,CAAC,GAAG,CAAC,IAAI;QAC9B,OAAO;YACL,YAAY,OAAO,CAAC,MAAM,CAAC;QAC7B;IACF;IAEA,CAAA,GAAA,kOAAA,CAAA,YAAS,AAAD;wCAAE;YACR,IAAI,CAAC,aAAa;YAElB,iBAAiB;YAEjB,MAAM,SAAS,YAAY,OAAO,CAAC,GAAG,CAAC;YACvC,mBAAA,6BAAA,OAAQ,cAAc,CAAC;gBAAE,OAAO;YAAS;YAEzC,MAAM,UAAU;wDAAW;oBACzB,iBAAiB;oBACjB;gBACF;uDAAG;YAEH;gDAAO,IAAM,aAAa;;QAC5B;uCAAG;QAAC;QAAa;QAAkB;KAAkB;IAErD,OAAO;QAAE;QAAe;IAAgB;AAC1C;GAjCgB","debugId":null}},
    {"offset": {"line": 142, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-sound-search.ts"],"sourcesContent":["import { useEffect } from \"react\";\r\nimport { useSoundsStore } from \"@/stores/sounds-store\";\r\n\r\n/**\r\n * Custom hook for searching sound effects with race condition protection.\r\n * Uses global Zustand store to persist search state across tab switches.\r\n * - Debounced search (300ms)\r\n * - Race condition protection with cleanup\r\n * - Proper error handling\r\n */\r\n\r\nexport function useSoundSearch(query: string, commercialOnly: boolean) {\r\n  const {\r\n    searchResults,\r\n    isSearching,\r\n    searchError,\r\n    lastSearchQuery,\r\n    currentPage,\r\n    hasNextPage,\r\n    isLoadingMore,\r\n    totalCount,\r\n    setSearchResults,\r\n    setSearching,\r\n    setSearchError,\r\n    setLastSearchQuery,\r\n    setCurrentPage,\r\n    setHasNextPage,\r\n    setTotalCount,\r\n    setLoadingMore,\r\n    appendSearchResults,\r\n    appendTopSounds,\r\n    resetPagination,\r\n  } = useSoundsStore();\r\n\r\n  // Load more function for infinite scroll\r\n  const loadMore = async () => {\r\n    if (isLoadingMore || !hasNextPage) return;\r\n\r\n    try {\r\n      setLoadingMore(true);\r\n      const nextPage = currentPage + 1;\r\n\r\n      const searchParams = new URLSearchParams({\r\n        page: nextPage.toString(),\r\n        type: \"effects\",\r\n      });\r\n\r\n      if (query.trim()) {\r\n        searchParams.set(\"q\", query);\r\n      }\r\n\r\n      searchParams.set(\"commercial_only\", commercialOnly.toString());\r\n      const response = await fetch(\r\n        `/api/sounds/search?${searchParams.toString()}`\r\n      );\r\n\r\n      if (response.ok) {\r\n        const data = await response.json();\r\n\r\n        // Append to appropriate array based on whether we have a query\r\n        if (query.trim()) {\r\n          appendSearchResults(data.results);\r\n        } else {\r\n          appendTopSounds(data.results);\r\n        }\r\n\r\n        setCurrentPage(nextPage);\r\n        setHasNextPage(!!data.next);\r\n        setTotalCount(data.count);\r\n      } else {\r\n        setSearchError(`Load more failed: ${response.status}`);\r\n      }\r\n    } catch (err) {\r\n      setSearchError(err instanceof Error ? err.message : \"Load more failed\");\r\n    } finally {\r\n      setLoadingMore(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!query.trim()) {\r\n      setSearchResults([]);\r\n      setSearchError(null);\r\n      setLastSearchQuery(\"\");\r\n      // Don't reset pagination here - top sounds pagination is managed by prefetcher\r\n      return;\r\n    }\r\n\r\n    // If we already searched for this query and have results, don't search again\r\n    if (query === lastSearchQuery && searchResults.length > 0) {\r\n      return;\r\n    }\r\n\r\n    let ignore = false;\r\n\r\n    const timeoutId = setTimeout(async () => {\r\n      try {\r\n        setSearching(true);\r\n        setSearchError(null);\r\n        resetPagination();\r\n\r\n        const response = await fetch(\r\n          `/api/sounds/search?q=${encodeURIComponent(query)}&type=effects&page=1`\r\n        );\r\n\r\n        if (!ignore) {\r\n          if (response.ok) {\r\n            const data = await response.json();\r\n            setSearchResults(data.results);\r\n            setLastSearchQuery(query);\r\n            setHasNextPage(!!data.next);\r\n            setTotalCount(data.count);\r\n            setCurrentPage(1);\r\n          } else {\r\n            setSearchError(`Search failed: ${response.status}`);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        if (!ignore) {\r\n          setSearchError(err instanceof Error ? err.message : \"Search failed\");\r\n        }\r\n      } finally {\r\n        if (!ignore) {\r\n          setSearching(false);\r\n        }\r\n      }\r\n    }, 300);\r\n\r\n    return () => {\r\n      clearTimeout(timeoutId);\r\n      ignore = true;\r\n    };\r\n  }, [\r\n    query,\r\n    lastSearchQuery,\r\n    searchResults.length,\r\n    setSearchResults,\r\n    setSearching,\r\n    setSearchError,\r\n    setLastSearchQuery,\r\n    setCurrentPage,\r\n    setHasNextPage,\r\n    setTotalCount,\r\n    resetPagination,\r\n  ]);\r\n\r\n  return {\r\n    results: searchResults,\r\n    isLoading: isSearching,\r\n    error: searchError,\r\n    loadMore,\r\n    hasNextPage,\r\n    isLoadingMore,\r\n    totalCount,\r\n  };\r\n}\r\n"],"names":[],"mappings":";;;AAAA;AACA;;;;AAUO,SAAS,eAAe,KAAa,EAAE,cAAuB;;IACnE,MAAM,EACJ,aAAa,EACb,WAAW,EACX,WAAW,EACX,eAAe,EACf,WAAW,EACX,WAAW,EACX,aAAa,EACb,UAAU,EACV,gBAAgB,EAChB,YAAY,EACZ,cAAc,EACd,kBAAkB,EAClB,cAAc,EACd,cAAc,EACd,aAAa,EACb,cAAc,EACd,mBAAmB,EACnB,eAAe,EACf,eAAe,EAChB,GAAG,CAAA,GAAA,kJAAA,CAAA,iBAAc,AAAD;IAEjB,yCAAyC;IACzC,MAAM,WAAW;QACf,IAAI,iBAAiB,CAAC,aAAa;QAEnC,IAAI;YACF,eAAe;YACf,MAAM,WAAW,cAAc;YAE/B,MAAM,eAAe,IAAI,gBAAgB;gBACvC,MAAM,SAAS,QAAQ;gBACvB,MAAM;YACR;YAEA,IAAI,MAAM,IAAI,IAAI;gBAChB,aAAa,GAAG,CAAC,KAAK;YACxB;YAEA,aAAa,GAAG,CAAC,mBAAmB,eAAe,QAAQ;YAC3D,MAAM,WAAW,MAAM,MACrB,AAAC,sBAA6C,OAAxB,aAAa,QAAQ;YAG7C,IAAI,SAAS,EAAE,EAAE;gBACf,MAAM,OAAO,MAAM,SAAS,IAAI;gBAEhC,+DAA+D;gBAC/D,IAAI,MAAM,IAAI,IAAI;oBAChB,oBAAoB,KAAK,OAAO;gBAClC,OAAO;oBACL,gBAAgB,KAAK,OAAO;gBAC9B;gBAEA,eAAe;gBACf,eAAe,CAAC,CAAC,KAAK,IAAI;gBAC1B,cAAc,KAAK,KAAK;YAC1B,OAAO;gBACL,eAAe,AAAC,qBAAoC,OAAhB,SAAS,MAAM;YACrD;QACF,EAAE,OAAO,KAAK;YACZ,eAAe,eAAe,QAAQ,IAAI,OAAO,GAAG;QACtD,SAAU;YACR,eAAe;QACjB;IACF;IAEA,CAAA,GAAA,kOAAA,CAAA,YAAS,AAAD;oCAAE;YACR,IAAI,CAAC,MAAM,IAAI,IAAI;gBACjB,iBAAiB,EAAE;gBACnB,eAAe;gBACf,mBAAmB;gBACnB,+EAA+E;gBAC/E;YACF;YAEA,6EAA6E;YAC7E,IAAI,UAAU,mBAAmB,cAAc,MAAM,GAAG,GAAG;gBACzD;YACF;YAEA,IAAI,SAAS;YAEb,MAAM,YAAY;sDAAW;oBAC3B,IAAI;wBACF,aAAa;wBACb,eAAe;wBACf;wBAEA,MAAM,WAAW,MAAM,MACrB,AAAC,wBAAiD,OAA1B,mBAAmB,QAAO;wBAGpD,IAAI,CAAC,QAAQ;4BACX,IAAI,SAAS,EAAE,EAAE;gCACf,MAAM,OAAO,MAAM,SAAS,IAAI;gCAChC,iBAAiB,KAAK,OAAO;gCAC7B,mBAAmB;gCACnB,eAAe,CAAC,CAAC,KAAK,IAAI;gCAC1B,cAAc,KAAK,KAAK;gCACxB,eAAe;4BACjB,OAAO;gCACL,eAAe,AAAC,kBAAiC,OAAhB,SAAS,MAAM;4BAClD;wBACF;oBACF,EAAE,OAAO,KAAK;wBACZ,IAAI,CAAC,QAAQ;4BACX,eAAe,eAAe,QAAQ,IAAI,OAAO,GAAG;wBACtD;oBACF,SAAU;wBACR,IAAI,CAAC,QAAQ;4BACX,aAAa;wBACf;oBACF;gBACF;qDAAG;YAEH;4CAAO;oBACL,aAAa;oBACb,SAAS;gBACX;;QACF;mCAAG;QACD;QACA;QACA,cAAc,MAAM;QACpB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,OAAO;QACL,SAAS;QACT,WAAW;QACX,OAAO;QACP;QACA;QACA;QACA;IACF;AACF;GAhJgB;;QAqBV,kJAAA,CAAA,iBAAc","debugId":null}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-infinite-scroll.ts"],"sourcesContent":["import { useRef, useCallback } from \"react\";\r\n\r\ninterface UseInfiniteScrollOptions {\r\n  onLoadMore: () => void;\r\n  hasMore: boolean;\r\n  isLoading: boolean;\r\n  threshold?: number;\r\n  enabled?: boolean;\r\n}\r\n\r\nexport function useInfiniteScroll({\r\n  onLoadMore,\r\n  hasMore,\r\n  isLoading,\r\n  threshold = 200,\r\n  enabled = true,\r\n}: UseInfiniteScrollOptions) {\r\n  const scrollAreaRef = useRef<HTMLDivElement>(null);\r\n\r\n  const handleScroll = useCallback(\r\n    (event: React.UIEvent<HTMLDivElement>) => {\r\n      if (!enabled) return;\r\n\r\n      const { scrollTop, scrollHeight, clientHeight } = event.currentTarget;\r\n      const nearBottom = scrollTop + clientHeight >= scrollHeight - threshold;\r\n\r\n      if (nearBottom && hasMore && !isLoading) {\r\n        onLoadMore();\r\n      }\r\n    },\r\n    [onLoadMore, hasMore, isLoading, threshold, enabled]\r\n  );\r\n\r\n  return { scrollAreaRef, handleScroll };\r\n}\r\n"],"names":[],"mappings":";;;AAAA;;;AAUO,SAAS,kBAAkB,KAMP;QANO,EAChC,UAAU,EACV,OAAO,EACP,SAAS,EACT,YAAY,GAAG,EACf,UAAU,IAAI,EACW,GANO;;IAOhC,MAAM,gBAAgB,CAAA,GAAA,kOAAA,CAAA,SAAM,AAAD,EAAkB;IAE7C,MAAM,eAAe,CAAA,GAAA,kOAAA,CAAA,cAAW,AAAD;uDAC7B,CAAC;YACC,IAAI,CAAC,SAAS;YAEd,MAAM,EAAE,SAAS,EAAE,YAAY,EAAE,YAAY,EAAE,GAAG,MAAM,aAAa;YACrE,MAAM,aAAa,YAAY,gBAAgB,eAAe;YAE9D,IAAI,cAAc,WAAW,CAAC,WAAW;gBACvC;YACF;QACF;sDACA;QAAC;QAAY;QAAS;QAAW;QAAW;KAAQ;IAGtD,OAAO;QAAE;QAAe;IAAa;AACvC;GAxBgB","debugId":null}},
    {"offset": {"line": 317, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-aspect-ratio.ts"],"sourcesContent":["import { useEditorStore } from \"@/stores/editor-store\";\nimport { useMediaStore, getMediaAspectRatio } from \"@/stores/media-store\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { DEFAULT_CANVAS_SIZE, useProjectStore } from \"@/stores/project-store\";\n\nexport function useAspectRatio() {\n  const { canvasPresets } = useEditorStore();\n  const { activeProject } = useProjectStore();\n  const { mediaFiles } = useMediaStore();\n  const { tracks } = useTimelineStore();\n\n  const canvasSize = activeProject?.canvasSize || DEFAULT_CANVAS_SIZE;\n  const canvasMode = activeProject?.canvasMode || \"preset\";\n\n  // Find the current preset based on canvas size\n  const currentPreset = canvasPresets.find(\n    (preset) =>\n      preset.width === canvasSize.width && preset.height === canvasSize.height\n  );\n\n  // Get the original aspect ratio from the first video/image in timeline\n  const getOriginalAspectRatio = (): number => {\n    // Find first video or image in timeline\n    for (const track of tracks) {\n      for (const element of track.elements) {\n        if (element.type === \"media\") {\n          const mediaFile = mediaFiles.find(\n            (file) => file.id === element.mediaId\n          );\n          if (\n            mediaFile &&\n            (mediaFile.type === \"video\" || mediaFile.type === \"image\")\n          ) {\n            return getMediaAspectRatio(mediaFile);\n          }\n        }\n      }\n    }\n    return 16 / 9; // Default aspect ratio\n  };\n\n  // Get current aspect ratio\n  const getCurrentAspectRatio = (): number => {\n    return canvasSize.width / canvasSize.height;\n  };\n\n  // Format aspect ratio as a readable string\n  const formatAspectRatio = (aspectRatio: number): string => {\n    // Check if it matches a common aspect ratio\n    const ratios = [\n      { ratio: 16 / 9, label: \"16:9\" },\n      { ratio: 9 / 16, label: \"9:16\" },\n      { ratio: 1, label: \"1:1\" },\n      { ratio: 4 / 3, label: \"4:3\" },\n      { ratio: 3 / 4, label: \"3:4\" },\n      { ratio: 21 / 9, label: \"21:9\" },\n    ];\n\n    for (const { ratio, label } of ratios) {\n      if (Math.abs(aspectRatio - ratio) < 0.01) {\n        return label;\n      }\n    }\n\n    // If not a common ratio, format as decimal\n    return aspectRatio.toFixed(2);\n  };\n\n  // Check if current mode is \"Original\"\n  const isOriginal = canvasMode === \"original\";\n\n  // Get display name for current aspect ratio\n  const getDisplayName = (): string => {\n    // If explicitly set to original mode, always show \"Original\"\n    if (canvasMode === \"original\") {\n      return \"Original\";\n    }\n\n    if (currentPreset) {\n      return currentPreset.name;\n    }\n\n    return formatAspectRatio(getCurrentAspectRatio());\n  };\n\n  return {\n    currentPreset,\n    canvasMode,\n    isOriginal,\n    getCurrentAspectRatio,\n    getOriginalAspectRatio,\n    formatAspectRatio,\n    getDisplayName,\n    canvasSize,\n    canvasPresets,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;;AAEO,SAAS;;IACd,MAAM,EAAE,aAAa,EAAE,GAAG,CAAA,GAAA,kJAAA,CAAA,iBAAc,AAAD;IACvC,MAAM,EAAE,aAAa,EAAE,GAAG,CAAA,GAAA,mJAAA,CAAA,kBAAe,AAAD;IACxC,MAAM,EAAE,UAAU,EAAE,GAAG,CAAA,GAAA,iJAAA,CAAA,gBAAa,AAAD;IACnC,MAAM,EAAE,MAAM,EAAE,GAAG,CAAA,GAAA,oJAAA,CAAA,mBAAgB,AAAD;IAElC,MAAM,aAAa,CAAA,0BAAA,oCAAA,cAAe,UAAU,KAAI,mJAAA,CAAA,sBAAmB;IACnE,MAAM,aAAa,CAAA,0BAAA,oCAAA,cAAe,UAAU,KAAI;IAEhD,+CAA+C;IAC/C,MAAM,gBAAgB,cAAc,IAAI,CACtC,CAAC,SACC,OAAO,KAAK,KAAK,WAAW,KAAK,IAAI,OAAO,MAAM,KAAK,WAAW,MAAM;IAG5E,uEAAuE;IACvE,MAAM,yBAAyB;QAC7B,wCAAwC;QACxC,KAAK,MAAM,SAAS,OAAQ;YAC1B,KAAK,MAAM,WAAW,MAAM,QAAQ,CAAE;gBACpC,IAAI,QAAQ,IAAI,KAAK,SAAS;oBAC5B,MAAM,YAAY,WAAW,IAAI,CAC/B,CAAC,OAAS,KAAK,EAAE,KAAK,QAAQ,OAAO;oBAEvC,IACE,aACA,CAAC,UAAU,IAAI,KAAK,WAAW,UAAU,IAAI,KAAK,OAAO,GACzD;wBACA,OAAO,CAAA,GAAA,iJAAA,CAAA,sBAAmB,AAAD,EAAE;oBAC7B;gBACF;YACF;QACF;QACA,OAAO,KAAK,GAAG,uBAAuB;IACxC;IAEA,2BAA2B;IAC3B,MAAM,wBAAwB;QAC5B,OAAO,WAAW,KAAK,GAAG,WAAW,MAAM;IAC7C;IAEA,2CAA2C;IAC3C,MAAM,oBAAoB,CAAC;QACzB,4CAA4C;QAC5C,MAAM,SAAS;YACb;gBAAE,OAAO,KAAK;gBAAG,OAAO;YAAO;YAC/B;gBAAE,OAAO,IAAI;gBAAI,OAAO;YAAO;YAC/B;gBAAE,OAAO;gBAAG,OAAO;YAAM;YACzB;gBAAE,OAAO,IAAI;gBAAG,OAAO;YAAM;YAC7B;gBAAE,OAAO,IAAI;gBAAG,OAAO;YAAM;YAC7B;gBAAE,OAAO,KAAK;gBAAG,OAAO;YAAO;SAChC;QAED,KAAK,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,OAAQ;YACrC,IAAI,KAAK,GAAG,CAAC,cAAc,SAAS,MAAM;gBACxC,OAAO;YACT;QACF;QAEA,2CAA2C;QAC3C,OAAO,YAAY,OAAO,CAAC;IAC7B;IAEA,sCAAsC;IACtC,MAAM,aAAa,eAAe;IAElC,4CAA4C;IAC5C,MAAM,iBAAiB;QACrB,6DAA6D;QAC7D,IAAI,eAAe,YAAY;YAC7B,OAAO;QACT;QAEA,IAAI,eAAe;YACjB,OAAO,cAAc,IAAI;QAC3B;QAEA,OAAO,kBAAkB;IAC3B;IAEA,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GA3FgB;;QACY,kJAAA,CAAA,iBAAc;QACd,mJAAA,CAAA,kBAAe;QAClB,iJAAA,CAAA,gBAAa;QACjB,oJAAA,CAAA,mBAAgB","debugId":null}},
    {"offset": {"line": 437, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-timeline-zoom.ts"],"sourcesContent":["import { useState, useCallback, useEffect, RefObject } from \"react\";\n\ninterface UseTimelineZoomProps {\n  containerRef: RefObject<HTMLDivElement>;\n  isInTimeline?: boolean;\n}\n\ninterface UseTimelineZoomReturn {\n  zoomLevel: number;\n  setZoomLevel: (zoomLevel: number | ((prev: number) => number)) => void;\n  handleWheel: (e: React.WheelEvent) => void;\n}\n\nexport function useTimelineZoom({\n  containerRef,\n  isInTimeline = false,\n}: UseTimelineZoomProps): UseTimelineZoomReturn {\n  const [zoomLevel, setZoomLevel] = useState(1);\n\n  const handleWheel = useCallback((e: React.WheelEvent) => {\n    // Only zoom if user is using pinch gesture (ctrlKey or metaKey is true)\n    if (e.ctrlKey || e.metaKey) {\n      e.preventDefault();\n      const delta = e.deltaY > 0 ? -0.15 : 0.15;\n      setZoomLevel((prev) => Math.max(0.1, Math.min(10, prev + delta)));\n    }\n    // For horizontal scrolling (when shift is held or horizontal wheel movement),\n    // let the event bubble up to allow ScrollArea to handle it\n    else if (e.shiftKey || Math.abs(e.deltaX) > Math.abs(e.deltaY)) {\n      // Don't prevent default - let ScrollArea handle horizontal scrolling\n      return;\n    }\n    // Otherwise, allow normal scrolling\n  }, []);\n\n  // Prevent browser zooming in/out when in timeline\n  useEffect(() => {\n    const preventZoom = (e: WheelEvent) => {\n      if (\n        isInTimeline &&\n        (e.ctrlKey || e.metaKey) &&\n        containerRef.current?.contains(e.target as Node)\n      ) {\n        e.preventDefault();\n      }\n    };\n\n    document.addEventListener(\"wheel\", preventZoom, { passive: false });\n\n    return () => {\n      document.removeEventListener(\"wheel\", preventZoom);\n    };\n  }, [isInTimeline, containerRef]);\n\n  return {\n    zoomLevel,\n    setZoomLevel,\n    handleWheel,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;;AAaO,SAAS,gBAAgB,KAGT;QAHS,EAC9B,YAAY,EACZ,eAAe,KAAK,EACC,GAHS;;IAI9B,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,kOAAA,CAAA,WAAQ,AAAD,EAAE;IAE3C,MAAM,cAAc,CAAA,GAAA,kOAAA,CAAA,cAAW,AAAD;oDAAE,CAAC;YAC/B,wEAAwE;YACxE,IAAI,EAAE,OAAO,IAAI,EAAE,OAAO,EAAE;gBAC1B,EAAE,cAAc;gBAChB,MAAM,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC,OAAO;gBACrC;gEAAa,CAAC,OAAS,KAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,IAAI,OAAO;;YAC3D,OAGK,IAAI,EAAE,QAAQ,IAAI,KAAK,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,GAAG,CAAC,EAAE,MAAM,GAAG;gBAC9D,qEAAqE;gBACrE;YACF;QACA,oCAAoC;QACtC;mDAAG,EAAE;IAEL,kDAAkD;IAClD,CAAA,GAAA,kOAAA,CAAA,YAAS,AAAD;qCAAE;YACR,MAAM;yDAAc,CAAC;wBAIjB;oBAHF,IACE,gBACA,CAAC,EAAE,OAAO,IAAI,EAAE,OAAO,OACvB,wBAAA,aAAa,OAAO,cAApB,4CAAA,sBAAsB,QAAQ,CAAC,EAAE,MAAM,IACvC;wBACA,EAAE,cAAc;oBAClB;gBACF;;YAEA,SAAS,gBAAgB,CAAC,SAAS,aAAa;gBAAE,SAAS;YAAM;YAEjE;6CAAO;oBACL,SAAS,mBAAmB,CAAC,SAAS;gBACxC;;QACF;oCAAG;QAAC;QAAc;KAAa;IAE/B,OAAO;QACL;QACA;QACA;IACF;AACF;GA9CgB","debugId":null}},
    {"offset": {"line": 503, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-timeline-element-resize.ts"],"sourcesContent":["import { useState, useEffect } from \"react\";\nimport { ResizeState, TimelineElement, TimelineTrack } from \"@/types/timeline\";\nimport { useMediaStore } from \"@/stores/media-store\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { DEFAULT_FPS, useProjectStore } from \"@/stores/project-store\";\nimport { snapTimeToFrame } from \"@/constants/timeline-constants\";\n\ninterface UseTimelineElementResizeProps {\n  element: TimelineElement;\n  track: TimelineTrack;\n  zoomLevel: number;\n}\n\nexport function useTimelineElementResize({\n  element,\n  track,\n  zoomLevel,\n}: UseTimelineElementResizeProps) {\n  const [resizing, setResizing] = useState<ResizeState | null>(null);\n  const { mediaFiles } = useMediaStore();\n  const {\n    updateElementStartTime,\n    updateElementTrim,\n    updateElementDuration,\n    pushHistory,\n  } = useTimelineStore();\n\n  // Set up document-level mouse listeners during resize (like proper drag behavior)\n  useEffect(() => {\n    if (!resizing) return;\n\n    const handleDocumentMouseMove = (e: MouseEvent) => {\n      updateTrimFromMouseMove({ clientX: e.clientX });\n    };\n\n    const handleDocumentMouseUp = () => {\n      handleResizeEnd();\n    };\n\n    // Add document-level listeners for proper drag behavior\n    document.addEventListener(\"mousemove\", handleDocumentMouseMove);\n    document.addEventListener(\"mouseup\", handleDocumentMouseUp);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleDocumentMouseMove);\n      document.removeEventListener(\"mouseup\", handleDocumentMouseUp);\n    };\n  }, [resizing]); // Re-run when resizing state changes\n\n  const handleResizeStart = (\n    e: React.MouseEvent,\n    elementId: string,\n    side: \"left\" | \"right\"\n  ) => {\n    e.stopPropagation();\n    e.preventDefault();\n\n    // Push history once at the start of the resize operation\n    pushHistory();\n\n    setResizing({\n      elementId,\n      side,\n      startX: e.clientX,\n      initialTrimStart: element.trimStart,\n      initialTrimEnd: element.trimEnd,\n    });\n  };\n\n  const canExtendElementDuration = () => {\n    // Text elements can always be extended\n    if (element.type === \"text\") {\n      return true;\n    }\n\n    // Media elements - check the media type\n    if (element.type === \"media\") {\n      const mediaFile = mediaFiles.find((file) => file.id === element.mediaId);\n      if (!mediaFile) return false;\n\n      // Images can be extended (static content)\n      if (mediaFile.type === \"image\") {\n        return true;\n      }\n\n      // Videos and audio cannot be extended beyond their natural duration\n      // (no additional content exists)\n      return false;\n    }\n\n    return false;\n  };\n\n  const updateTrimFromMouseMove = (e: { clientX: number }) => {\n    if (!resizing) return;\n\n    const deltaX = e.clientX - resizing.startX;\n    // Reasonable sensitivity for resize operations - similar to timeline scale\n    const deltaTime = deltaX / (50 * zoomLevel);\n\n    // Get project FPS for frame snapping\n    const projectStore = useProjectStore.getState();\n    const projectFps = projectStore.activeProject?.fps || DEFAULT_FPS;\n\n    if (resizing.side === \"left\") {\n      // Left resize - different behavior for media vs text/image elements\n      const maxAllowed = element.duration - resizing.initialTrimEnd - 0.1;\n      const calculated = resizing.initialTrimStart + deltaTime;\n\n      if (calculated >= 0) {\n        // Normal trimming within available content\n        const newTrimStart = snapTimeToFrame(\n          Math.min(maxAllowed, calculated),\n          projectFps\n        );\n        const trimDelta = newTrimStart - resizing.initialTrimStart;\n        const newStartTime = snapTimeToFrame(\n          element.startTime + trimDelta,\n          projectFps\n        );\n\n        updateElementTrim(\n          track.id,\n          element.id,\n          newTrimStart,\n          resizing.initialTrimEnd,\n          false\n        );\n        updateElementStartTime(track.id, element.id, newStartTime, false);\n      } else {\n        // Trying to extend beyond trimStart = 0\n        if (canExtendElementDuration()) {\n          // Text/Image: extend element to the left by moving startTime and increasing duration\n          const extensionAmount = Math.abs(calculated);\n          const maxExtension = element.startTime;\n          const actualExtension = Math.min(extensionAmount, maxExtension);\n          const newStartTime = snapTimeToFrame(\n            element.startTime - actualExtension,\n            projectFps\n          );\n          const newDuration = snapTimeToFrame(\n            element.duration + actualExtension,\n            projectFps\n          );\n\n          // Keep trimStart at 0 and extend the element\n          updateElementTrim(\n            track.id,\n            element.id,\n            0,\n            resizing.initialTrimEnd,\n            false\n          );\n          updateElementDuration(track.id, element.id, newDuration, false);\n          updateElementStartTime(track.id, element.id, newStartTime, false);\n        } else {\n          // Video/Audio: can't extend beyond original content - limit to trimStart = 0\n          const newTrimStart = 0;\n          const trimDelta = newTrimStart - resizing.initialTrimStart;\n          const newStartTime = snapTimeToFrame(\n            element.startTime + trimDelta,\n            projectFps\n          );\n\n          updateElementTrim(\n            track.id,\n            element.id,\n            newTrimStart,\n            resizing.initialTrimEnd,\n            false\n          );\n          updateElementStartTime(track.id, element.id, newStartTime, false);\n        }\n      }\n    } else {\n      // Right resize - can extend duration for supported element types\n      const calculated = resizing.initialTrimEnd - deltaTime;\n\n      if (calculated < 0) {\n        // We're trying to extend beyond original duration\n        if (canExtendElementDuration()) {\n          // Extend the duration instead of reducing trimEnd further\n          const extensionNeeded = Math.abs(calculated);\n          const newDuration = snapTimeToFrame(\n            element.duration + extensionNeeded,\n            projectFps\n          );\n          const newTrimEnd = 0; // Reset trimEnd to 0 since we're extending\n\n          // Update duration first, then trim\n          updateElementDuration(track.id, element.id, newDuration, false);\n          updateElementTrim(\n            track.id,\n            element.id,\n            resizing.initialTrimStart,\n            newTrimEnd,\n            false\n          );\n        } else {\n          // Can't extend - just set trimEnd to 0 (maximum possible extension)\n          updateElementTrim(\n            track.id,\n            element.id,\n            resizing.initialTrimStart,\n            0,\n            false\n          );\n        }\n      } else {\n        // Normal trimming within original duration\n        // Calculate the desired end time based on mouse movement\n        const currentEndTime =\n          element.startTime +\n          element.duration -\n          element.trimStart -\n          element.trimEnd;\n        const desiredEndTime = currentEndTime + deltaTime;\n\n        // Snap the desired end time to frame\n        const snappedEndTime = snapTimeToFrame(desiredEndTime, projectFps);\n\n        // Calculate what trimEnd should be to achieve this snapped end time\n        const newTrimEnd = Math.max(\n          0,\n          element.duration -\n            element.trimStart -\n            (snappedEndTime - element.startTime)\n        );\n\n        // Ensure we don't trim more than available content (leave at least 0.1s visible)\n        const maxTrimEnd = element.duration - element.trimStart - 0.1;\n        const finalTrimEnd = Math.min(maxTrimEnd, newTrimEnd);\n\n        updateElementTrim(\n          track.id,\n          element.id,\n          element.trimStart,\n          finalTrimEnd,\n          false\n        );\n      }\n    }\n  };\n\n  const handleResizeEnd = () => {\n    setResizing(null);\n  };\n\n  return {\n    resizing,\n    isResizing: resizing !== null,\n    handleResizeStart,\n    // Return empty handlers since we use document listeners now\n    handleResizeMove: () => {}, // Not used anymore\n    handleResizeEnd: () => {}, // Not used anymore\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 686, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-timeline-snapping.ts"],"sourcesContent":["import { useCallback } from \"react\";\nimport { TimelineTrack } from \"@/types/timeline\";\nimport { TIMELINE_CONSTANTS } from \"@/constants/timeline-constants\";\n\nexport interface SnapPoint {\n  time: number;\n  type: \"element-start\" | \"element-end\" | \"playhead\";\n  elementId?: string;\n  trackId?: string;\n}\n\nexport interface SnapResult {\n  snappedTime: number;\n  snapPoint: SnapPoint | null;\n  snapDistance: number;\n}\n\nexport interface UseTimelineSnappingOptions {\n  snapThreshold?: number; // Distance in pixels to trigger snapping\n  enableElementSnapping?: boolean;\n  enablePlayheadSnapping?: boolean;\n}\n\nexport function useTimelineSnapping({\n  snapThreshold = 10,\n  enableElementSnapping = true,\n  enablePlayheadSnapping = true,\n}: UseTimelineSnappingOptions = {}) {\n  const findSnapPoints = useCallback(\n    (\n      tracks: TimelineTrack[],\n      currentTime: number,\n      playheadTime: number,\n      zoomLevel: number,\n      excludeElementId?: string\n    ): SnapPoint[] => {\n      const snapPoints: SnapPoint[] = [];\n\n      // Add element snap points\n      if (enableElementSnapping) {\n        tracks.forEach((track) => {\n          track.elements.forEach((element) => {\n            // Skip the element being dragged\n            if (element.id === excludeElementId) return;\n\n            const elementStart = element.startTime;\n            const elementEnd =\n              element.startTime +\n              (element.duration - element.trimStart - element.trimEnd);\n\n            snapPoints.push(\n              {\n                time: elementStart,\n                type: \"element-start\",\n                elementId: element.id,\n                trackId: track.id,\n              },\n              {\n                time: elementEnd,\n                type: \"element-end\",\n                elementId: element.id,\n                trackId: track.id,\n              }\n            );\n          });\n        });\n      }\n\n      // Add playhead snap point\n      if (enablePlayheadSnapping) {\n        snapPoints.push({\n          time: playheadTime,\n          type: \"playhead\",\n        });\n      }\n\n      return snapPoints;\n    },\n    [enableElementSnapping, enablePlayheadSnapping]\n  );\n\n  const snapToNearestPoint = useCallback(\n    (\n      targetTime: number,\n      snapPoints: SnapPoint[],\n      zoomLevel: number\n    ): SnapResult => {\n      const pixelsPerSecond = TIMELINE_CONSTANTS.PIXELS_PER_SECOND * zoomLevel;\n      const thresholdInSeconds = snapThreshold / pixelsPerSecond;\n\n      let closestSnapPoint: SnapPoint | null = null;\n      let closestDistance = Infinity;\n\n      snapPoints.forEach((snapPoint) => {\n        const distance = Math.abs(targetTime - snapPoint.time);\n        if (distance < thresholdInSeconds && distance < closestDistance) {\n          closestDistance = distance;\n          closestSnapPoint = snapPoint;\n        }\n      });\n\n      return {\n        snappedTime: closestSnapPoint\n          ? (closestSnapPoint as SnapPoint).time\n          : targetTime,\n        snapPoint: closestSnapPoint,\n        snapDistance: closestDistance,\n      };\n    },\n    [snapThreshold]\n  );\n\n  const snapElementPosition = useCallback(\n    (\n      targetTime: number,\n      tracks: TimelineTrack[],\n      playheadTime: number,\n      zoomLevel: number,\n      excludeElementId?: string\n    ): SnapResult => {\n      const snapPoints = findSnapPoints(\n        tracks,\n        targetTime,\n        playheadTime,\n        zoomLevel,\n        excludeElementId\n      );\n\n      return snapToNearestPoint(targetTime, snapPoints, zoomLevel);\n    },\n    [findSnapPoints, snapToNearestPoint]\n  );\n\n  const snapElementEdge = useCallback(\n    (\n      targetTime: number,\n      elementDuration: number,\n      tracks: TimelineTrack[],\n      playheadTime: number,\n      zoomLevel: number,\n      excludeElementId?: string,\n      snapToStart = true // true for start edge, false for end edge\n    ): SnapResult => {\n      const snapPoints = findSnapPoints(\n        tracks,\n        targetTime,\n        playheadTime,\n        zoomLevel,\n        excludeElementId\n      );\n\n      // For end edge snapping, we need to account for element duration\n      const effectiveTargetTime = snapToStart\n        ? targetTime\n        : targetTime + elementDuration;\n      const snapResult = snapToNearestPoint(\n        effectiveTargetTime,\n        snapPoints,\n        zoomLevel\n      );\n\n      // Adjust the snapped time back for end edge\n      if (!snapToStart && snapResult.snapPoint) {\n        snapResult.snappedTime = snapResult.snappedTime - elementDuration;\n      }\n\n      return snapResult;\n    },\n    [findSnapPoints, snapToNearestPoint]\n  );\n\n  return {\n    snapElementPosition,\n    snapElementEdge,\n    findSnapPoints,\n    snapToNearestPoint,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AAEA;;;;AAqBO,SAAS;QAAoB,EAClC,gBAAgB,EAAE,EAClB,wBAAwB,IAAI,EAC5B,yBAAyB,IAAI,EACF,GAJO,iEAIJ,CAAC;;IAC/B,MAAM,iBAAiB,CAAA,GAAA,kOAAA,CAAA,cAAW,AAAD;2DAC/B,CACE,QACA,aACA,cACA,WACA;YAEA,MAAM,aAA0B,EAAE;YAElC,0BAA0B;YAC1B,IAAI,uBAAuB;gBACzB,OAAO,OAAO;uEAAC,CAAC;wBACd,MAAM,QAAQ,CAAC,OAAO;+EAAC,CAAC;gCACtB,iCAAiC;gCACjC,IAAI,QAAQ,EAAE,KAAK,kBAAkB;gCAErC,MAAM,eAAe,QAAQ,SAAS;gCACtC,MAAM,aACJ,QAAQ,SAAS,GACjB,CAAC,QAAQ,QAAQ,GAAG,QAAQ,SAAS,GAAG,QAAQ,OAAO;gCAEzD,WAAW,IAAI,CACb;oCACE,MAAM;oCACN,MAAM;oCACN,WAAW,QAAQ,EAAE;oCACrB,SAAS,MAAM,EAAE;gCACnB,GACA;oCACE,MAAM;oCACN,MAAM;oCACN,WAAW,QAAQ,EAAE;oCACrB,SAAS,MAAM,EAAE;gCACnB;4BAEJ;;oBACF;;YACF;YAEA,0BAA0B;YAC1B,IAAI,wBAAwB;gBAC1B,WAAW,IAAI,CAAC;oBACd,MAAM;oBACN,MAAM;gBACR;YACF;YAEA,OAAO;QACT;0DACA;QAAC;QAAuB;KAAuB;IAGjD,MAAM,qBAAqB,CAAA,GAAA,kOAAA,CAAA,cAAW,AAAD;+DACnC,CACE,YACA,YACA;YAEA,MAAM,kBAAkB,2JAAA,CAAA,qBAAkB,CAAC,iBAAiB,GAAG;YAC/D,MAAM,qBAAqB,gBAAgB;YAE3C,IAAI,mBAAqC;YACzC,IAAI,kBAAkB;YAEtB,WAAW,OAAO;uEAAC,CAAC;oBAClB,MAAM,WAAW,KAAK,GAAG,CAAC,aAAa,UAAU,IAAI;oBACrD,IAAI,WAAW,sBAAsB,WAAW,iBAAiB;wBAC/D,kBAAkB;wBAClB,mBAAmB;oBACrB;gBACF;;YAEA,OAAO;gBACL,aAAa,mBACT,AAAC,iBAA+B,IAAI,GACpC;gBACJ,WAAW;gBACX,cAAc;YAChB;QACF;8DACA;QAAC;KAAc;IAGjB,MAAM,sBAAsB,CAAA,GAAA,kOAAA,CAAA,cAAW,AAAD;gEACpC,CACE,YACA,QACA,cACA,WACA;YAEA,MAAM,aAAa,eACjB,QACA,YACA,cACA,WACA;YAGF,OAAO,mBAAmB,YAAY,YAAY;QACpD;+DACA;QAAC;QAAgB;KAAmB;IAGtC,MAAM,kBAAkB,CAAA,GAAA,kOAAA,CAAA,cAAW,AAAD;4DAChC,SACE,YACA,iBACA,QACA,cACA,WACA;gBACA,+EAAc,KAAK,0CAA0C;;YAE7D,MAAM,aAAa,eACjB,QACA,YACA,cACA,WACA;YAGF,iEAAiE;YACjE,MAAM,sBAAsB,cACxB,aACA,aAAa;YACjB,MAAM,aAAa,mBACjB,qBACA,YACA;YAGF,4CAA4C;YAC5C,IAAI,CAAC,eAAe,WAAW,SAAS,EAAE;gBACxC,WAAW,WAAW,GAAG,WAAW,WAAW,GAAG;YACpD;YAEA,OAAO;QACT;2DACA;QAAC;QAAgB;KAAmB;IAGtC,OAAO;QACL;QACA;QACA;QACA;IACF;AACF;GA1JgB","debugId":null}},
    {"offset": {"line": 807, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-edge-auto-scroll.ts"],"sourcesContent":["import { useEffect, useRef } from \"react\";\r\n\r\ninterface UseEdgeAutoScrollParams {\r\n  isActive: boolean;\r\n  getMouseClientX: () => number;\r\n  rulerScrollRef: React.RefObject<HTMLDivElement>;\r\n  tracksScrollRef: React.RefObject<HTMLDivElement>;\r\n  contentWidth: number;\r\n  edgeThreshold?: number;\r\n  maxScrollSpeed?: number;\r\n}\r\n\r\n// Provides smooth edge auto-scrolling for horizontal timeline interactions.\r\nexport function useEdgeAutoScroll({\r\n  isActive,\r\n  getMouseClientX,\r\n  rulerScrollRef,\r\n  tracksScrollRef,\r\n  contentWidth,\r\n  edgeThreshold = 100,\r\n  maxScrollSpeed = 15,\r\n}: UseEdgeAutoScrollParams): void {\r\n  const rafRef = useRef<number | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (!isActive) {\r\n      if (rafRef.current) {\r\n        cancelAnimationFrame(rafRef.current);\r\n        rafRef.current = null;\r\n      }\r\n      return;\r\n    }\r\n\r\n    const step = () => {\r\n      const rulerViewport = rulerScrollRef.current;\r\n      const tracksViewport = tracksScrollRef.current;\r\n      if (!rulerViewport || !tracksViewport) {\r\n        rafRef.current = requestAnimationFrame(step);\r\n        return;\r\n      }\r\n\r\n      const viewportRect = rulerViewport.getBoundingClientRect();\r\n      const mouseX = getMouseClientX();\r\n      const mouseXRelative = mouseX - viewportRect.left;\r\n\r\n      const viewportWidth = rulerViewport.clientWidth;\r\n      const intrinsicContentWidth = rulerViewport.scrollWidth;\r\n      const effectiveContentWidth = Math.max(\r\n        contentWidth,\r\n        intrinsicContentWidth\r\n      );\r\n      const scrollMax = Math.max(0, effectiveContentWidth - viewportWidth);\r\n\r\n      let scrollSpeed = 0;\r\n\r\n      if (mouseXRelative < edgeThreshold && rulerViewport.scrollLeft > 0) {\r\n        const edgeDistance = Math.max(0, mouseXRelative);\r\n        const intensity = 1 - edgeDistance / edgeThreshold;\r\n        scrollSpeed = -maxScrollSpeed * intensity;\r\n      } else if (\r\n        mouseXRelative > viewportWidth - edgeThreshold &&\r\n        rulerViewport.scrollLeft < scrollMax\r\n      ) {\r\n        const edgeDistance = Math.max(\r\n          0,\r\n          viewportWidth - edgeThreshold - mouseXRelative\r\n        );\r\n        const intensity = 1 - edgeDistance / edgeThreshold;\r\n        scrollSpeed = maxScrollSpeed * intensity;\r\n      }\r\n\r\n      if (scrollSpeed !== 0) {\r\n        const newScrollLeft = Math.max(\r\n          0,\r\n          Math.min(scrollMax, rulerViewport.scrollLeft + scrollSpeed)\r\n        );\r\n        rulerViewport.scrollLeft = newScrollLeft;\r\n        tracksViewport.scrollLeft = newScrollLeft;\r\n      }\r\n\r\n      rafRef.current = requestAnimationFrame(step);\r\n    };\r\n\r\n    rafRef.current = requestAnimationFrame(step);\r\n\r\n    return () => {\r\n      if (rafRef.current) {\r\n        cancelAnimationFrame(rafRef.current);\r\n        rafRef.current = null;\r\n      }\r\n    };\r\n  }, [\r\n    isActive,\r\n    getMouseClientX,\r\n    rulerScrollRef,\r\n    tracksScrollRef,\r\n    contentWidth,\r\n    edgeThreshold,\r\n    maxScrollSpeed,\r\n  ]);\r\n}\r\n"],"names":[],"mappings":";;;AAAA;;;AAaO,SAAS,kBAAkB,KAQR;QARQ,EAChC,QAAQ,EACR,eAAe,EACf,cAAc,EACd,eAAe,EACf,YAAY,EACZ,gBAAgB,GAAG,EACnB,iBAAiB,EAAE,EACK,GARQ;;IAShC,MAAM,SAAS,CAAA,GAAA,kOAAA,CAAA,SAAM,AAAD,EAAiB;IAErC,CAAA,GAAA,kOAAA,CAAA,YAAS,AAAD;uCAAE;YACR,IAAI,CAAC,UAAU;gBACb,IAAI,OAAO,OAAO,EAAE;oBAClB,qBAAqB,OAAO,OAAO;oBACnC,OAAO,OAAO,GAAG;gBACnB;gBACA;YACF;YAEA,MAAM;oDAAO;oBACX,MAAM,gBAAgB,eAAe,OAAO;oBAC5C,MAAM,iBAAiB,gBAAgB,OAAO;oBAC9C,IAAI,CAAC,iBAAiB,CAAC,gBAAgB;wBACrC,OAAO,OAAO,GAAG,sBAAsB;wBACvC;oBACF;oBAEA,MAAM,eAAe,cAAc,qBAAqB;oBACxD,MAAM,SAAS;oBACf,MAAM,iBAAiB,SAAS,aAAa,IAAI;oBAEjD,MAAM,gBAAgB,cAAc,WAAW;oBAC/C,MAAM,wBAAwB,cAAc,WAAW;oBACvD,MAAM,wBAAwB,KAAK,GAAG,CACpC,cACA;oBAEF,MAAM,YAAY,KAAK,GAAG,CAAC,GAAG,wBAAwB;oBAEtD,IAAI,cAAc;oBAElB,IAAI,iBAAiB,iBAAiB,cAAc,UAAU,GAAG,GAAG;wBAClE,MAAM,eAAe,KAAK,GAAG,CAAC,GAAG;wBACjC,MAAM,YAAY,IAAI,eAAe;wBACrC,cAAc,CAAC,iBAAiB;oBAClC,OAAO,IACL,iBAAiB,gBAAgB,iBACjC,cAAc,UAAU,GAAG,WAC3B;wBACA,MAAM,eAAe,KAAK,GAAG,CAC3B,GACA,gBAAgB,gBAAgB;wBAElC,MAAM,YAAY,IAAI,eAAe;wBACrC,cAAc,iBAAiB;oBACjC;oBAEA,IAAI,gBAAgB,GAAG;wBACrB,MAAM,gBAAgB,KAAK,GAAG,CAC5B,GACA,KAAK,GAAG,CAAC,WAAW,cAAc,UAAU,GAAG;wBAEjD,cAAc,UAAU,GAAG;wBAC3B,eAAe,UAAU,GAAG;oBAC9B;oBAEA,OAAO,OAAO,GAAG,sBAAsB;gBACzC;;YAEA,OAAO,OAAO,GAAG,sBAAsB;YAEvC;+CAAO;oBACL,IAAI,OAAO,OAAO,EAAE;wBAClB,qBAAqB,OAAO,OAAO;wBACnC,OAAO,OAAO,GAAG;oBACnB;gBACF;;QACF;sCAAG;QACD;QACA;QACA;QACA;QACA;QACA;QACA;KACD;AACH;GAvFgB","debugId":null}},
    {"offset": {"line": 889, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-timeline-playhead.ts"],"sourcesContent":["import { snapTimeToFrame } from \"@/constants/timeline-constants\";\nimport { DEFAULT_FPS, useProjectStore } from \"@/stores/project-store\";\nimport { usePlaybackStore } from \"@/stores/playback-store\";\nimport { useState, useEffect, useCallback, useRef } from \"react\";\nimport { useEdgeAutoScroll } from \"@/hooks/use-edge-auto-scroll\";\n\ninterface UseTimelinePlayheadProps {\n  currentTime: number;\n  duration: number;\n  zoomLevel: number;\n  seek: (time: number) => void;\n  rulerRef: React.RefObject<HTMLDivElement>;\n  rulerScrollRef: React.RefObject<HTMLDivElement>;\n  tracksScrollRef: React.RefObject<HTMLDivElement>;\n  playheadRef?: React.RefObject<HTMLDivElement>;\n}\n\nexport function useTimelinePlayhead({\n  currentTime,\n  duration,\n  zoomLevel,\n  seek,\n  rulerRef,\n  rulerScrollRef,\n  tracksScrollRef,\n  playheadRef,\n}: UseTimelinePlayheadProps) {\n  // Playhead scrubbing state\n  const [isScrubbing, setIsScrubbing] = useState(false);\n  const [scrubTime, setScrubTime] = useState<number | null>(null);\n\n  // Ruler drag detection state\n  const [isDraggingRuler, setIsDraggingRuler] = useState(false);\n  const [hasDraggedRuler, setHasDraggedRuler] = useState(false);\n  const lastMouseXRef = useRef<number>(0);\n\n  const playheadPosition =\n    isScrubbing && scrubTime !== null ? scrubTime : currentTime;\n\n  // --- Playhead Scrubbing Handlers ---\n  const handlePlayheadMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      e.preventDefault();\n      e.stopPropagation(); // Prevent ruler drag from triggering\n      setIsScrubbing(true);\n      handleScrub(e);\n    },\n    [duration, zoomLevel]\n  );\n\n  // Ruler mouse down handler\n  const handleRulerMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      // Only handle left mouse button\n      if (e.button !== 0) return;\n\n      // Don't interfere if clicking on the playhead itself\n      if (playheadRef?.current?.contains(e.target as Node)) return;\n\n      e.preventDefault();\n      setIsDraggingRuler(true);\n      setHasDraggedRuler(false);\n\n      // Start scrubbing immediately\n      setIsScrubbing(true);\n      handleScrub(e);\n    },\n    [duration, zoomLevel]\n  );\n\n  const handleScrub = useCallback(\n    (e: MouseEvent | React.MouseEvent) => {\n      const ruler = rulerRef.current;\n      if (!ruler) return;\n      const rect = ruler.getBoundingClientRect();\n      const rawX = e.clientX - rect.left;\n\n      // Get the timeline content width based on duration and zoom\n      const timelineContentWidth = duration * 50 * zoomLevel; // TIMELINE_CONSTANTS.PIXELS_PER_SECOND = 50\n\n      // Constrain x to be within the timeline content bounds\n      const x = Math.max(0, Math.min(timelineContentWidth, rawX));\n\n      const rawTime = Math.max(0, Math.min(duration, x / (50 * zoomLevel)));\n      // Use frame snapping for playhead scrubbing\n      const projectStore = useProjectStore.getState();\n      const projectFps = projectStore.activeProject?.fps || DEFAULT_FPS;\n      const time = snapTimeToFrame(rawTime, projectFps);\n\n      // Debug logging\n      if (rawX < 0 || x !== rawX) {\n        console.log(\n          \"PLAYHEAD DEBUG:\",\n          JSON.stringify({\n            mouseX: e.clientX,\n            rulerLeft: rect.left,\n            rawX,\n            constrainedX: x,\n            timelineContentWidth,\n            rawTime,\n            finalTime: time,\n            duration,\n            zoomLevel,\n            playheadPx: time * 50 * zoomLevel,\n          })\n        );\n      }\n\n      setScrubTime(time);\n      seek(time); // update video preview in real time\n\n      // Store mouse position for auto-scrolling\n      lastMouseXRef.current = e.clientX;\n    },\n    [duration, zoomLevel, seek, rulerRef]\n  );\n\n  useEdgeAutoScroll({\n    isActive: isScrubbing,\n    getMouseClientX: () => lastMouseXRef.current,\n    rulerScrollRef,\n    tracksScrollRef,\n    contentWidth: duration * 50 * zoomLevel,\n  });\n\n  // Mouse move/up event handlers\n  useEffect(() => {\n    if (!isScrubbing) return;\n\n    const onMouseMove = (e: MouseEvent) => {\n      handleScrub(e);\n      // Mark that we've dragged if ruler drag is active\n      if (isDraggingRuler) {\n        setHasDraggedRuler(true);\n      }\n    };\n\n    const onMouseUp = (e: MouseEvent) => {\n      setIsScrubbing(false);\n      if (scrubTime !== null) seek(scrubTime); // finalize seek\n      setScrubTime(null);\n\n      // Handle ruler click vs drag\n      if (isDraggingRuler) {\n        setIsDraggingRuler(false);\n        // If we didn't drag, treat it as a click-to-seek\n        if (!hasDraggedRuler) {\n          handleScrub(e);\n        }\n        setHasDraggedRuler(false);\n      }\n    };\n\n    window.addEventListener(\"mousemove\", onMouseMove);\n    window.addEventListener(\"mouseup\", onMouseUp);\n\n    // Edge auto-scroll is handled by useEdgeAutoScroll\n\n    return () => {\n      window.removeEventListener(\"mousemove\", onMouseMove);\n      window.removeEventListener(\"mouseup\", onMouseUp);\n      // nothing to cleanup for edge auto scroll\n    };\n  }, [\n    isScrubbing,\n    scrubTime,\n    seek,\n    handleScrub,\n    isDraggingRuler,\n    hasDraggedRuler,\n    // edge auto scroll hook is independent\n  ]);\n\n  // --- Playhead auto-scroll effect (only during playback) ---\n  useEffect(() => {\n    const { isPlaying } = usePlaybackStore.getState();\n\n    // Only auto-scroll during playback, not during manual interactions\n    if (!isPlaying || isScrubbing) return;\n\n    const rulerViewport = rulerScrollRef.current;\n    const tracksViewport = tracksScrollRef.current;\n    if (!rulerViewport || !tracksViewport) return;\n\n    const playheadPx = playheadPosition * 50 * zoomLevel; // TIMELINE_CONSTANTS.PIXELS_PER_SECOND = 50\n    const viewportWidth = rulerViewport.clientWidth;\n    const scrollMin = 0;\n    const scrollMax = rulerViewport.scrollWidth - viewportWidth;\n\n    // Only auto-scroll if playhead is completely out of view (no buffer)\n    const needsScroll =\n      playheadPx < rulerViewport.scrollLeft ||\n      playheadPx > rulerViewport.scrollLeft + viewportWidth;\n\n    if (needsScroll) {\n      // Center the playhead in the viewport\n      const desiredScroll = Math.max(\n        scrollMin,\n        Math.min(scrollMax, playheadPx - viewportWidth / 2)\n      );\n      rulerViewport.scrollLeft = tracksViewport.scrollLeft = desiredScroll;\n    }\n  }, [\n    playheadPosition,\n    duration,\n    zoomLevel,\n    rulerScrollRef,\n    tracksScrollRef,\n    isScrubbing,\n  ]);\n\n  return {\n    playheadPosition,\n    handlePlayheadMouseDown,\n    handleRulerMouseDown,\n    isDraggingRuler,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1094, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-selection-box.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from \"react\";\n\ninterface UseSelectionBoxProps {\n  containerRef: React.RefObject<HTMLElement>;\n  playheadRef?: React.RefObject<HTMLElement>;\n  onSelectionComplete: (\n    elements: { trackId: string; elementId: string }[]\n  ) => void;\n  isEnabled?: boolean;\n}\n\ninterface SelectionBoxState {\n  startPos: { x: number; y: number };\n  currentPos: { x: number; y: number };\n  isActive: boolean;\n}\n\nexport function useSelectionBox({\n  containerRef,\n  playheadRef,\n  onSelectionComplete,\n  isEnabled = true,\n}: UseSelectionBoxProps) {\n  const [selectionBox, setSelectionBox] = useState<SelectionBoxState | null>(\n    null\n  );\n  const [justFinishedSelecting, setJustFinishedSelecting] = useState(false);\n\n  // Mouse down handler to start selection\n  const handleMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      if (!isEnabled) return;\n\n      // Only start selection on empty space clicks\n      if ((e.target as HTMLElement).closest(\".timeline-element\")) {\n        return;\n      }\n      if (playheadRef?.current?.contains(e.target as Node)) {\n        return;\n      }\n      if ((e.target as HTMLElement).closest(\"[data-track-labels]\")) {\n        return;\n      }\n      // Don't start selection when clicking in the ruler area - this interferes with playhead dragging\n      if ((e.target as HTMLElement).closest(\"[data-ruler-area]\")) {\n        return;\n      }\n\n      setSelectionBox({\n        startPos: { x: e.clientX, y: e.clientY },\n        currentPos: { x: e.clientX, y: e.clientY },\n        isActive: false, // Will become active when mouse moves\n      });\n    },\n    [isEnabled, playheadRef]\n  );\n\n  // Function to select elements within the selection box\n  const selectElementsInBox = useCallback(\n    (startPos: { x: number; y: number }, endPos: { x: number; y: number }) => {\n      if (!containerRef.current) return;\n\n      const container = containerRef.current;\n      const containerRect = container.getBoundingClientRect();\n\n      // Calculate selection rectangle in container coordinates\n      const startX = startPos.x - containerRect.left;\n      const startY = startPos.y - containerRect.top;\n      const endX = endPos.x - containerRect.left;\n      const endY = endPos.y - containerRect.top;\n\n      const selectionRect = {\n        left: Math.min(startX, endX),\n        top: Math.min(startY, endY),\n        right: Math.max(startX, endX),\n        bottom: Math.max(startY, endY),\n      };\n\n      // Find all timeline elements within the selection rectangle\n      const timelineElements = container.querySelectorAll(\".timeline-element\");\n\n      const selectedElements: { trackId: string; elementId: string }[] = [];\n\n      timelineElements.forEach((element) => {\n        const elementRect = element.getBoundingClientRect();\n        // Use absolute coordinates for more accurate intersection detection\n        const elementAbsolute = {\n          left: elementRect.left,\n          top: elementRect.top,\n          right: elementRect.right,\n          bottom: elementRect.bottom,\n        };\n\n        const selectionAbsolute = {\n          left: startPos.x,\n          top: startPos.y,\n          right: endPos.x,\n          bottom: endPos.y,\n        };\n\n        // Normalize selection rectangle (handle dragging in any direction)\n        const normalizedSelection = {\n          left: Math.min(selectionAbsolute.left, selectionAbsolute.right),\n          top: Math.min(selectionAbsolute.top, selectionAbsolute.bottom),\n          right: Math.max(selectionAbsolute.left, selectionAbsolute.right),\n          bottom: Math.max(selectionAbsolute.top, selectionAbsolute.bottom),\n        };\n\n        const elementId = element.getAttribute(\"data-element-id\");\n        const trackId = element.getAttribute(\"data-track-id\");\n\n        // Check if element intersects with selection rectangle (any overlap)\n        // Using absolute coordinates for more precise detection\n        const intersects = !(\n          elementAbsolute.right < normalizedSelection.left ||\n          elementAbsolute.left > normalizedSelection.right ||\n          elementAbsolute.bottom < normalizedSelection.top ||\n          elementAbsolute.top > normalizedSelection.bottom\n        );\n\n        if (intersects && elementId && trackId) {\n          selectedElements.push({ trackId, elementId });\n        }\n      });\n\n      // Always call the callback - with elements or empty array to clear selection\n      console.log(\n        JSON.stringify({ selectElementsInBox: selectedElements.length })\n      );\n      onSelectionComplete(selectedElements);\n    },\n    [containerRef, onSelectionComplete]\n  );\n\n  // Effect to track selection box movement\n  useEffect(() => {\n    if (!selectionBox) return;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const deltaX = Math.abs(e.clientX - selectionBox.startPos.x);\n      const deltaY = Math.abs(e.clientY - selectionBox.startPos.y);\n\n      // Start selection if mouse moved more than 5px\n      const shouldActivate = deltaX > 5 || deltaY > 5;\n\n      const newSelectionBox = {\n        ...selectionBox,\n        currentPos: { x: e.clientX, y: e.clientY },\n        isActive: shouldActivate || selectionBox.isActive,\n      };\n\n      setSelectionBox(newSelectionBox);\n\n      // Real-time visual feedback: update selection as we drag\n      if (newSelectionBox.isActive) {\n        selectElementsInBox(\n          newSelectionBox.startPos,\n          newSelectionBox.currentPos\n        );\n      }\n    };\n\n    const handleMouseUp = () => {\n      console.log(\n        JSON.stringify({ mouseUp: { wasActive: selectionBox?.isActive } })\n      );\n\n      // If we had an active selection, mark that we just finished selecting\n      if (selectionBox?.isActive) {\n        console.log(JSON.stringify({ settingJustFinishedSelecting: true }));\n        setJustFinishedSelecting(true);\n        // Clear the flag after a short delay to allow click events to check it\n        setTimeout(() => {\n          console.log(JSON.stringify({ clearingJustFinishedSelecting: true }));\n          setJustFinishedSelecting(false);\n        }, 50);\n      }\n\n      // Don't call selectElementsInBox again - real-time selection already handled it\n      // Just clean up the selection box visual\n      setSelectionBox(null);\n    };\n\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    window.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      window.removeEventListener(\"mousemove\", handleMouseMove);\n      window.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [selectionBox, selectElementsInBox]);\n\n  useEffect(() => {\n    if (!selectionBox?.isActive) return;\n\n    const previousBodyUserSelect = document.body.style.userSelect;\n    const container = containerRef.current;\n    const previousContainerUserSelect = container?.style.userSelect ?? \"\";\n\n    document.body.style.userSelect = \"none\";\n    if (container) container.style.userSelect = \"none\";\n\n    return () => {\n      document.body.style.userSelect = previousBodyUserSelect;\n      if (container) container.style.userSelect = previousContainerUserSelect;\n    };\n  }, [selectionBox?.isActive, containerRef]);\n\n  return {\n    selectionBox,\n    handleMouseDown,\n    isSelecting: selectionBox?.isActive || false,\n    justFinishedSelecting,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1309, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-frame-cache.ts"],"sourcesContent":["import { useRef, useCallback } from \"react\";\nimport {\n  TimelineTrack,\n  TimelineElement,\n  MediaElement,\n  TextElement,\n} from \"@/types/timeline\";\nimport { MediaFile } from \"@/types/media\";\nimport { TProject } from \"@/types/project\";\n\ninterface CachedFrame {\n  imageData: ImageData;\n  timelineHash: string;\n  timestamp: number;\n}\n\ninterface FrameCacheOptions {\n  maxCacheSize?: number; // Maximum number of cached frames\n  cacheResolution?: number; // Frames per second to cache at\n}\n\n// Shared singleton cache across hook instances (HMR-safe)\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst __frameCacheGlobal: any = globalThis as any;\nconst __sharedFrameCache: Map<number, CachedFrame> =\n  __frameCacheGlobal.__sharedFrameCache ?? new Map<number, CachedFrame>();\n__frameCacheGlobal.__sharedFrameCache = __sharedFrameCache;\n\nexport function useFrameCache(options: FrameCacheOptions = {}) {\n  const { maxCacheSize = 300, cacheResolution = 30 } = options; // 10 seconds at 30fps\n\n  const frameCacheRef = useRef(__sharedFrameCache);\n\n  // Generate a hash of the timeline state that affects rendering\n  const getTimelineHash = useCallback(\n    (\n      time: number,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      sceneId?: string\n    ): string => {\n      // Get elements that are active at this time\n      const activeElements: Array<{\n        id: string;\n        type: string;\n        startTime: number;\n        duration: number;\n        trimStart: number;\n        trimEnd: number;\n        mediaId?: string;\n        // Text-specific properties\n        content?: string;\n        fontSize?: number;\n        fontFamily?: string;\n        color?: string;\n        backgroundColor?: string;\n        x?: number;\n        y?: number;\n        rotation?: number;\n        opacity?: number;\n      }> = [];\n\n      for (const track of tracks) {\n        if (track.muted) continue;\n\n        for (const element of track.elements) {\n          // Check if element has hidden property (some elements might not have it)\n          const isHidden = \"hidden\" in element ? element.hidden : false;\n          if (isHidden) continue;\n\n          const elementStart = element.startTime;\n          const elementEnd =\n            element.startTime +\n            (element.duration - element.trimStart - element.trimEnd);\n\n          if (time >= elementStart && time < elementEnd) {\n            if (element.type === \"media\") {\n              const mediaElement = element as MediaElement;\n              activeElements.push({\n                id: element.id,\n                type: element.type,\n                startTime: element.startTime,\n                duration: element.duration,\n                trimStart: element.trimStart,\n                trimEnd: element.trimEnd,\n                mediaId: mediaElement.mediaId,\n              });\n            } else if (element.type === \"text\") {\n              const textElement = element as TextElement;\n              activeElements.push({\n                id: element.id,\n                type: element.type,\n                startTime: element.startTime,\n                duration: element.duration,\n                trimStart: element.trimStart,\n                trimEnd: element.trimEnd,\n                content: textElement.content,\n                fontSize: textElement.fontSize,\n                fontFamily: textElement.fontFamily,\n                color: textElement.color,\n                backgroundColor: textElement.backgroundColor,\n                x: textElement.x,\n                y: textElement.y,\n                rotation: textElement.rotation,\n                opacity: textElement.opacity,\n              });\n            }\n          }\n        }\n      }\n\n      // Include project settings that affect rendering\n      const projectState = {\n        backgroundColor: activeProject?.backgroundColor,\n        backgroundType: activeProject?.backgroundType,\n        blurIntensity: activeProject?.blurIntensity,\n        canvasSize: activeProject?.canvasSize,\n      };\n\n      const hash = {\n        activeElements,\n        projectState,\n        sceneId,\n        time: Math.floor(time * cacheResolution) / cacheResolution,\n      };\n      return JSON.stringify(hash);\n    },\n    [cacheResolution]\n  );\n\n  // Check if a frame is cached and valid\n  const isFrameCached = useCallback(\n    (\n      time: number,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      sceneId?: string\n    ): boolean => {\n      const frameKey = Math.floor(time * cacheResolution);\n      const cached = frameCacheRef.current.get(frameKey);\n\n      if (!cached) return false;\n\n      const currentHash = getTimelineHash(\n        time,\n        tracks,\n        mediaFiles,\n        activeProject,\n        sceneId\n      );\n      return cached.timelineHash === currentHash;\n    },\n    [getTimelineHash, cacheResolution]\n  );\n\n  // Get cached frame if available and valid\n  const getCachedFrame = useCallback(\n    (\n      time: number,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      sceneId?: string\n    ): ImageData | null => {\n      const frameKey = Math.floor(time * cacheResolution);\n      const cached = frameCacheRef.current.get(frameKey);\n\n      if (!cached) {\n        return null;\n      }\n\n      const currentHash = getTimelineHash(\n        time,\n        tracks,\n        mediaFiles,\n        activeProject,\n        sceneId\n      );\n      console.log(cached.timelineHash === currentHash);\n      if (cached.timelineHash !== currentHash) {\n        // Cache is stale, remove it\n        console.log(\n          \"Cache miss - hash mismatch:\",\n          JSON.stringify({\n            cachedHash: cached.timelineHash.slice(0, 100),\n            currentHash: currentHash.slice(0, 100),\n          })\n        );\n        frameCacheRef.current.delete(frameKey);\n        return null;\n      }\n\n      return cached.imageData;\n    },\n    [getTimelineHash, cacheResolution]\n  );\n\n  // Cache a rendered frame\n  const cacheFrame = useCallback(\n    (\n      time: number,\n      imageData: ImageData,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      sceneId?: string\n    ): void => {\n      const frameKey = Math.floor(time * cacheResolution);\n      const timelineHash = getTimelineHash(\n        time,\n        tracks,\n        mediaFiles,\n        activeProject,\n        sceneId\n      );\n\n      // Enforce cache size limit (LRU eviction)\n      if (frameCacheRef.current.size >= maxCacheSize) {\n        // Remove oldest entries\n        const entries = Array.from(frameCacheRef.current.entries());\n        entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n\n        // Remove oldest 20% of entries\n        const toRemove = Math.floor(entries.length * 0.2);\n        for (let i = 0; i < toRemove; i++) {\n          frameCacheRef.current.delete(entries[i][0]);\n        }\n      }\n\n      frameCacheRef.current.set(frameKey, {\n        imageData,\n        timelineHash,\n        timestamp: Date.now(),\n      });\n    },\n    [getTimelineHash, cacheResolution, maxCacheSize]\n  );\n\n  // Clear cache when timeline changes significantly\n  const invalidateCache = useCallback(() => {\n    frameCacheRef.current.clear();\n  }, []);\n\n  // Get render status for timeline indicator\n  const getRenderStatus = useCallback(\n    (\n      time: number,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      sceneId?: string\n    ): \"cached\" | \"not-cached\" => {\n      return isFrameCached(time, tracks, mediaFiles, activeProject, sceneId)\n        ? \"cached\"\n        : \"not-cached\";\n    },\n    [isFrameCached]\n  );\n\n  // Pre-render frames around current time\n  const preRenderNearbyFrames = useCallback(\n    async (\n      currentTime: number,\n      tracks: TimelineTrack[],\n      mediaFiles: MediaFile[],\n      activeProject: TProject | null,\n      renderFunction: (time: number) => Promise<ImageData>,\n      sceneId?: string,\n      range: number = 3 // seconds\n    ) => {\n      const framesToPreRender: number[] = [];\n\n      // Calculate frames to pre-render (around current time)\n      for (\n        let offset = -range;\n        offset <= range;\n        offset += 1 / cacheResolution\n      ) {\n        const time = currentTime + offset;\n        if (time < 0) continue;\n\n        if (!isFrameCached(time, tracks, mediaFiles, activeProject, sceneId)) {\n          framesToPreRender.push(time);\n        }\n      }\n\n      // Expand to full 1-second buckets to avoid fragmented tiny cache regions\n      const secondsToPreRender = new Set<number>();\n      for (const t of framesToPreRender) {\n        secondsToPreRender.add(Math.floor(t));\n      }\n\n      const expandedTimes: number[] = [];\n      for (const s of secondsToPreRender) {\n        for (let k = 0; k < cacheResolution; k++) {\n          const t = s + k / cacheResolution;\n          if (t < 0) continue;\n          if (!isFrameCached(t, tracks, mediaFiles, activeProject, sceneId)) {\n            expandedTimes.push(t);\n          }\n        }\n      }\n\n      // Sort forward-first near currentTime to improve perceived responsiveness\n      expandedTimes.sort((a, b) => {\n        const da = a >= currentTime ? a - currentTime : currentTime - a + 1e6;\n        const db = b >= currentTime ? b - currentTime : currentTime - b + 1e6;\n        return da - db;\n      });\n\n      // Cap total scheduled renders to avoid jank (e.g., up to 90 frames)\n      const CAP = Math.max(30, Math.min(90, cacheResolution * 3));\n      const toSchedule = expandedTimes.slice(0, CAP);\n\n      // Pre-render during idle time\n      for (const time of toSchedule) {\n        requestIdleCallback(async () => {\n          try {\n            const imageData = await renderFunction(time);\n            cacheFrame(\n              time,\n              imageData,\n              tracks,\n              mediaFiles,\n              activeProject,\n              sceneId\n            );\n          } catch (error) {\n            console.warn(`Pre-render failed for time ${time}:`, error);\n          }\n        });\n      }\n    },\n    [isFrameCached, cacheFrame, cacheResolution]\n  );\n\n  return {\n    isFrameCached,\n    getCachedFrame,\n    cacheFrame,\n    invalidateCache,\n    getRenderStatus,\n    preRenderNearbyFrames,\n    cacheSize: frameCacheRef.current.size,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1552, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-keyboard-shortcuts-help.ts"],"sourcesContent":["\"use client\";\n\nimport { useMemo } from \"react\";\nimport { useKeybindingsStore } from \"@/stores/keybindings-store\";\nimport { Action } from \"@/constants/actions\";\nimport { getPlatformAlternateKey, getPlatformSpecialKey } from \"@/lib/utils\";\n\nexport interface KeyboardShortcut {\n  id: string;\n  keys: string[];\n  description: string;\n  category: string;\n  action: Action;\n  icon?: React.ReactNode;\n}\n\n// Map actions to their descriptions and categories\nconst actionDescriptions: Record<\n  Action,\n  { description: string; category: string }\n> = {\n  \"toggle-play\": { description: \"Play/Pause\", category: \"Playback\" },\n  \"stop-playback\": { description: \"Stop playback\", category: \"Playback\" },\n  \"seek-forward\": {\n    description: \"Seek forward 1 second\",\n    category: \"Playback\",\n  },\n  \"seek-backward\": {\n    description: \"Seek backward 1 second\",\n    category: \"Playback\",\n  },\n  \"frame-step-forward\": {\n    description: \"Frame step forward\",\n    category: \"Navigation\",\n  },\n  \"frame-step-backward\": {\n    description: \"Frame step backward\",\n    category: \"Navigation\",\n  },\n  \"jump-forward\": {\n    description: \"Jump forward 5 seconds\",\n    category: \"Navigation\",\n  },\n  \"jump-backward\": {\n    description: \"Jump backward 5 seconds\",\n    category: \"Navigation\",\n  },\n  \"goto-start\": { description: \"Go to timeline start\", category: \"Navigation\" },\n  \"goto-end\": { description: \"Go to timeline end\", category: \"Navigation\" },\n  \"split-element\": {\n    description: \"Split element at playhead\",\n    category: \"Editing\",\n  },\n  \"delete-selected\": {\n    description: \"Delete selected elements\",\n    category: \"Editing\",\n  },\n  \"select-all\": { description: \"Select all elements\", category: \"Selection\" },\n  \"duplicate-selected\": {\n    description: \"Duplicate selected element\",\n    category: \"Selection\",\n  },\n  \"toggle-snapping\": { description: \"Toggle snapping\", category: \"Editing\" },\n  undo: { description: \"Undo\", category: \"History\" },\n  redo: { description: \"Redo\", category: \"History\" },\n  \"copy-selected\": {\n    description: \"Copy selected elements\",\n    category: \"Editing\",\n  },\n  \"paste-selected\": {\n    description: \"Paste elements at playhead\",\n    category: \"Editing\",\n  },\n};\n\n// Convert key binding format to display format\nconst formatKey = (key: string): string => {\n  return key\n    .replace(\"ctrl\", getPlatformSpecialKey())\n    .replace(\"alt\", getPlatformAlternateKey())\n    .replace(\"shift\", \"Shift\")\n    .replace(\"left\", \"\")\n    .replace(\"right\", \"\")\n    .replace(\"up\", \"\")\n    .replace(\"down\", \"\")\n    .replace(\"space\", \"Space\")\n    .replace(\"home\", \"Home\")\n    .replace(\"enter\", \"Enter\")\n    .replace(\"end\", \"End\")\n    .replace(\"delete\", \"Delete\")\n    .replace(\"backspace\", \"Backspace\")\n    .replace(\"-\", \"+\");\n};\n\nexport const useKeyboardShortcutsHelp = () => {\n  const { keybindings } = useKeybindingsStore();\n\n  const shortcuts = useMemo(() => {\n    const result: KeyboardShortcut[] = [];\n\n    // Group keybindings by action\n    const actionToKeys: Record<Action, string[]> = {} as any;\n\n    Object.entries(keybindings).forEach(([key, action]) => {\n      if (action) {\n        if (!actionToKeys[action]) {\n          actionToKeys[action] = [];\n        }\n        actionToKeys[action].push(formatKey(key));\n      }\n    });\n\n    // Convert to shortcuts format\n    Object.entries(actionToKeys).forEach(([action, keys]) => {\n      const actionInfo = actionDescriptions[action as Action];\n      if (actionInfo) {\n        result.push({\n          id: action,\n          keys,\n          description: actionInfo.description,\n          category: actionInfo.category,\n          action: action as Action,\n        });\n      }\n    });\n\n    // Sort shortcuts by category first, then by description to ensure consistent ordering\n    return result.sort((a, b) => {\n      if (a.category !== b.category) {\n        return a.category.localeCompare(b.category);\n      }\n      return a.description.localeCompare(b.description);\n    });\n  }, [keybindings]);\n\n  return {\n    shortcuts,\n  };\n};\n"],"names":[],"mappings":";;;AAEA;AACA;AAEA;;AALA;;;;AAgBA,mDAAmD;AACnD,MAAM,qBAGF;IACF,eAAe;QAAE,aAAa;QAAc,UAAU;IAAW;IACjE,iBAAiB;QAAE,aAAa;QAAiB,UAAU;IAAW;IACtE,gBAAgB;QACd,aAAa;QACb,UAAU;IACZ;IACA,iBAAiB;QACf,aAAa;QACb,UAAU;IACZ;IACA,sBAAsB;QACpB,aAAa;QACb,UAAU;IACZ;IACA,uBAAuB;QACrB,aAAa;QACb,UAAU;IACZ;IACA,gBAAgB;QACd,aAAa;QACb,UAAU;IACZ;IACA,iBAAiB;QACf,aAAa;QACb,UAAU;IACZ;IACA,cAAc;QAAE,aAAa;QAAwB,UAAU;IAAa;IAC5E,YAAY;QAAE,aAAa;QAAsB,UAAU;IAAa;IACxE,iBAAiB;QACf,aAAa;QACb,UAAU;IACZ;IACA,mBAAmB;QACjB,aAAa;QACb,UAAU;IACZ;IACA,cAAc;QAAE,aAAa;QAAuB,UAAU;IAAY;IAC1E,sBAAsB;QACpB,aAAa;QACb,UAAU;IACZ;IACA,mBAAmB;QAAE,aAAa;QAAmB,UAAU;IAAU;IACzE,MAAM;QAAE,aAAa;QAAQ,UAAU;IAAU;IACjD,MAAM;QAAE,aAAa;QAAQ,UAAU;IAAU;IACjD,iBAAiB;QACf,aAAa;QACb,UAAU;IACZ;IACA,kBAAkB;QAChB,aAAa;QACb,UAAU;IACZ;AACF;AAEA,+CAA+C;AAC/C,MAAM,YAAY,CAAC;IACjB,OAAO,IACJ,OAAO,CAAC,QAAQ,CAAA,GAAA,qIAAA,CAAA,wBAAqB,AAAD,KACpC,OAAO,CAAC,OAAO,CAAA,GAAA,qIAAA,CAAA,0BAAuB,AAAD,KACrC,OAAO,CAAC,SAAS,SACjB,OAAO,CAAC,QAAQ,KAChB,OAAO,CAAC,SAAS,KACjB,OAAO,CAAC,MAAM,KACd,OAAO,CAAC,QAAQ,KAChB,OAAO,CAAC,SAAS,SACjB,OAAO,CAAC,QAAQ,QAChB,OAAO,CAAC,SAAS,SACjB,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,UAAU,UAClB,OAAO,CAAC,aAAa,aACrB,OAAO,CAAC,KAAK;AAClB;AAEO,MAAM,2BAA2B;;IACtC,MAAM,EAAE,WAAW,EAAE,GAAG,CAAA,GAAA,uJAAA,CAAA,sBAAmB,AAAD;IAE1C,MAAM,YAAY,CAAA,GAAA,kOAAA,CAAA,UAAO,AAAD;uDAAE;YACxB,MAAM,SAA6B,EAAE;YAErC,8BAA8B;YAC9B,MAAM,eAAyC,CAAC;YAEhD,OAAO,OAAO,CAAC,aAAa,OAAO;+DAAC;wBAAC,CAAC,KAAK,OAAO;oBAChD,IAAI,QAAQ;wBACV,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE;4BACzB,YAAY,CAAC,OAAO,GAAG,EAAE;wBAC3B;wBACA,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU;oBACtC;gBACF;;YAEA,8BAA8B;YAC9B,OAAO,OAAO,CAAC,cAAc,OAAO;+DAAC;wBAAC,CAAC,QAAQ,KAAK;oBAClD,MAAM,aAAa,kBAAkB,CAAC,OAAiB;oBACvD,IAAI,YAAY;wBACd,OAAO,IAAI,CAAC;4BACV,IAAI;4BACJ;4BACA,aAAa,WAAW,WAAW;4BACnC,UAAU,WAAW,QAAQ;4BAC7B,QAAQ;wBACV;oBACF;gBACF;;YAEA,sFAAsF;YACtF,OAAO,OAAO,IAAI;+DAAC,CAAC,GAAG;oBACrB,IAAI,EAAE,QAAQ,KAAK,EAAE,QAAQ,EAAE;wBAC7B,OAAO,EAAE,QAAQ,CAAC,aAAa,CAAC,EAAE,QAAQ;oBAC5C;oBACA,OAAO,EAAE,WAAW,CAAC,aAAa,CAAC,EAAE,WAAW;gBAClD;;QACF;sDAAG;QAAC;KAAY;IAEhB,OAAO;QACL;IACF;AACF;GA5Ca;;QACa,uJAAA,CAAA,sBAAmB","debugId":null}},
    {"offset": {"line": 1712, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-keybindings.ts"],"sourcesContent":["import { useEffect } from \"react\";\nimport { invokeAction } from \"../constants/actions\";\nimport { useKeybindingsStore } from \"@/stores/keybindings-store\";\n\n/**\n * A composable that hooks to the caller component's\n * lifecycle and hooks to the keyboard events to fire\n * the appropriate actions based on keybindings\n */\nexport function useKeybindingsListener() {\n  const { keybindings, getKeybindingString, keybindingsEnabled, isRecording } =\n    useKeybindingsStore();\n\n  useEffect(() => {\n    const handleKeyDown = (ev: KeyboardEvent) => {\n      // Do not check keybinds if the mode is disabled\n      if (!keybindingsEnabled) return;\n      // ignore key events if user is changing keybindings\n      if (isRecording) return;\n\n      const binding = getKeybindingString(ev);\n      if (!binding) return;\n\n      const boundAction = keybindings[binding];\n      if (!boundAction) return;\n\n      const activeElement = document.activeElement;\n      const isTextInput =\n        activeElement &&\n        (activeElement.tagName === \"INPUT\" ||\n          activeElement.tagName === \"TEXTAREA\" ||\n          (activeElement as HTMLElement).isContentEditable);\n\n      if (isTextInput) return;\n\n      ev.preventDefault();\n\n      // Handle actions with default arguments\n      let actionArgs: any;\n\n      if (boundAction === \"seek-forward\") {\n        actionArgs = { seconds: 1 };\n      } else if (boundAction === \"seek-backward\") {\n        actionArgs = { seconds: 1 };\n      } else if (boundAction === \"jump-forward\") {\n        actionArgs = { seconds: 5 };\n      } else if (boundAction === \"jump-backward\") {\n        actionArgs = { seconds: 5 };\n      }\n\n      invokeAction(boundAction, actionArgs, \"keypress\");\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, [keybindings, getKeybindingString, keybindingsEnabled, isRecording]);\n}\n\n/**\n * This composable allows for the UI component to be disabled if the component in question is mounted\n */\nexport function useKeybindingDisabler() {\n  const { disableKeybindings, enableKeybindings } = useKeybindingsStore();\n\n  return {\n    disableKeybindings,\n    enableKeybindings,\n  };\n}\n\n// Export the bindings for backward compatibility\nexport const bindings = {};\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;;AAOO,SAAS;;IACd,MAAM,EAAE,WAAW,EAAE,mBAAmB,EAAE,kBAAkB,EAAE,WAAW,EAAE,GACzE,CAAA,GAAA,uJAAA,CAAA,sBAAmB,AAAD;IAEpB,CAAA,GAAA,kOAAA,CAAA,YAAS,AAAD;4CAAE;YACR,MAAM;kEAAgB,CAAC;oBACrB,gDAAgD;oBAChD,IAAI,CAAC,oBAAoB;oBACzB,oDAAoD;oBACpD,IAAI,aAAa;oBAEjB,MAAM,UAAU,oBAAoB;oBACpC,IAAI,CAAC,SAAS;oBAEd,MAAM,cAAc,WAAW,CAAC,QAAQ;oBACxC,IAAI,CAAC,aAAa;oBAElB,MAAM,gBAAgB,SAAS,aAAa;oBAC5C,MAAM,cACJ,iBACA,CAAC,cAAc,OAAO,KAAK,WACzB,cAAc,OAAO,KAAK,cAC1B,AAAC,cAA8B,iBAAiB;oBAEpD,IAAI,aAAa;oBAEjB,GAAG,cAAc;oBAEjB,wCAAwC;oBACxC,IAAI;oBAEJ,IAAI,gBAAgB,gBAAgB;wBAClC,aAAa;4BAAE,SAAS;wBAAE;oBAC5B,OAAO,IAAI,gBAAgB,iBAAiB;wBAC1C,aAAa;4BAAE,SAAS;wBAAE;oBAC5B,OAAO,IAAI,gBAAgB,gBAAgB;wBACzC,aAAa;4BAAE,SAAS;wBAAE;oBAC5B,OAAO,IAAI,gBAAgB,iBAAiB;wBAC1C,aAAa;4BAAE,SAAS;wBAAE;oBAC5B;oBAEA,CAAA,GAAA,6IAAA,CAAA,eAAY,AAAD,EAAE,aAAa,YAAY;gBACxC;;YAEA,SAAS,gBAAgB,CAAC,WAAW;YAErC;oDAAO;oBACL,SAAS,mBAAmB,CAAC,WAAW;gBAC1C;;QACF;2CAAG;QAAC;QAAa;QAAqB;QAAoB;KAAY;AACxE;GAlDgB;;QAEZ,uJAAA,CAAA,sBAAmB;;;AAqDhB,SAAS;;IACd,MAAM,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,GAAG,CAAA,GAAA,uJAAA,CAAA,sBAAmB,AAAD;IAEpE,OAAO;QACL;QACA;IACF;AACF;IAPgB;;QACoC,uJAAA,CAAA,sBAAmB;;;AAShE,MAAM,WAAW,CAAC","debugId":null}},
    {"offset": {"line": 1807, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-editor-actions.ts"],"sourcesContent":["\"use client\";\n\nimport { useEffect } from \"react\";\nimport { useActionHandler } from \"@/constants/actions\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { usePlaybackStore } from \"@/stores/playback-store\";\nimport { DEFAULT_FPS, useProjectStore } from \"@/stores/project-store\";\nimport { toast } from \"sonner\";\n\nexport function useEditorActions() {\n  const {\n    tracks,\n    selectedElements,\n    clearSelectedElements,\n    setSelectedElements,\n    deleteSelected,\n    splitSelected,\n    addElementToTrack,\n    snappingEnabled,\n    toggleSnapping,\n    undo,\n    redo,\n  } = useTimelineStore();\n\n  const { currentTime, duration, isPlaying, toggle, seek } = usePlaybackStore();\n  const { activeProject } = useProjectStore();\n\n  // Playback actions\n  useActionHandler(\n    \"toggle-play\",\n    () => {\n      toggle();\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"stop-playback\",\n    () => {\n      if (isPlaying) {\n        toggle();\n      }\n      seek(0);\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"seek-forward\",\n    (args) => {\n      const seconds = args?.seconds ?? 1;\n      seek(Math.min(duration, currentTime + seconds));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"seek-backward\",\n    (args) => {\n      const seconds = args?.seconds ?? 1;\n      seek(Math.max(0, currentTime - seconds));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"frame-step-forward\",\n    () => {\n      const projectFps = activeProject?.fps || DEFAULT_FPS;\n      seek(Math.min(duration, currentTime + 1 / projectFps));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"frame-step-backward\",\n    () => {\n      const projectFps = activeProject?.fps || DEFAULT_FPS;\n      seek(Math.max(0, currentTime - 1 / projectFps));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"jump-forward\",\n    (args) => {\n      const seconds = args?.seconds ?? 5;\n      seek(Math.min(duration, currentTime + seconds));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"jump-backward\",\n    (args) => {\n      const seconds = args?.seconds ?? 5;\n      seek(Math.max(0, currentTime - seconds));\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"goto-start\",\n    () => {\n      seek(0);\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"goto-end\",\n    () => {\n      seek(duration);\n    },\n    undefined\n  );\n\n  // Timeline editing actions\n  useActionHandler(\n    \"split-element\",\n    () => {\n      if (selectedElements.length !== 1) {\n        toast.error(\"Select exactly one element to split\");\n        return;\n      }\n\n      const { trackId, elementId } = selectedElements[0];\n      const track = tracks.find((t: any) => t.id === trackId);\n      const element = track?.elements.find((el: any) => el.id === elementId);\n\n      if (element) {\n        const effectiveStart = element.startTime;\n        const effectiveEnd =\n          element.startTime +\n          (element.duration - element.trimStart - element.trimEnd);\n\n        if (currentTime > effectiveStart && currentTime < effectiveEnd) {\n          splitSelected(currentTime, trackId, elementId);\n        } else {\n          toast.error(\"Playhead must be within selected element\");\n        }\n      }\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"delete-selected\",\n    () => {\n      if (selectedElements.length === 0) {\n        return;\n      }\n      deleteSelected();\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"select-all\",\n    () => {\n      const allElements = tracks.flatMap((track: any) =>\n        track.elements.map((element: any) => ({\n          trackId: track.id,\n          elementId: element.id,\n        }))\n      );\n      setSelectedElements(allElements);\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"duplicate-selected\",\n    () => {\n      if (selectedElements.length !== 1) {\n        toast.error(\"Select exactly one element to duplicate\");\n        return;\n      }\n\n      const { trackId, elementId } = selectedElements[0];\n      const track = tracks.find((t: any) => t.id === trackId);\n      const element = track?.elements.find((el: any) => el.id === elementId);\n\n      if (element) {\n        const newStartTime =\n          element.startTime +\n          (element.duration - element.trimStart - element.trimEnd) +\n          0.1;\n        const { id, ...elementWithoutId } = element;\n\n        addElementToTrack(trackId, {\n          ...elementWithoutId,\n          startTime: newStartTime,\n        });\n      }\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"copy-selected\",\n    () => {\n      if (selectedElements.length === 0) return;\n      useTimelineStore.getState().copySelected();\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"paste-selected\",\n    () => {\n      useTimelineStore.getState().pasteAtTime(currentTime);\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"toggle-snapping\",\n    () => {\n      toggleSnapping();\n    },\n    undefined\n  );\n\n  // History actions\n  useActionHandler(\n    \"undo\",\n    () => {\n      undo();\n    },\n    undefined\n  );\n\n  useActionHandler(\n    \"redo\",\n    () => {\n      redo();\n    },\n    undefined\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2023, "column": 0}, "map": {"version":3,"sources":["file:///C:/shawn/1code/1project-cur/video-remake/clip/OpenCut-main/apps/web/src/hooks/use-playback-controls.ts"],"sourcesContent":["import { useEffect, useCallback } from \"react\";\nimport { usePlaybackStore } from \"@/stores/playback-store\";\nimport { useTimelineStore } from \"@/stores/timeline-store\";\nimport { toast } from \"sonner\";\n\nexport const usePlaybackControls = () => {\n  const { isPlaying, currentTime, play, pause, seek } = usePlaybackStore();\n\n  const {\n    selectedElements,\n    tracks,\n    splitSelected,\n    splitAndKeepLeft,\n    splitAndKeepRight,\n    separateAudio,\n  } = useTimelineStore();\n\n  const handleSplitSelectedElement = useCallback(() => {\n    if (selectedElements.length !== 1) {\n      toast.error(\"Select exactly one element to split\");\n      return;\n    }\n\n    const { trackId, elementId } = selectedElements[0];\n    const track = tracks.find((t) => t.id === trackId);\n    const element = track?.elements.find((e) => e.id === elementId);\n\n    if (!element) return;\n\n    const effectiveStart = element.startTime;\n    const effectiveEnd =\n      element.startTime +\n      (element.duration - element.trimStart - element.trimEnd);\n\n    if (currentTime <= effectiveStart || currentTime >= effectiveEnd) {\n      toast.error(\"Playhead must be within selected element\");\n      return;\n    }\n\n    splitSelected(currentTime, trackId, elementId);\n  }, [selectedElements, tracks, currentTime, splitSelected]);\n\n  const handleSplitAndKeepLeftCallback = useCallback(() => {\n    if (selectedElements.length !== 1) {\n      toast.error(\"Select exactly one element\");\n      return;\n    }\n\n    const { trackId, elementId } = selectedElements[0];\n    const track = tracks.find((t) => t.id === trackId);\n    const element = track?.elements.find((e) => e.id === elementId);\n\n    if (!element) return;\n\n    const effectiveStart = element.startTime;\n    const effectiveEnd =\n      element.startTime +\n      (element.duration - element.trimStart - element.trimEnd);\n\n    if (currentTime <= effectiveStart || currentTime >= effectiveEnd) {\n      toast.error(\"Playhead must be within selected element\");\n      return;\n    }\n\n    splitAndKeepLeft(trackId, elementId, currentTime);\n  }, [selectedElements, tracks, currentTime, splitAndKeepLeft]);\n\n  const handleSplitAndKeepRightCallback = useCallback(() => {\n    if (selectedElements.length !== 1) {\n      toast.error(\"Select exactly one element\");\n      return;\n    }\n\n    const { trackId, elementId } = selectedElements[0];\n    const track = tracks.find((t) => t.id === trackId);\n    const element = track?.elements.find((e) => e.id === elementId);\n\n    if (!element) return;\n\n    const effectiveStart = element.startTime;\n    const effectiveEnd =\n      element.startTime +\n      (element.duration - element.trimStart - element.trimEnd);\n\n    if (currentTime <= effectiveStart || currentTime >= effectiveEnd) {\n      toast.error(\"Playhead must be within selected element\");\n      return;\n    }\n\n    splitAndKeepRight(trackId, elementId, currentTime);\n  }, [selectedElements, tracks, currentTime, splitAndKeepRight]);\n\n  const handleSeparateAudioCallback = useCallback(() => {\n    if (selectedElements.length !== 1) {\n      toast.error(\"Select exactly one media element to separate audio\");\n      return;\n    }\n\n    const { trackId, elementId } = selectedElements[0];\n    const track = tracks.find((t) => t.id === trackId);\n\n    if (!track || track.type !== \"media\") {\n      toast.error(\"Select a media element to separate audio\");\n      return;\n    }\n\n    separateAudio(trackId, elementId);\n  }, [selectedElements, tracks, separateAudio]);\n};\n"],"names":[],"mappings":"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","debugId":null}}]
}